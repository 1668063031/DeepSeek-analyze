slug,code,radon
largest-number-after-digit-swaps-by-parity,"```python
class Solution:
    def largestInteger(self, num: int) -> int:
        digits = list(str(num))
        n = len(digits)
        for i in range(n):
            for j in range(i + 1, n):
                if int(digits[i]) % 2 == int(digits[j]) % 2 and int(digits[i]) < int(digits[j]):
                    digits[i], digits[j] = digits[j], digits[i]
        return int(''.join(digits))
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 1}, {'name': 'largestInteger', 'complexity': 5, 'lineno': 2}], 'maintainability_index': 65.37210411009929, 'raw_metrics': {'loc': 9, 'lloc': 9, 'sloc': 9, 'comments': 0}}"
smallest-divisible-digit-product-i,"```python
class Solution:
    def smallestNumber(self, n: int, t: int) -> int:
        def product_digits(num):
            product = 1
            for digit in str(num):
                product *= int(digit)
            return product
        
        while True:
            if product_digits(n) % t == 0:
                return n
            n += 1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'smallestNumber', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 65.30613586505524, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
minimize-xor,"```python
class Solution:
    def minimizeXor(self, num1: int, num2: int) -> int:
        count = bin(num2).count('1')
        num1_bits = bin(num1)[2:]
        res = ['0'] * len(num1_bits)
        
        for i in range(len(num1_bits)):
            if count == 0:
                break
            if num1_bits[i] == '1':
                res[i] = '1'
                count -= 1
        
        for i in range(len(num1_bits) - 1, -1, -1):
            if count == 0:
                break
            if res[i] == '0':
                res[i] = '1'
                count -= 1
        
        remaining_bits = []
        while count > 0:
            remaining_bits.append('1')
            count -= 1
        res = remaining_bits + res
        
        return int(''.join(res), 2)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 1}, {'name': 'minimizeXor', 'complexity': 8, 'lineno': 2}], 'maintainability_index': 53.35888008223389, 'raw_metrics': {'loc': 23, 'lloc': 24, 'sloc': 23, 'comments': 0}}"
final-value-of-variable-after-performing-operations,"```python
class Solution:
    def finalValueAfterOperations(self, operations: List[str]) -> int:
        x = 0
        for op in operations:
            if op in (""++X"", ""X++""):
                x += 1
            else:
                x -= 1
        return x
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'finalValueAfterOperations', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 67.82742192357686, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
maximum-running-time-of-n-computers,"```python
from typing import List

class Solution:
    def maxRunTime(self, n: int, batteries: List[int]) -> int:
        left, right = 1, sum(batteries) // n
        
        while left < right:
            mid = (left + right + 1) // 2
            total = 0
            for bat in batteries:
                total += min(bat, mid)
                if total >= mid * n:
                    break
            if total >= mid * n:
                left = mid
            else:
                right = mid - 1
        return left
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'maxRunTime', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 57.32085506556965, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
find-minimum-diameter-after-merging-two-trees,"```python
from collections import deque
from typing import List

class Solution:
    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:
        def build_tree(edges):
            tree = {}
            for u, v in edges:
                if u not in tree:
                    tree[u] = []
                if v not in tree:
                    tree[v] = []
                tree[u].append(v)
                tree[v].append(u)
            return tree
        
        def get_tree_properties(tree):
            if not tree:
                return (0, 0, [])
            
            def bfs(start):
                visited = {}
                q = deque()
                q.append((start, 0))
                visited[start] = True
                farthest_node = start
                max_dist = 0
                while q:
                    node, dist = q.popleft()
                    if dist > max_dist:
                        max_dist = dist
                        farthest_node = node
                    for neighbor in tree.get(node, []):
                        if neighbor not in visited:
                            visited[neighbor] = True
                            q.append((neighbor, dist + 1))
                return farthest_node, max_dist
            
            node, _ = bfs(next(iter(tree.keys())))
            node, diameter = bfs(node)
            center_nodes = []
            
            def find_centers():
                leaves = deque()
                degree = {}
                for node in tree:
                    degree[node] = len(tree[node])
                    if degree[node] == 1:
                        leaves.append(node)
                total_nodes = len(tree)
                while total_nodes > 2:
                    for _ in range(len(leaves)):
                        leaf = leaves.popleft()
                        for neighbor in tree[leaf]:
                            degree[neighbor] -= 1
                            if degree[neighbor] == 1:
                                leaves.append(neighbor)
                        total_nodes -= 1
                return list(leaves)
            
            center_nodes = find_centers()
            radius = (diameter + 1) // 2
            return (diameter, radius, center_nodes)
        
        tree1 = build_tree(edges1)
        tree2 = build_tree(edges2)
        
        d1, r1, centers1 = get_tree_properties(tree1)
        d2, r2, centers2 = get_tree_properties(tree2)
        
        min_diameter = max(d1, d2, r1 + r2 + 1)
        return min_diameter
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 4}, {'name': 'minimumDiameterAfterMerge', 'complexity': 1, 'lineno': 5}], 'maintainability_index': 43.98653658159397, 'raw_metrics': {'loc': 64, 'lloc': 64, 'sloc': 64, 'comments': 0}}"
minimum-edge-reversals-so-every-node-is-reachable,"```python
from typing import List
from collections import defaultdict, deque

class Solution:
    def minEdgeReversals(self, n: int, edges: List[List[int]]) -> List[int]:
        graph = defaultdict(list)
        reverse_graph = defaultdict(list)
        for u, v in edges:
            graph[u].append((v, 0))  # 0 indicates no reversal needed
            reverse_graph[v].append((u, 1))  # 1 indicates reversal needed
        
        root = 0
        res = [0] * n
        q = deque([root])
        visited = [False] * n
        visited[root] = True
        count = 0
        
        parent = [-1] * n
        children = defaultdict(list)
        stack = [root]
        visited_tree = [False] * n
        visited_tree[root] = True
        while stack:
            u = stack.pop()
            for v, cost in graph[u]:
                if not visited_tree[v]:
                    parent[v] = u
                    children[u].append((v, cost))
                    visited_tree[v] = True
                    stack.append(v)
            for v, cost in reverse_graph[u]:
                if not visited_tree[v]:
                    parent[v] = u
                    children[u].append((v, cost))
                    visited_tree[v] = True
                    stack.append(v)
        
        stack = [(root, 0)]
        total = 0
        while stack:
            u, cost = stack.pop()
            total += cost
            for v, c in children[u]:
                stack.append((v, c))
        res[root] = total
        
        stack = [(root, children[root])]
        while stack:
            u, child_list = stack[-1]
            if not child_list:
                stack.pop()
                continue
            v, cost = child_list.pop()
            res[v] = res[u] + (1 - cost) - cost
            stack.append((v, children[v]))
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 4}, {'name': 'minEdgeReversals', 'complexity': 11, 'lineno': 5}], 'maintainability_index': 57.10496213628071, 'raw_metrics': {'loc': 53, 'lloc': 53, 'sloc': 53, 'comments': 2}}"
split-the-array-to-make-coprime-products,"```python
import math
from collections import defaultdict

class Solution:
    def findValidSplit(self, nums: List[int]) -> int:
        def get_prime_factors(x):
            factors = set()
            if x == 1:
                return factors
            while x % 2 == 0:
                factors.add(2)
                x = x // 2
            i = 3
            max_factor = math.sqrt(x) + 1
            while i <= max_factor:
                while x % i == 0:
                    factors.add(i)
                    x = x // i
                    max_factor = math.sqrt(x) + 1
                i += 2
            if x > 1:
                factors.add(x)
            return factors
        
        n = len(nums)
        if n == 1:
            return -1
        
        left_primes = defaultdict(int)
        right_primes = defaultdict(int)
        
        for num in nums:
            primes = get_prime_factors(num)
            for p in primes:
                right_primes[p] += 1
        
        current_primes = set()
        for i in range(n - 1):
            num = nums[i]
            primes = get_prime_factors(num)
            for p in primes:
                current_primes.add(p)
                right_primes[p] -= 1
                if right_primes[p] == 0:
                    del right_primes[p]
            
            valid = True
            for p in current_primes:
                if p in right_primes:
                    valid = False
                    break
            if valid:
                return i
        
        return -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 4}, {'name': 'findValidSplit', 'complexity': 10, 'lineno': 5}], 'maintainability_index': 44.56170042342738, 'raw_metrics': {'loc': 49, 'lloc': 49, 'sloc': 49, 'comments': 0}}"
mark-elements-on-array-by-performing-queries,"```python
import heapq
from typing import List

class Solution:
    def unmarkedSumArray(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        n = len(nums)
        marked = [False] * n
        total_sum = sum(nums)
        marked_sum = 0
        
        heap = []
        for i in range(n):
            heapq.heappush(heap, (nums[i], i))
        
        res = []
        for index, k in queries:
            if not marked[index]:
                marked[index] = True
                marked_sum += nums[index]
            
            count = 0
            temp = []
            while heap and count < k:
                val, i = heapq.heappop(heap)
                if not marked[i]:
                    marked[i] = True
                    marked_sum += val
                    count += 1
                else:
                    temp.append((val, i))
            
            for val, i in temp:
                heapq.heappush(heap, (val, i))
            
            res.append(total_sum - marked_sum)
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 4}, {'name': 'unmarkedSumArray', 'complexity': 8, 'lineno': 5}], 'maintainability_index': 52.07006470964124, 'raw_metrics': {'loc': 31, 'lloc': 31, 'sloc': 31, 'comments': 0}}"
count-the-number-of-fair-pairs,"```python
class Solution:
    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:
        nums.sort()
        n = len(nums)
        res = 0
        
        for i in range(n):
            left = i + 1
            right = n - 1
            lower_bound = lower - nums[i]
            upper_bound = upper - nums[i]
            
            l = left
            r = right
            low_pos = n
            while l <= r:
                mid = (l + r) // 2
                if nums[mid] >= lower_bound:
                    low_pos = mid
                    r = mid - 1
                else:
                    l = mid + 1
            
            l = left
            r = right
            high_pos = -1
            while l <= r:
                mid = (l + r) // 2
                if nums[mid] <= upper_bound:
                    high_pos = mid
                    l = mid + 1
                else:
                    r = mid - 1
            
            if low_pos <= high_pos:
                res += high_pos - low_pos + 1
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 2}, {'name': 'countFairPairs', 'complexity': 7, 'lineno': 3}], 'maintainability_index': 48.19128432270804, 'raw_metrics': {'loc': 34, 'lloc': 34, 'sloc': 34, 'comments': 0}}"
maximize-score-of-numbers-in-ranges,"```python
from typing import List

class Solution:
    def maxPossibleScore(self, start: List[int], d: int) -> int:
        intervals = [(s, s + d) for s in start]
        intervals.sort()
        n = len(intervals)
        low = 0
        high = intervals[-1][1] - intervals[0][0]
        answer = 0
        
        def is_possible(mid):
            prev = intervals[0][0]
            count = 1
            for i in range(1, n):
                current_start, current_end = intervals[i]
                target = prev + mid
                if target <= current_end:
                    prev = max(target, current_start)
                    count += 1
                else:
                    return False
            return count == n
        
        while low <= high:
            mid = (low + high) // 2
            if is_possible(mid):
                answer = mid
                low = mid + 1
            else:
                high = mid - 1
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'maxPossibleScore', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 51.70434732021675, 'raw_metrics': {'loc': 30, 'lloc': 30, 'sloc': 30, 'comments': 0}}"
minimum-fuel-cost-to-report-to-the-capital,"```python
from typing import List
from collections import defaultdict, deque

class Solution:
    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:
        if not roads:
            return 0
        
        graph = defaultdict(list)
        for a, b in roads:
            graph[a].append(b)
            graph[b].append(a)
        
        parent = {}
        children = defaultdict(list)
        queue = deque([0])
        parent[0] = -1
        
        while queue:
            node = queue.popleft()
            for neighbor in graph[node]:
                if neighbor != parent[node]:
                    parent[neighbor] = node
                    children[node].append(neighbor)
                    queue.append(neighbor)
        
        fuel = 0
        
        def dfs(node):
            nonlocal fuel
            total_people = 1
            for child in children[node]:
                people = dfs(child)
                total_people += people
                fuel += (people + seats - 1) // seats
            return total_people
        
        dfs(0)
        return fuel
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 4}, {'name': 'minimumFuelCost', 'complexity': 6, 'lineno': 5}], 'maintainability_index': 52.19186367531368, 'raw_metrics': {'loc': 33, 'lloc': 33, 'sloc': 33, 'comments': 0}}"
string-compression-ii,"```python
class Solution:
    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        memo = {}
        
        def dp(i, last_char, last_count, left):
            if (i, last_char, last_count, left) in memo:
                return memo[(i, last_char, last_count, left)]
            if left < 0:
                return float('inf')
            if i == len(s):
                return 0
            res = float('inf')
            res = min(res, dp(i + 1, last_char, last_count, left - 1))
            if s[i] == last_char:
                carry = 0
                if last_count == 1 or last_count == 9 or last_count == 99:
                    carry = 1
                res = min(res, carry + dp(i + 1, last_char, last_count + 1, left))
            else:
                res = min(res, 1 + dp(i + 1, s[i], 1, left))
            memo[(i, last_char, last_count, left)] = res
            return res
        
        return dp(0, """", 0, k)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 1}, {'name': 'getLengthOfOptimalCompression', 'complexity': 1, 'lineno': 2}], 'maintainability_index': 54.174099984510676, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
distribute-elements-into-two-arrays-ii,"```python
import bisect

class Solution:
    def resultArray(self, nums: List[int]) -> List[int]:
        arr1 = [nums[0]]
        arr1_sorted = [nums[0]]
        arr2 = [nums[1]]
        arr2_sorted = [nums[1]]
        
        for num in nums[2:]:
            cnt1 = len(arr1_sorted) - bisect.bisect_right(arr1_sorted, num)
            cnt2 = len(arr2_sorted) - bisect.bisect_right(arr2_sorted, num)
            
            if cnt1 > cnt2:
                bisect.insort(arr1_sorted, num)
                arr1.append(num)
            elif cnt1 < cnt2:
                bisect.insort(arr2_sorted, num)
                arr2.append(num)
            else:
                if len(arr1) <= len(arr2):
                    bisect.insort(arr1_sorted, num)
                    arr1.append(num)
                else:
                    bisect.insort(arr2_sorted, num)
                    arr2.append(num)
        
        return arr1 + arr2
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'resultArray', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 55.76492459982643, 'raw_metrics': {'loc': 25, 'lloc': 25, 'sloc': 25, 'comments': 0}}"
maximum-number-of-non-overlapping-substrings,"```python
class Solution:
    def maxNumOfSubstrings(self, s: str) -> List[str]:
        first = {}
        last = {}
        for i, c in enumerate(s):
            if c not in first:
                first[c] = i
            last[c] = i
        
        intervals = []
        for c in first:
            start = first[c]
            end = last[c]
            left, right = start, end
            changed = True
            while changed:
                changed = False
                new_left, new_right = left, right
                for i in range(left, right + 1):
                    char = s[i]
                    new_left = min(new_left, first[char])
                    new_right = max(new_right, last[char])
                if new_left != left or new_right != right:
                    changed = True
                    left, right = new_left, new_right
            intervals.append((left, right))
        
        intervals = list(set(intervals))
        intervals.sort(key=lambda x: x[1])
        
        res = []
        prev_end = -1
        for start, end in intervals:
            if start > prev_end:
                res.append(s[start:end+1])
                prev_end = end
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 2}, {'name': 'maxNumOfSubstrings', 'complexity': 10, 'lineno': 3}], 'maintainability_index': 50.434789491426095, 'raw_metrics': {'loc': 35, 'lloc': 37, 'sloc': 35, 'comments': 0}}"
maximum-number-of-operations-with-the-same-score-ii,"```python
from typing import List

class Solution:
    def maxOperations(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 2:
            return 0
        
        def helper(start, end, target, memo):
            if start >= end:
                return 0
            if (start, end) in memo:
                return memo[(start, end)]
            
            res = 0
            if nums[start] + nums[start + 1] == target:
                res = max(res, 1 + helper(start + 2, end, target, memo))
            if nums[end] + nums[end - 1] == target:
                res = max(res, 1 + helper(start, end - 2, target, memo))
            if nums[start] + nums[end] == target:
                res = max(res, 1 + helper(start + 1, end - 1, target, memo))
            
            memo[(start, end)] = res
            return res
        
        options = [
            nums[0] + nums[1],
            nums[-1] + nums[-2],
            nums[0] + nums[-1]
        ]
        
        max_ops = 0
        for target in options:
            memo = {}
            current_ops = helper(0, n - 1, target, memo)
            if current_ops > max_ops:
                max_ops = current_ops
        
        return max_ops
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'maxOperations', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 49.25622018675944, 'raw_metrics': {'loc': 33, 'lloc': 29, 'sloc': 33, 'comments': 0}}"
type-of-triangle,"```python
from typing import List

class Solution:
    def triangleType(self, nums: List[int]) -> str:
        a, b, c = sorted(nums)
        if a + b <= c:
            return ""none""
        if a == b == c:
            return ""equilateral""
        if a == b or b == c or a == c:
            return ""isosceles""
        return ""scalene""
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'triangleType', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 62.07888302771768, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
range-product-queries-of-powers,"```python
class Solution:
    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        MOD = 10**9 + 7
        powers = []
        current_power = 1
        while current_power <= n:
            if n & current_power:
                powers.append(current_power)
            current_power <<= 1
        
        prefix = [1] * (len(powers) + 1)
        for i in range(len(powers)):
            prefix[i+1] = (prefix[i] * powers[i]) % MOD
        
        answers = []
        for left, right in queries:
            inv = pow(prefix[left], MOD-2, MOD)
            product = (prefix[right+1] * inv) % MOD
            answers.append(product)
        return answers
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'productQueries', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 55.15756842998667, 'raw_metrics': {'loc': 19, 'lloc': 19, 'sloc': 19, 'comments': 0}}"
remove-letter-to-equalize-frequency,"```python
class Solution:
    def equalFrequency(self, word: str) -> bool:
        from collections import defaultdict
        
        for i in range(len(word)):
            temp_word = word[:i] + word[i+1:]
            freq = defaultdict(int)
            for c in temp_word:
                freq[c] += 1
            frequencies = list(freq.values())
            if all(f == frequencies[0] for f in frequencies):
                return True
        return False
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 1}, {'name': 'equalFrequency', 'complexity': 5, 'lineno': 2}], 'maintainability_index': 63.828669357124156, 'raw_metrics': {'loc': 12, 'lloc': 13, 'sloc': 12, 'comments': 0}}"
prime-subtraction-operation,"```python
class Solution:
    def primeSubOperation(self, nums: List[int]) -> bool:
        def is_prime(n):
            if n <= 1:
                return False
            if n == 2:
                return True
            if n % 2 == 0:
                return False
            for i in range(3, int(n**0.5) + 1, 2):
                if n % i == 0:
                    return False
            return True

        def get_primes_less_than(n):
            primes = []
            for p in range(2, n):
                if is_prime(p):
                    primes.append(p)
            return primes

        n = len(nums)
        if n == 1:
            return True
        
        prev = 0
        for i in range(n):
            if nums[i] <= prev:
                return False
            primes = get_primes_less_than(nums[i] - prev)
            max_p = 0
            for p in primes:
                if p < nums[i] - prev and (nums[i] - p) > prev:
                    if p > max_p:
                        max_p = p
            if max_p > 0:
                nums[i] -= max_p
            prev = nums[i]
        return True
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 2}, {'name': 'primeSubOperation', 'complexity': 9, 'lineno': 3}], 'maintainability_index': 47.230537985699364, 'raw_metrics': {'loc': 37, 'lloc': 37, 'sloc': 37, 'comments': 0}}"
find-the-minimum-possible-sum-of-a-beautiful-array,"```python
class Solution:
    def minimumPossibleSum(self, n: int, target: int) -> int:
        mod = 10**9 + 7
        m = target // 2
        if n <= m:
            return (n * (n + 1) // 2) % mod
        else:
            return (m * (m + 1) // 2 + (target + (target + (n - m) - 1)) * (n - m) // 2) % mod
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 1}, {'name': 'minimumPossibleSum', 'complexity': 2, 'lineno': 2}], 'maintainability_index': 62.57966872820126, 'raw_metrics': {'loc': 8, 'lloc': 8, 'sloc': 8, 'comments': 0}}"
number-of-students-unable-to-eat-lunch,"```python
from typing import List

class Solution:
    def countStudents(self, students: List[int], sandwiches: List[int]) -> int:
        from collections import deque
        
        student_queue = deque(students)
        sandwich_stack = sandwiches.copy()
        
        while student_queue and sandwich_stack:
            if student_queue[0] == sandwich_stack[0]:
                student_queue.popleft()
                sandwich_stack.pop(0)
            else:
                if sandwich_stack[0] not in student_queue:
                    break
                student_queue.append(student_queue.popleft())
        
        return len(student_queue)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'countStudents', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 62.90392455935266, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
maximum-sum-queries,"```python
import bisect
from typing import List

class Solution:
    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
        pairs = sorted([(a, b) for a, b in zip(nums1, nums2)], key=lambda x: -x[0] - x[1])
        
        
        
        
        
        
        
        stack = []
        for a, b in pairs:
            sum_ab = a + b
            if not stack:
                stack.append((b, sum_ab))
            else:
                if b > stack[-1][0]:
                    stack.append((b, sum_ab))
                else:
                    idx = bisect.bisect_left(stack, (b, 0))
                    if idx == len(stack):
                        if sum_ab > stack[-1][1]:
                            stack.append((b, sum_ab))
                    else:
                        if sum_ab > stack[idx][1]:
                            stack.insert(idx, (b, sum_ab))
        
        
        
        
        
        
        
        all_y = nums2.copy()
        for _, y in queries:
            all_y.append(y)
        sorted_unique_y = sorted(set(all_y))
        y_to_compressed = {y: i for i, y in enumerate(sorted_unique_y)}
        
        
        
        m = len(sorted_unique_y)
        max_val = [ -1 ] * (4 * m)
        
        def update(node, l, r, y, val):
            if l == r:
                max_val[node] = max(max_val[node], val)
                return
            mid = (l + r) // 2
            if y <= sorted_unique_y[mid]:
                update(2 * node + 1, l, mid, y, val)
            else:
                update(2 * node + 2, mid + 1, r, y, val)
            max_val[node] = max(max_val[2 * node + 1], max_val[2 * node + 2])
        
        def query(node, l, r, y_low):
            if y_low <= sorted_unique_y[l]:
                return max_val[node]
            if y_low > sorted_unique_y[r]:
                return -1
            mid = (l + r) // 2
            left = query(2 * node + 1, l, mid, y_low)
            right = query(2 * node + 2, mid + 1, r, y_low)
            return max(left, right)
        
        indexed_queries = [ (xi, yi, i) for i, (xi, yi) in enumerate(queries) ]
        indexed_queries.sort(reverse=True, key=lambda q: q[0])
        pairs.sort(reverse=True, key=lambda p: p[0])
        
        res = [ -1 ] * len(queries)
        ptr = 0
        n = len(pairs)
        
        for xi, yi, idx in indexed_queries:
            while ptr < n and pairs[ptr][0] >= xi:
                a, b = pairs[ptr]
                sum_ab = a + b
                compressed_y = y_to_compressed[b]
                update(0, 0, m - 1, b, sum_ab)
                ptr += 1
            if yi > sorted_unique_y[-1]:
                res[idx] = -1
            else:
                res[idx] = query(0, 0, m - 1, yi)
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 16, 'lineno': 4}, {'name': 'maximumSumQueries', 'complexity': 15, 'lineno': 5}], 'maintainability_index': 37.233800579493945, 'raw_metrics': {'loc': 66, 'lloc': 70, 'sloc': 66, 'comments': 0}}"
longest-unequal-adjacent-groups-subsequence-i,"```python
from typing import List

class Solution:
    def getLongestSubsequence(self, words: List[str], groups: List[int]) -> List[str]:
        if not words:
            return []
        
        n = len(words)
        dp = [1] * n
        prev = [-1] * n
        
        for i in range(1, n):
            for j in range(i):
                if groups[i] != groups[j] and dp[j] + 1 > dp[i]:
                    dp[i] = dp[j] + 1
                    prev[i] = j
        
        max_len = max(dp)
        max_index = dp.index(max_len)
        
        subsequence = []
        current = max_index
        while current != -1:
            subsequence.append(words[current])
            current = prev[current]
        
        return subsequence[::-1]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'getLongestSubsequence', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 54.13395096669208, 'raw_metrics': {'loc': 22, 'lloc': 23, 'sloc': 22, 'comments': 0}}"
minimum-number-of-pushes-to-type-word-ii,"```python
class Solution:
    def minimumPushes(self, word: str) -> int:
        from collections import defaultdict
        
        freq = defaultdict(int)
        for c in word:
            freq[c] += 1
        
        sorted_freq = sorted(freq.values(), reverse=True)
        
        total_pushes = 0
        for i, count in enumerate(sorted_freq):
            if i < 8:
                total_pushes += count * 1
            elif i < 16:
                total_pushes += count * 2
            elif i < 24:
                total_pushes += count * 3
            else:
                total_pushes += count * 4
        
        return total_pushes
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 1}, {'name': 'minimumPushes', 'complexity': 6, 'lineno': 2}], 'maintainability_index': 56.436613555623964, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
form-smallest-number-from-two-digit-arrays,"```python
class Solution:
    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:
        common_digits = set(nums1) & set(nums2)
        if common_digits:
            return min(common_digits)
        
        min1 = min(nums1)
        min2 = min(nums2)
        
        return min(min1 * 10 + min2, min2 * 10 + min1)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 2}, {'name': 'minNumber', 'complexity': 2, 'lineno': 3}], 'maintainability_index': 66.89489175386416, 'raw_metrics': {'loc': 9, 'lloc': 9, 'sloc': 9, 'comments': 0}}"
longest-palindromic-subsequence-after-at-most-k-operations,"```python
class Solution:
    def longestPalindromicSubsequence(self, s: str, k: int) -> int:
        n = len(s)
        memo = {}

        def dp(i, j, k_left):
            if (i, j, k_left) in memo:
                return memo[(i, j, k_left)]
            if i > j:
                return 0
            if i == j:
                return 1
            if s[i] == s[j]:
                res = 2 + dp(i + 1, j - 1, k_left)
            else:
                if k_left > 0:
                    cost_i = (ord(s[j]) - ord(s[i])) % 26
                    cost_i = min(cost_i, 26 - cost_i)
                    if cost_i <= k_left:
                        option1 = 2 + dp(i + 1, j - 1, k_left - cost_i)
                    else:
                        option1 = 0
                    cost_j = (ord(s[i]) - ord(s[j])) % 26
                    cost_j = min(cost_j, 26 - cost_j)
                    if cost_j <= k_left:
                        option2 = 2 + dp(i + 1, j - 1, k_left - cost_j)
                    else:
                        option2 = 0
                    option3 = max(dp(i + 1, j, k_left), dp(i, j - 1, k_left))
                    res = max(option1, option2, option3)
                else:
                    res = max(dp(i + 1, j, k_left), dp(i, j - 1, k_left))
            memo[(i, j, k_left)] = res
            return res

        return dp(0, n - 1, k)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 1}, {'name': 'longestPalindromicSubsequence', 'complexity': 1, 'lineno': 2}], 'maintainability_index': 47.87661725626125, 'raw_metrics': {'loc': 34, 'lloc': 34, 'sloc': 34, 'comments': 0}}"
find-indices-with-index-and-value-difference-i,"```python
from typing import List

class Solution:
    def findIndices(self, nums: List[int], indexDifference: int, valueDifference: int) -> List[int]:
        n = len(nums)
        for i in range(n):
            for j in range(n):
                if abs(i - j) >= indexDifference and abs(nums[i] - nums[j]) >= valueDifference:
                    return [i, j]
        return [-1, -1]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'findIndices', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 64.28115869675968, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
clear-digits,"```python
class Solution:
    def clearDigits(self, s: str) -> str:
        stack = []
        for char in s:
            if char.isdigit():
                if stack and not stack[-1].isdigit():
                    stack.pop()
            else:
                stack.append(char)
        return ''.join(stack)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 1}, {'name': 'clearDigits', 'complexity': 5, 'lineno': 2}], 'maintainability_index': 68.32264708560068, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
minimum-amount-of-time-to-fill-cups,"```python
from typing import List

class Solution:
    def fillCups(self, amount: List[int]) -> int:
        amount.sort()
        if amount[2] >= amount[0] + amount[1]:
            return amount[2]
        else:
            return (sum(amount) + 1) // 2
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 3}, {'name': 'fillCups', 'complexity': 2, 'lineno': 4}], 'maintainability_index': 67.45011981872972, 'raw_metrics': {'loc': 9, 'lloc': 9, 'sloc': 9, 'comments': 0}}"
best-position-for-a-service-centre,"```python
import math

class Solution:
    def getMinDistSum(self, positions: List[List[int]]) -> float:
        n = len(positions)
        if n == 0:
            return 0.0
        
        x = sum(p[0] for p in positions) / n
        y = sum(p[1] for p in positions) / n
        
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        step = 1.0
        eps = 1e-6
        decay = 0.9
        
        while step > eps:
            improved = False
            for dx, dy in directions:
                nx = x + step * dx
                ny = y + step * dy
                current_sum = 0.0
                new_sum = 0.0
                for px, py in positions:
                    current_sum += math.sqrt((x - px)**2 + (y - py)**2)
                    new_sum += math.sqrt((nx - px)**2 + (ny - py)**2)
                if new_sum < current_sum:
                    x, y = nx, ny
                    improved = True
                    break
            if not improved:
                step *= decay
        
        total = 0.0
        for px, py in positions:
            total += math.sqrt((x - px)**2 + (y - py)**2)
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 3}, {'name': 'getMinDistSum', 'complexity': 10, 'lineno': 4}], 'maintainability_index': 46.481381920357954, 'raw_metrics': {'loc': 33, 'lloc': 33, 'sloc': 33, 'comments': 0}}"
find-if-digit-game-can-be-won,"```python
from typing import List

class Solution:
    def canAliceWin(self, nums: List[int]) -> bool:
        single_sum = sum(num for num in nums if num < 10)
        double_sum = sum(num for num in nums if num >= 10)
        total_sum = sum(nums)
        return single_sum > (total_sum - single_sum) or double_sum > (total_sum - double_sum)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'canAliceWin', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 66.03477771868883, 'raw_metrics': {'loc': 8, 'lloc': 8, 'sloc': 8, 'comments': 0}}"
using-a-robot-to-print-the-lexicographically-smallest-string,"```python
class Solution:
    def robotWithString(self, s: str) -> str:
        t = []
        res = []
        freq = [0] * 26
        for c in s:
            freq[ord(c) - ord('a')] += 1
        
        for c in s:
            t.append(c)
            freq[ord(c) - ord('a')] -= 1
            while t:
                current = t[-1]
                has_smaller = False
                for i in range(ord(current) - ord('a')):
                    if freq[i] > 0:
                        has_smaller = True
                        break
                if not has_smaller:
                    res.append(t.pop())
                else:
                    break
        return ''.join(res)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 1}, {'name': 'robotWithString', 'complexity': 7, 'lineno': 2}], 'maintainability_index': 55.40099972944927, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
maximize-number-of-nice-divisors,"```python
class Solution:
    def maxNiceDivisors(self, primeFactors: int) -> int:
        MOD = 10**9 + 7
        if primeFactors == 1:
            return 1
        q, r = divmod(primeFactors, 3)
        if r == 1 and q > 0:
            q -= 1
            r = 4
        elif r == 0:
            r = 1
        return pow(3, q, MOD) * r % MOD
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 1}, {'name': 'maxNiceDivisors', 'complexity': 5, 'lineno': 2}], 'maintainability_index': 60.76267545874003, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
maximum-number-of-moves-in-a-grid,"```python
from typing import List

class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])
        dp = [[0] * n for _ in range(m)]
        max_moves = 0
        
        for col in range(n-2, -1, -1):
            for row in range(m):
                current_val = grid[row][col]
                max_next = 0
                for dr in [-1, 0, 1]:
                    next_row = row + dr
                    next_col = col + 1
                    if 0 <= next_row < m and next_col < n and grid[next_row][next_col] > current_val:
                        max_next = max(max_next, dp[next_row][next_col] + 1)
                dp[row][col] = max_next
                if col == 0:
                    max_moves = max(max_moves, dp[row][col])
        
        return max_moves
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 3}, {'name': 'maxMoves', 'complexity': 9, 'lineno': 4}], 'maintainability_index': 53.965148789340674, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
count-of-matches-in-tournament,"```python
class Solution:
    def numberOfMatches(self, n: int) -> int:
        matches = 0
        while n > 1:
            if n % 2 == 0:
                matches += n // 2
                n = n // 2
            else:
                matches += (n - 1) // 2
                n = (n - 1) // 2 + 1
        return matches
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'numberOfMatches', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 61.56642747651527, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
minimum-operations-to-exceed-threshold-value-ii,"```python
import heapq

class Solution:
    def minOperations(self, nums: List[int], k: int) -> int:
        heap = []
        for num in nums:
            heapq.heappush(heap, num)
        
        operations = 0
        while heap[0] < k and len(heap) >= 2:
            x = heapq.heappop(heap)
            y = heapq.heappop(heap)
            new_num = min(x, y) * 2 + max(x, y)
            heapq.heappush(heap, new_num)
            operations += 1
        
        return operations
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'minOperations', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 60.667206387871765, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
total-cost-to-hire-k-workers,"```python
import heapq

class Solution:
    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:
        left_heap = []
        right_heap = []
        n = len(costs)
        left_ptr = 0
        right_ptr = n - 1
        total_cost = 0
        
        for _ in range(k):
            while left_ptr <= right_ptr and len(left_heap) < candidates:
                heapq.heappush(left_heap, (costs[left_ptr], left_ptr))
                left_ptr += 1
            while left_ptr <= right_ptr and len(right_heap) < candidates:
                heapq.heappush(right_heap, (costs[right_ptr], right_ptr))
                right_ptr -= 1
            
            left_min = left_heap[0] if left_heap else (float('inf'), -1)
            right_min = right_heap[0] if right_heap else (float('inf'), -1)
            
            if left_min[0] <= right_min[0]:
                total_cost += left_min[0]
                heapq.heappop(left_heap)
            else:
                total_cost += right_min[0]
                heapq.heappop(right_heap)
        
        return total_cost
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 3}, {'name': 'totalCost', 'complexity': 9, 'lineno': 4}], 'maintainability_index': 52.024884250475885, 'raw_metrics': {'loc': 26, 'lloc': 26, 'sloc': 26, 'comments': 0}}"
remove-methods-from-project,"```python
from typing import List
from collections import defaultdict, deque

class Solution:
    def remainingMethods(self, n: int, k: int, invocations: List[List[int]]) -> List[int]:
        graph = defaultdict(set)
        reverse_graph = defaultdict(set)
        for a, b in invocations:
            graph[a].add(b)
            reverse_graph[b].add(a)
        
        suspicious = set()
        queue = deque([k])
        while queue:
            current = queue.popleft()
            if current in suspicious:
                continue
            suspicious.add(current)
            for neighbor in graph.get(current, set()):
                if neighbor not in suspicious:
                    queue.append(neighbor)
        
        can_remove = True
        for method in suspicious:
            for caller in reverse_graph.get(method, set()):
                if caller not in suspicious:
                    can_remove = False
                    break
            if not can_remove:
                break
        
        if not can_remove:
            return list(range(n))
        else:
            remaining = [m for m in range(n) if m not in suspicious]
            return remaining
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 14, 'lineno': 4}, {'name': 'remainingMethods', 'complexity': 13, 'lineno': 5}], 'maintainability_index': 53.05253504038185, 'raw_metrics': {'loc': 33, 'lloc': 33, 'sloc': 33, 'comments': 0}}"
divide-nodes-into-the-maximum-number-of-groups,"```python
from collections import deque
from typing import List

class Solution:
    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:
        graph = [[] for _ in range(n + 1)]
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        visited = [0] * (n + 1)
        components = []
        
        for node in range(1, n + 1):
            if not visited[node]:
                queue = deque([node])
                visited[node] = 1
                component = []
                while queue:
                    current = queue.popleft()
                    component.append(current)
                    for neighbor in graph[current]:
                        if not visited[neighbor]:
                            visited[neighbor] = 1
                            queue.append(neighbor)
                components.append(component)
        
        max_groups = 0
        
        for component in components:
            current_max = 0
            for start in component:
                groups = {start: 1}
                queue = deque([start])
                valid = True
                while queue and valid:
                    current = queue.popleft()
                    for neighbor in graph[current]:
                        if neighbor not in groups:
                            groups[neighbor] = groups[current] + 1
                            queue.append(neighbor)
                        elif abs(groups[neighbor] - groups[current]) != 1:
                            valid = False
                            break
                    if not valid:
                        break
                if valid:
                    current_max = max(current_max, max(groups.values()))
            if current_max == 0:
                return -1
            max_groups += current_max
        
        return max_groups
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 19, 'lineno': 4}, {'name': 'magnificentSets', 'complexity': 18, 'lineno': 5}], 'maintainability_index': 44.57551164006528, 'raw_metrics': {'loc': 48, 'lloc': 49, 'sloc': 48, 'comments': 0}}"
sum-of-all-subset-xor-totals,"```python
from typing import List

class Solution:
    def subsetXORSum(self, nums: List[int]) -> int:
        total = 0
        n = len(nums)
        for mask in range(1 << n):
            current_xor = 0
            for i in range(n):
                if mask & (1 << i):
                    current_xor ^= nums[i]
            total += current_xor
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'subsetXORSum', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 62.91045011161828, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
reverse-odd-levels-of-binary-tree,"```python
from collections import deque

class Solution:
    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return root
        
        queue = deque([root])
        level = 0
        
        while queue:
            size = len(queue)
            if level % 2 == 1:
                values = [node.val for node in queue]
                values = values[::-1]
                for i in range(size):
                    queue[i].val = values[i]
            
            for _ in range(size):
                node = queue.popleft()
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            level += 1
        
        return root
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 3}, {'name': 'reverseOddLevels', 'complexity': 9, 'lineno': 4}], 'maintainability_index': 57.096465138742246, 'raw_metrics': {'loc': 23, 'lloc': 24, 'sloc': 23, 'comments': 0}}"
count-pairs-whose-sum-is-less-than-target,"```python
from typing import List

class Solution:
    def countPairs(self, nums: List[int], target: int) -> int:
        count = 0
        n = len(nums)
        for i in range(n):
            for j in range(i + 1, n):
                if nums[i] + nums[j] < target:
                    count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'countPairs', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 65.54578992527813, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
apple-redistribution-into-boxes,"```python
from typing import List

class Solution:
    def minimumBoxes(self, apple: List[int], capacity: List[int]) -> int:
        total_apples = sum(apple)
        capacity.sort(reverse=True)
        boxes_used = 0
        current_capacity = 0
        
        for cap in capacity:
            if current_capacity >= total_apples:
                break
            current_capacity += cap
            boxes_used += 1
        
        return boxes_used
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'minimumBoxes', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 64.63979020821802, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
construct-the-minimum-bitwise-array-i,"```python
from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            found = -1
            for x in range(num):
                if (x | (x + 1)) == num:
                    found = x
                    break
            ans.append(found)
        return ans
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'minBitwiseArray', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 64.22776828130313, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
closest-prime-numbers-in-range,"```python
import math

class Solution:
    def closestPrimes(self, left: int, right: int) -> List[int]:
        def is_prime(n):
            if n < 2:
                return False
            for p in [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]:
                if n % p == 0:
                    return n == p
            d = n - 1
            s = 0
            while d % 2 == 0:
                d //= 2
                s += 1
            for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:
                if a >= n:
                    continue
                x = pow(a, d, n)
                if x == 1 or x == n - 1:
                    continue
                for _ in range(s - 1):
                    x = pow(x, 2, n)
                    if x == n - 1:
                        break
                else:
                    return False
            return True

        primes = []
        for num in range(left, right + 1):
            if is_prime(num):
                primes.append(num)
        
        if len(primes) < 2:
            return [-1, -1]
        
        min_diff = float('inf')
        result = [-1, -1]
        for i in range(len(primes) - 1):
            diff = primes[i+1] - primes[i]
            if diff < min_diff:
                min_diff = diff
                result = [primes[i], primes[i+1]]
                if min_diff == 2:
                    break
        
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'closestPrimes', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 44.68941794535974, 'raw_metrics': {'loc': 44, 'lloc': 44, 'sloc': 44, 'comments': 0}}"
maximize-amount-after-two-days-of-conversions,"```python
from typing import List
from collections import defaultdict

class Solution:
    def maxAmount(self, initialCurrency: str, pairs1: List[List[str]], rates1: List[float], pairs2: List[List[str]], rates2: List[float]) -> float:
        def build_graph(pairs, rates):
            graph = defaultdict(dict)
            for (u, v), rate in zip(pairs, rates):
                graph[u][v] = rate
                graph[v][u] = 1.0 / rate
            return graph
        
        def find_max_conversion(graph, start_currency):
            max_amounts = defaultdict(float)
            max_amounts[start_currency] = 1.0
            queue = [start_currency]
            
            while queue:
                current_currency = queue.pop(0)
                current_amount = max_amounts[current_currency]
                for neighbor, rate in graph[current_currency].items():
                    new_amount = current_amount * rate
                    if new_amount > max_amounts[neighbor]:
                        max_amounts[neighbor] = new_amount
                        queue.append(neighbor)
            return max_amounts
        
        graph1 = build_graph(pairs1, rates1)
        day1_amounts = find_max_conversion(graph1, initialCurrency)
        
        max_final_amount = 1.0
        
        for currency, amount in day1_amounts.items():
            graph2 = build_graph(pairs2, rates2)
            day2_amounts = find_max_conversion(graph2, currency)
            if initialCurrency in day2_amounts:
                final_amount = amount * day2_amounts[initialCurrency]
                if final_amount > max_final_amount:
                    max_final_amount = final_amount
        
        return max_final_amount
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 4}, {'name': 'maxAmount', 'complexity': 4, 'lineno': 5}], 'maintainability_index': 52.64017402630878, 'raw_metrics': {'loc': 35, 'lloc': 35, 'sloc': 35, 'comments': 0}}"
divide-an-array-into-subarrays-with-minimum-cost-i,"```python
from typing import List

class Solution:
    def minimumCost(self, nums: List[int]) -> int:
        n = len(nums)
        min_sum = float('inf')
        
        for i in range(1, n):
            for j in range(i + 1, n):
                current_sum = nums[0] + nums[i] + nums[j]
                if current_sum < min_sum:
                    min_sum = current_sum
        
        return min_sum
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'minimumCost', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 64.579041983756, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
find-closest-number-to-zero,"```python
from typing import List

class Solution:
    def findClosestNumber(self, nums: List[int]) -> int:
        closest = nums[0]
        for num in nums[1:]:
            if abs(num) < abs(closest):
                closest = num
            elif abs(num) == abs(closest):
                if num > closest:
                    closest = num
        return closest
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'findClosestNumber', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 65.46179136944026, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
minimum-number-of-operations-to-make-elements-in-array-distinct,"```python
from typing import List

class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        operations = 0
        while True:
            if len(set(nums)) == len(nums):
                return operations
            operations += 1
            nums = nums[3:] if len(nums) >= 3 else []
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'minimumOperations', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 66.42061260173968, 'raw_metrics': {'loc': 10, 'lloc': 11, 'sloc': 10, 'comments': 0}}"
count-complete-subarrays-in-an-array,"```python
from typing import List

class Solution:
    def countCompleteSubarrays(self, nums: List[int]) -> int:
        distinct = len(set(nums))
        n = len(nums)
        count = 0
        
        for i in range(n):
            seen = set()
            for j in range(i, n):
                seen.add(nums[j])
                if len(seen) == distinct:
                    count += 1
        
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'countCompleteSubarrays', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 65.98925427669732, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
minimum-number-of-operations-to-make-array-empty,"```python
from collections import defaultdict
from typing import List

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        freq = defaultdict(int)
        for num in nums:
            freq[num] += 1
        
        operations = 0
        for count in freq.values():
            if count == 1:
                return -1
            operations += count // 3
            if count % 3 != 0:
                operations += 1
        return operations
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 4}, {'name': 'minOperations', 'complexity': 5, 'lineno': 5}], 'maintainability_index': 59.32598381708597, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
lexicographically-smallest-string-after-operations-with-constraint,"```python
class Solution:
    def getSmallestString(self, s: str, k: int) -> str:
        res = []
        remaining_k = k
        for c in s:
            if remaining_k <= 0:
                res.append(c)
                continue
            current_char = ord(c) - ord('a')
            for target in range(0, 26):
                distance = min((current_char - target) % 26, (target - current_char) % 26)
                if distance <= remaining_k:
                    remaining_k -= distance
                    res.append(chr(ord('a') + target))
                    break
        return ''.join(res)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 1}, {'name': 'getSmallestString', 'complexity': 5, 'lineno': 2}], 'maintainability_index': 58.759914366152714, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
minimum-number-of-seconds-to-make-mountain-height-zero,"```python
from typing import List

class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        left = 1
        right = mountainHeight * (mountainHeight + 1) // 2 * max(workerTimes) if workerTimes else 0
        
        def can_reduce(t):
            total = 0
            for time in workerTimes:
                low = 0
                high = mountainHeight
                best = 0
                while low <= high:
                    mid = (low + high) // 2
                    s = time * mid * (mid + 1) // 2
                    if s <= t:
                        best = mid
                        low = mid + 1
                    else:
                        high = mid - 1
                total += best
                if total >= mountainHeight:
                    return True
            return total >= mountainHeight
        
        answer = right
        while left <= right:
            mid = (left + right) // 2
            if can_reduce(mid):
                answer = mid
                right = mid - 1
            else:
                left = mid + 1
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'minNumberOfSeconds', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 48.56800918189958, 'raw_metrics': {'loc': 33, 'lloc': 33, 'sloc': 33, 'comments': 0}}"
closest-nodes-queries-in-a-binary-search-tree,"```python
class Solution:
    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:
        values = []
        def inorder(node):
            if node:
                inorder(node.left)
                values.append(node.val)
                inorder(node.right)
        inorder(root)
        
        answer = []
        for q in queries:
            mini = -1
            maxi = -1
            left, right = 0, len(values) - 1
            while left <= right:
                mid = (left + right) // 2
                if values[mid] <= q:
                    mini = values[mid]
                    left = mid + 1
                else:
                    right = mid - 1
            left, right = 0, len(values) - 1
            while left <= right:
                mid = (left + right) // 2
                if values[mid] >= q:
                    maxi = values[mid]
                    right = mid - 1
                else:
                    left = mid + 1
            answer.append([mini, maxi])
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 2}, {'name': 'closestNodes', 'complexity': 6, 'lineno': 3}], 'maintainability_index': 50.24039371398114, 'raw_metrics': {'loc': 32, 'lloc': 32, 'sloc': 32, 'comments': 0}}"
maximum-and-sum-of-array,"```python
class Solution:
    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:
        n = len(nums)
        dp = [0] * (1 << (2 * numSlots))
        
        for mask in range(1 << (2 * numSlots)):
            cnt = bin(mask).count('1')
            if cnt >= n:
                continue
            for i in range(2 * numSlots):
                slot = (i // 2) + 1
                if not (mask & (1 << i)):
                    new_mask = mask | (1 << i)
                    dp[new_mask] = max(dp[new_mask], dp[mask] + (nums[cnt] & slot))
        
        return max(dp)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'maximumANDSum', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 57.0883739307288, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
number-of-black-blocks,"```python
from typing import List
from collections import defaultdict

class Solution:
    def countBlackBlocks(self, m: int, n: int, coordinates: List[List[int]]) -> List[int]:
        block_counts = defaultdict(int)
        black_cells = set((x, y) for x, y in coordinates)
        
        for x, y in black_cells:
            for i in [x-1, x]:
                for j in [y-1, y]:
                    if 0 <= i < m - 1 and 0 <= j < n - 1:
                        count = 0
                        count += (i, j) in black_cells
                        count += (i+1, j) in black_cells
                        count += (i, j+1) in black_cells
                        count += (i+1, j+1) in black_cells
                        block_counts[(i, j)] = count
        
        total_blocks = (m - 1) * (n - 1)
        result = [0] * 5
        result[0] = total_blocks - len(block_counts)
        
        for count in block_counts.values():
            if 1 <= count <=4:
                result[count] += 1
        
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 4}, {'name': 'countBlackBlocks', 'complexity': 9, 'lineno': 5}], 'maintainability_index': 50.05427541414671, 'raw_metrics': {'loc': 24, 'lloc': 24, 'sloc': 24, 'comments': 0}}"
count-increasing-quadruplets,"```python
class Solution:
    def countQuadruplets(self, nums: List[int]) -> int:
        n = len(nums)
        count = 0
        
        
        
        left_less = [[0] * n for _ in range(n)]
        right_greater = [[0] * n for _ in range(n)]
        
        for k in range(n):
            cnt = 0
            for j in range(n):
                if nums[j] < nums[k]:
                    cnt += 1
                left_less[k][j] = cnt
        
        for j in range(n):
            cnt = 0
            for k in range(n-1, -1, -1):
                if nums[k] > nums[j]:
                    cnt += 1
                right_greater[j][k] = cnt
        
        res = 0
        for j in range(n):
            for k in range(j+1, n):
                if nums[j] > nums[k]:
                    res += left_less[k][j] * right_greater[j][k]
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 13, 'lineno': 2}, {'name': 'countQuadruplets', 'complexity': 12, 'lineno': 3}], 'maintainability_index': 52.23001616201136, 'raw_metrics': {'loc': 25, 'lloc': 25, 'sloc': 25, 'comments': 0}}"
concatenation-of-array,"```python
from typing import List

class Solution:
    def getConcatenation(self, nums: List[int]) -> List[int]:
        return nums + nums
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 3}, {'name': 'getConcatenation', 'complexity': 1, 'lineno': 4}], 'maintainability_index': 81.14287831432362, 'raw_metrics': {'loc': 5, 'lloc': 5, 'sloc': 5, 'comments': 0}}"
most-popular-video-creator,"```python
from typing import List

class Solution:
    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:
        from collections import defaultdict
        
        creator_total_views = defaultdict(int)
        creator_videos = defaultdict(list)
        
        for creator, video_id, view in zip(creators, ids, views):
            creator_total_views[creator] += view
            creator_videos[creator].append((view, video_id))
        
        if not creator_total_views:
            return []
        
        max_popularity = max(creator_total_views.values())
        popular_creators = [creator for creator, total in creator_total_views.items() if total == max_popularity]
        
        result = []
        for creator in popular_creators:
            videos = creator_videos[creator]
            max_view = max(v[0] for v in videos)
            candidates = [v[1] for v in videos if v[0] == max_view]
            candidates.sort()
            result.append([creator, candidates[0]])
        
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 3}, {'name': 'mostPopularCreator', 'complexity': 9, 'lineno': 4}], 'maintainability_index': 58.42878417235655, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
count-subtrees-with-max-distance-between-cities,"```python
from typing import List
from collections import deque

class Solution:
    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:
        adj = [[] for _ in range(n)]
        for u, v in edges:
            u -= 1
            v -= 1
            adj[u].append(v)
            adj[v].append(u)
        
        res = [0] * (n - 1)
        
        for mask in range(1, 1 << n):
            nodes = []
            for i in range(n):
                if mask & (1 << i):
                    nodes.append(i)
            if len(nodes) < 2:
                continue
            
            visited = 0
            q = deque()
            q.append(nodes[0])
            visited |= 1 << nodes[0]
            
            while q:
                u = q.popleft()
                for v in adj[u]:
                    if (mask & (1 << v)) and not (visited & (1 << v)):
                        visited |= 1 << v
                        q.append(v)
            
            if visited != mask:
                continue
            
            max_dist = 0
            for start in nodes:
                dist = [-1] * n
                q = deque()
                q.append(start)
                dist[start] = 0
                while q:
                    u = q.popleft()
                    for v in adj[u]:
                        if (mask & (1 << v)) and dist[v] == -1:
                            dist[v] = dist[u] + 1
                            q.append(v)
                current_max = max(d for d in dist if d != -1)
                if current_max > max_dist:
                    max_dist = current_max
            
            if max_dist > 0:
                res[max_dist - 1] += 1
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 22, 'lineno': 4}, {'name': 'countSubgraphsForEachDiameter', 'complexity': 21, 'lineno': 5}], 'maintainability_index': 41.12598367080502, 'raw_metrics': {'loc': 49, 'lloc': 49, 'sloc': 49, 'comments': 0}}"
two-furthest-houses-with-different-colors,"```python
from typing import List

class Solution:
    def maxDistance(self, colors: List[int]) -> int:
        max_dist = 0
        n = len(colors)
        for i in range(n):
            for j in range(i + 1, n):
                if colors[i] != colors[j]:
                    max_dist = max(max_dist, abs(i - j))
        return max_dist
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'maxDistance', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 66.58815489908999, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
sum-of-total-strength-of-wizards,"```python
class Solution:
    def totalStrength(self, strength: List[int]) -> int:
        MOD = 10**9 + 7
        n = len(strength)
        
        prefix = [0] * (n + 2)
        for i in range(n):
            prefix[i+1] = (prefix[i] + strength[i]) % MOD
        prefix_prefix = [0] * (n + 2)
        for i in range(n+1):
            prefix_prefix[i+1] = (prefix_prefix[i] + prefix[i]) % MOD
        
        left = [-1] * n
        stack = []
        for i in range(n):
            while stack and strength[stack[-1]] >= strength[i]:
                stack.pop()
            if stack:
                left[i] = stack[-1]
            else:
                left[i] = -1
            stack.append(i)
        
        right = [n] * n
        stack = []
        for i in range(n-1, -1, -1):
            while stack and strength[stack[-1]] > strength[i]:
                stack.pop()
            if stack:
                right[i] = stack[-1]
            else:
                right[i] = n
            stack.append(i)
        
        res = 0
        for i in range(n):
            l, r = left[i] + 1, right[i] - 1
            total = (i - l + 1) * (prefix_prefix[r+2] - prefix_prefix[i+1]) - (r - i + 1) * (prefix_prefix[i+1] - prefix_prefix[l])
            total %= MOD
            res += strength[i] * total
            res %= MOD
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 13, 'lineno': 2}, {'name': 'totalStrength', 'complexity': 12, 'lineno': 3}], 'maintainability_index': 43.37944837015333, 'raw_metrics': {'loc': 39, 'lloc': 39, 'sloc': 39, 'comments': 0}}"
shortest-and-lexicographically-smallest-beautiful-string,"```python
class Solution:
    def shortestBeautifulSubstring(self, s: str, k: int) -> str:
        n = len(s)
        min_len = float('inf')
        result = """"
        
        for i in range(n):
            count = 0
            for j in range(i, n):
                if s[j] == '1':
                    count += 1
                    if count == k:
                        current_len = j - i + 1
                        if current_len < min_len:
                            min_len = current_len
                            result = s[i:j+1]
                        elif current_len == min_len:
                            if s[i:j+1] < result:
                                result = s[i:j+1]
                        break
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 1}, {'name': 'shortestBeautifulSubstring', 'complexity': 8, 'lineno': 2}], 'maintainability_index': 54.65762705154747, 'raw_metrics': {'loc': 20, 'lloc': 22, 'sloc': 20, 'comments': 0}}"
count-the-number-of-good-nodes,"```python
from collections import defaultdict
from typing import List

class Solution:
    def countGoodNodes(self, edges: List[List[int]]) -> int:
        if not edges:
            return 0
        
        tree = defaultdict(list)
        for a, b in edges:
            tree[a].append(b)
            tree[b].append(a)
        
        visited = set()
        size = {}
        is_good = {}
        
        stack = [(0, None, False)]
        
        while stack:
            node, parent, processed = stack.pop()
            if not processed:
                stack.append((node, parent, True))
                for neighbor in reversed(tree[node]):
                    if neighbor != parent:
                        stack.append((neighbor, node, False))
            else:
                sizes = []
                for neighbor in tree[node]:
                    if neighbor != parent:
                        sizes.append(size[neighbor])
                if not sizes:
                    size[node] = 1
                    is_good[node] = True
                else:
                    size[node] = 1 + sum(sizes)
                    is_good[node] = all(s == sizes[0] for s in sizes)
        
        return sum(is_good.values())
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 4}, {'name': 'countGoodNodes', 'complexity': 11, 'lineno': 5}], 'maintainability_index': 52.209986989732926, 'raw_metrics': {'loc': 34, 'lloc': 34, 'sloc': 34, 'comments': 0}}"
determine-if-a-cell-is-reachable-at-a-given-time,"```python
class Solution:
    def isReachableAtTime(self, sx: int, sy: int, fx: int, fy: int, t: int) -> bool:
        if sx == fx and sy == fy:
            return t != 1
        dx = abs(fx - sx)
        dy = abs(fy - sy)
        min_time = max(dx, dy)
        return t >= min_time
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'isReachableAtTime', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 66.43828649061868, 'raw_metrics': {'loc': 8, 'lloc': 8, 'sloc': 8, 'comments': 0}}"
maximum-length-substring-with-two-occurrences,"```python
class Solution:
    def maximumLengthSubstring(self, s: str) -> int:
        max_len = 0
        n = len(s)
        for i in range(n):
            freq = {}
            for j in range(i, n):
                char = s[j]
                freq[char] = freq.get(char, 0) + 1
                if freq[char] > 2:
                    break
                current_len = j - i + 1
                if current_len > max_len:
                    max_len = current_len
        return max_len
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 1}, {'name': 'maximumLengthSubstring', 'complexity': 5, 'lineno': 2}], 'maintainability_index': 61.42025498473004, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
find-the-integer-added-to-array-ii,"```python
from typing import List

class Solution:
    def minimumAddedInteger(self, nums1: List[int], nums2: List[int]) -> int:
        nums1.sort()
        nums2.sort()
        min_x = float('inf')
        
        n = len(nums1)
        for i in range(n):
            for j in range(i + 1, n):
                candidate = []
                for k in range(n):
                    if k != i and k != j:
                        candidate.append(nums1[k])
                x = nums2[0] - candidate[0]
                match = True
                for a, b in zip(candidate, nums2):
                    if b - a != x:
                        match = False
                        break
                if match:
                    if x < min_x:
                        min_x = x
        return min_x
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 3}, {'name': 'minimumAddedInteger', 'complexity': 10, 'lineno': 4}], 'maintainability_index': 54.40618606348572, 'raw_metrics': {'loc': 24, 'lloc': 24, 'sloc': 24, 'comments': 0}}"
check-if-the-sentence-is-pangram,"```python
class Solution:
    def checkIfPangram(self, sentence: str) -> bool:
        return len(set(sentence)) == 26
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 1}, {'name': 'checkIfPangram', 'complexity': 1, 'lineno': 2}], 'maintainability_index': 84.58174335197131, 'raw_metrics': {'loc': 3, 'lloc': 3, 'sloc': 3, 'comments': 0}}"
total-characters-in-string-after-transformations-i,"```python
class Solution:
    def lengthAfterTransformations(self, s: str, t: int) -> int:
        MOD = 10**9 + 7
        count = [0] * 26
        for c in s:
            count[ord(c) - ord('a')] += 1
        
        for _ in range(t):
            new_count = [0] * 26
            for i in range(25):
                new_count[i + 1] += count[i]
                new_count[i + 1] %= MOD
            new_count[0] += count[25]
            new_count[1] += count[25]
            new_count[0] %= MOD
            new_count[1] %= MOD
            count = new_count
        
        return sum(count) % MOD
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 1}, {'name': 'lengthAfterTransformations', 'complexity': 4, 'lineno': 2}], 'maintainability_index': 56.13598501305888, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
make-array-elements-equal-to-zero,"```python
from typing import List

class Solution:
    def countValidSelections(self, nums: List[int]) -> int:
        n = len(nums)
        count = 0
        
        for start in range(n):
            if nums[start] == 0:
                for direction in [-1, 1]:  # -1 for left, 1 for right
                    temp_nums = nums.copy()
                    curr = start
                    dir_ = direction
                    valid = True
                    
                    while True:
                        if curr < 0 or curr >= n:
                            break
                        if temp_nums[curr] == 0:
                            curr += dir_
                        else:
                            temp_nums[curr] -= 1
                            dir_ *= -1
                            curr += dir_
                    
                    if all(x == 0 for x in temp_nums):
                        count += 1
        
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 3}, {'name': 'countValidSelections', 'complexity': 10, 'lineno': 4}], 'maintainability_index': 64.31867930708508, 'raw_metrics': {'loc': 25, 'lloc': 25, 'sloc': 25, 'comments': 1}}"
shift-distance-between-two-strings,"```python
from typing import List

class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        total_cost = 0
        for sc, tc in zip(s, t):
            if sc == tc:
                continue
            sc_ord = ord(sc) - ord('a')
            tc_ord = ord(tc) - ord('a')
            
            forward_shifts = (tc_ord - sc_ord) % 26
            backward_shifts = (sc_ord - tc_ord) % 26
            
            forward_cost = 0
            current = sc_ord
            for _ in range(forward_shifts):
                forward_cost += nextCost[current]
                current = (current + 1) % 26
            
            backward_cost = 0
            current = sc_ord
            for _ in range(backward_shifts):
                backward_cost += previousCost[current]
                current = (current - 1) % 26
            
            total_cost += min(forward_cost, backward_cost)
        
        return total_cost
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'shiftDistance', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 53.04959732845172, 'raw_metrics': {'loc': 24, 'lloc': 24, 'sloc': 24, 'comments': 0}}"
count-ways-to-group-overlapping-ranges,"```python
class Solution:
    def countWays(self, ranges: List[List[int]]) -> int:
        ranges.sort()
        merged = []
        for start, end in ranges:
            if not merged:
                merged.append([start, end])
            else:
                last_start, last_end = merged[-1]
                if start <= last_end:
                    merged[-1][1] = max(last_end, end)
                else:
                    merged.append([start, end])
        return pow(2, len(merged), 10**9 + 7)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'countWays', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 61.45834917467711, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
check-if-two-chessboard-squares-have-the-same-color,"```python
class Solution:
    def checkTwoChessboards(self, coordinate1: str, coordinate2: str) -> bool:
        def get_color(coordinate):
            x = ord(coordinate[0]) - ord('a')
            y = int(coordinate[1]) - 1
            return (x + y) % 2 == 0
        
        return get_color(coordinate1) == get_color(coordinate2)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 1}, {'name': 'checkTwoChessboards', 'complexity': 1, 'lineno': 2}], 'maintainability_index': 68.29098933708798, 'raw_metrics': {'loc': 7, 'lloc': 7, 'sloc': 7, 'comments': 0}}"
maximum-possible-number-by-binary-concatenation,"```python
from typing import List

class Solution:
    def maxGoodNumber(self, nums: List[int]) -> int:
        max_num = 0
        from itertools import permutations
        
        for perm in permutations(nums):
            binary_str = ''
            for num in perm:
                binary_str += bin(num)[2:]
            current_num = int(binary_str, 2)
            if current_num > max_num:
                max_num = current_num
        return max_num
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'maxGoodNumber', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 65.33563759945251, 'raw_metrics': {'loc': 14, 'lloc': 15, 'sloc': 14, 'comments': 0}}"
substring-with-largest-variance,"```python
class Solution:
    def largestVariance(self, s: str) -> int:
        unique_chars = list(set(s))
        max_variance = 0
        
        for i in range(len(unique_chars)):
            for j in range(len(unique_chars)):
                if i == j:
                    continue
                char1, char2 = unique_chars[i], unique_chars[j]
                count1 = count2 = 0
                reset_flag = False
                
                for char in s:
                    if char == char1:
                        count1 += 1
                    elif char == char2:
                        count2 += 1
                    
                    if count2 > count1:
                        count1 = count2 = 0
                        reset_flag = True
                    elif count1 > 0 and count2 > 0:
                        max_variance = max(max_variance, count1 - count2)
                
                if reset_flag:
                    count1 = count2 = 0
                    for char in reversed(s):
                        if char == char1:
                            count1 += 1
                        elif char == char2:
                            count2 += 1
                        
                        if count2 > count1:
                            break
                        elif count1 > 0 and count2 > 0:
                            max_variance = max(max_variance, count1 - count2)
        
        return max_variance
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 18, 'lineno': 1}, {'name': 'largestVariance', 'complexity': 17, 'lineno': 2}], 'maintainability_index': 47.81733394708187, 'raw_metrics': {'loc': 33, 'lloc': 33, 'sloc': 33, 'comments': 0}}"
find-minimum-time-to-finish-all-jobs,"```python
class Solution:
    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:
        workers = [0] * k
        self.res = float('inf')
        jobs.sort(reverse=True)
        
        def dfs(index):
            if index == len(jobs):
                self.res = min(self.res, max(workers))
                return
            for i in range(k):
                if workers[i] + jobs[index] >= self.res:
                    continue
                workers[i] += jobs[index]
                dfs(index + 1)
                workers[i] -= jobs[index]
                if workers[i] == 0:
                    break
        dfs(0)
        return self.res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 2}, {'name': 'minimumTimeRequired', 'complexity': 1, 'lineno': 3}], 'maintainability_index': 57.235092878183416, 'raw_metrics': {'loc': 20, 'lloc': 20, 'sloc': 20, 'comments': 0}}"
make-k-subarray-sums-equal,"```python
import math
from typing import List

class Solution:
    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:
        n = len(arr)
        visited = [False] * n
        total_operations = 0
        
        for i in range(n):
            if not visited[i]:
                group = []
                j = i
                while not visited[j]:
                    visited[j] = True
                    group.append(arr[j])
                    j = (j + k) % n
                group.sort()
                median = group[len(group) // 2]
                total_operations += sum(abs(num - median) for num in group)
        
        return total_operations
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 4}, {'name': 'makeSubKSumEqual', 'complexity': 5, 'lineno': 5}], 'maintainability_index': 57.01419536048107, 'raw_metrics': {'loc': 20, 'lloc': 20, 'sloc': 20, 'comments': 0}}"
longest-strictly-increasing-or-strictly-decreasing-subarray,"```python
from typing import List

class Solution:
    def longestMonotonicSubarray(self, nums: List[int]) -> int:
        if not nums:
            return 0
        
        max_len = 1
        inc_len = 1
        dec_len = 1
        
        for i in range(1, len(nums)):
            if nums[i] > nums[i-1]:
                inc_len += 1
                dec_len = 1
            elif nums[i] < nums[i-1]:
                dec_len += 1
                inc_len = 1
            else:
                inc_len = 1
                dec_len = 1
            max_len = max(max_len, inc_len, dec_len)
        
        return max_len
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'longestMonotonicSubarray', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 57.1747767466274, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
number-of-senior-citizens,"```python
class Solution:
    def countSeniors(self, details: List[str]) -> int:
        count = 0
        for detail in details:
            age = int(detail[11:13])
            if age > 60:
                count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'countSeniors', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 69.3113889160328, 'raw_metrics': {'loc': 9, 'lloc': 10, 'sloc': 9, 'comments': 0}}"
second-largest-digit-in-a-string,"```python
class Solution:
    def secondHighest(self, s: str) -> int:
        digits = set()
        for c in s:
            if c.isdigit():
                digits.add(int(c))
        if len(digits) < 2:
            return -1
        return sorted(digits, reverse=True)[1]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 1}, {'name': 'secondHighest', 'complexity': 4, 'lineno': 2}], 'maintainability_index': 71.05579856126917, 'raw_metrics': {'loc': 9, 'lloc': 9, 'sloc': 9, 'comments': 0}}"
counting-words-with-a-given-prefix,"```python
from typing import List

class Solution:
    def prefixCount(self, words: List[str], pref: str) -> int:
        count = 0
        pref_len = len(pref)
        for word in words:
            if len(word) >= pref_len and word[:pref_len] == pref:
                count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'prefixCount', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 66.07457148659327, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
minimum-impossible-or,"```python
class Solution:
    def minImpossibleOR(self, nums: List[int]) -> int:
        nums_set = set(nums)
        res = 1
        while res in nums_set:
            res <<= 1
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 2}, {'name': 'minImpossibleOR', 'complexity': 2, 'lineno': 3}], 'maintainability_index': 71.88621556846499, 'raw_metrics': {'loc': 8, 'lloc': 8, 'sloc': 8, 'comments': 0}}"
distribute-elements-into-two-arrays-i,"```python
from typing import List

class Solution:
    def resultArray(self, nums: List[int]) -> List[int]:
        if not nums:
            return []
        arr1 = [nums[0]]
        arr2 = [nums[1]] if len(nums) > 1 else []
        
        for i in range(2, len(nums)):
            if arr1[-1] > arr2[-1]:
                arr1.append(nums[i])
            else:
                arr2.append(nums[i])
        
        return arr1 + arr2
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'resultArray', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 62.18226189255759, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
design-memory-allocator,"```python
class Allocator:

    def __init__(self, n: int):
        self.memory = [0] * n

    def allocate(self, size: int, mID: int) -> int:
        consecutive = 0
        start = -1
        for i in range(len(self.memory)):
            if self.memory[i] == 0:
                if consecutive == 0:
                    start = i
                consecutive += 1
                if consecutive == size:
                    for j in range(start, start + size):
                        self.memory[j] = mID
                    return start
            else:
                consecutive = 0
        return -1

    def freeMemory(self, mID: int) -> int:
        count = 0
        for i in range(len(self.memory)):
            if self.memory[i] == mID:
                self.memory[i] = 0
                count += 1
        return count


```","{'cyclomatic_complexity': [{'name': 'Allocator', 'complexity': 4, 'lineno': 1}, {'name': '__init__', 'complexity': 1, 'lineno': 2}, {'name': 'allocate', 'complexity': 6, 'lineno': 4}, {'name': 'freeMemory', 'complexity': 3, 'lineno': 19}], 'maintainability_index': 53.67720322011735, 'raw_metrics': {'loc': 25, 'lloc': 25, 'sloc': 25, 'comments': 0}}"
movement-of-robots,"```python
class Solution:
    def sumDistance(self, nums: List[int], s: str, d: int) -> int:
        MOD = 10**9 + 7
        n = len(nums)
        final_positions = []
        
        for i in range(n):
            direction = s[i]
            if direction == 'R':
                final_positions.append(nums[i] + d)
            else:
                final_positions.append(nums[i] - d)
        
        final_positions.sort()
        prefix = [0] * (n + 1)
        res = 0
        
        for i in range(n):
            prefix[i+1] = prefix[i] + final_positions[i]
        
        for i in range(n):
            res += final_positions[i] * i - prefix[i]
            res %= MOD
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'sumDistance', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 54.434766925060494, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
count-the-number-of-complete-components,"```python
from typing import List

class Solution:
    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:
        parent = [i for i in range(n)]
        rank = [1] * n
        
        def find(u):
            while parent[u] != u:
                parent[u] = parent[parent[u]]
                u = parent[u]
            return u
        
        def union(u, v):
            u_root = find(u)
            v_root = find(v)
            if u_root == v_root:
                return
            if rank[u_root] > rank[v_root]:
                parent[v_root] = u_root
                rank[u_root] += rank[v_root]
            else:
                parent[u_root] = v_root
                rank[v_root] += rank[u_root]
        
        for u, v in edges:
            union(u, v)
        
        components = {}
        for u in range(n):
            root = find(u)
            if root not in components:
                components[root] = []
            components[root].append(u)
        
        count = 0
        for component in components.values():
            m = len(component)
            required_edges = m * (m - 1) // 2
            actual_edges = 0
            for u, v in edges:
                if u in component and v in component:
                    actual_edges += 1
            if actual_edges == required_edges:
                count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 3}, {'name': 'countCompleteComponents', 'complexity': 10, 'lineno': 4}], 'maintainability_index': 46.54819744238714, 'raw_metrics': {'loc': 41, 'lloc': 41, 'sloc': 41, 'comments': 0}}"
count-k-subsequences-of-a-string-with-maximum-beauty,"```python
class Solution:
    def countKSubsequencesWithMaxBeauty(self, s: str, k: int) -> int:
        from collections import defaultdict
        from math import comb
        
        MOD = 10**9 + 7
        
        freq = defaultdict(int)
        for c in s:
            freq[c] += 1
        
        if k > len(freq):
            return 0
        
        freq_list = sorted(freq.values(), reverse=True)
        max_sum = sum(freq_list[:k])
        
        
        m = freq_list[k-1]
        total = 0  # total number of elements with frequency >= m in the entire list
        cnt_in_top_k = 0  # number of elements with frequency == m in the top k
        
        for f in freq_list:
            if f > m:
                total += 1
            elif f == m:
                cnt_in_top_k += 1
        total += cnt_in_top_k
        
        
        x = k - (total - cnt_in_top_k)
        if x < 0:
            return 0
        
        ways = comb(cnt_in_top_k, x)
        
        res = 1
        for f in freq_list:
            if f > m:
                res = (res * f) % MOD
            elif f == m:
                if x > 0:
                    res = (res * f) % MOD
                    x -= 1
            else:
                break
        
        res = (res * ways) % MOD
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 1}, {'name': 'countKSubsequencesWithMaxBeauty', 'complexity': 11, 'lineno': 2}], 'maintainability_index': 59.790046952008225, 'raw_metrics': {'loc': 37, 'lloc': 38, 'sloc': 37, 'comments': 2}}"
find-the-losers-of-the-circular-game,"```python
class Solution:
    def circularGameLosers(self, n: int, k: int) -> List[int]:
        received = set()
        current = 1
        step = 1
        while current not in received:
            received.add(current)
            current = (current + step * k - 1) % n + 1
            step += 1
        
        losers = []
        for i in range(1, n + 1):
            if i not in received:
                losers.append(i)
        return losers
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'circularGameLosers', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 59.43421307666564, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
maximize-greatness-of-an-array,"```python
class Solution:
    def maximizeGreatness(self, nums: List[int]) -> int:
        nums_sorted = sorted(nums)
        perm_sorted = sorted(nums)
        
        res = 0
        i = 0
        j = 0
        n = len(nums)
        
        while j < n:
            if perm_sorted[j] > nums_sorted[i]:
                res += 1
                i += 1
            j += 1
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'maximizeGreatness', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 61.92098818368344, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
maximum-element-sum-of-a-complete-subset-of-indices,"```python
import math
from collections import defaultdict
from typing import List

class Solution:
    def maximumSum(self, nums: List[int]) -> int:
        def get_square_free(x):
            res = 1
            for i in range(2, int(math.isqrt(x)) + 1):
                if x % i == 0:
                    cnt = 0
                    while x % i == 0:
                        x //= i
                        cnt += 1
                    if cnt % 2 == 1:
                        res *= i
            if x > 1:
                res *= x
            return res
        
        groups = defaultdict(int)
        for i in range(1, len(nums) + 1):
            sf = get_square_free(i)
            groups[sf] += nums[i - 1]
        
        return max(groups.values()) if groups else 0
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 5}, {'name': 'maximumSum', 'complexity': 3, 'lineno': 6}], 'maintainability_index': 53.18861077298256, 'raw_metrics': {'loc': 24, 'lloc': 24, 'sloc': 24, 'comments': 0}}"
recover-the-original-array,"```python
from collections import defaultdict

class Solution:
    def recoverArray(self, nums: List[int]) -> List[int]:
        nums.sort()
        n = len(nums)
        possible_ks = set()
        
        for j in range(1, n):
            diff = nums[j] - nums[0]
            if diff > 0 and diff % 2 == 0:
                possible_ks.add(diff // 2)
        
        for k in sorted(possible_ks):
            freq = defaultdict(int)
            for num in nums:
                freq[num] += 1
            res = []
            valid = True
            for num in nums:
                if freq[num] == 0:
                    continue
                if freq[num + 2 * k] == 0:
                    valid = False
                    break
                freq[num] -= 1
                freq[num + 2 * k] -= 1
                res.append(num + k)
            if valid and len(res) == n // 2:
                return res
        return []
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 3}, {'name': 'recoverArray', 'complexity': 11, 'lineno': 4}], 'maintainability_index': 49.324397184486465, 'raw_metrics': {'loc': 29, 'lloc': 29, 'sloc': 29, 'comments': 0}}"
substring-xor-queries,"```python
class Solution:
    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:
        n = len(s)
        val_map = {}
        for l in range(1, 33):
            for i in range(n - l + 1):
                substring = s[i:i+l]
                val = int(substring, 2)
                if val not in val_map or (i + l - 1 - i) < (val_map[val][1] - val_map[val][0]):
                    val_map[val] = [i, i + l - 1]
        
        res = []
        for first, second in queries:
            target = first ^ second
            if target in val_map:
                res.append(val_map[target])
            else:
                res.append([-1, -1])
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 2}, {'name': 'substringXorQueries', 'complexity': 7, 'lineno': 3}], 'maintainability_index': 54.15935796197449, 'raw_metrics': {'loc': 19, 'lloc': 20, 'sloc': 19, 'comments': 0}}"
maximum-strength-of-k-disjoint-subarrays,"```python
from typing import List

class Solution:
    def maximumStrength(self, nums: List[int], k: int) -> int:
        n = len(nums)
        dp = [[[-10**18, -10**18] for _ in range(k+1)] for __ in range(n+1)]
        dp[0][0][0] = 0
        
        for i in range(1, n+1):
            num = nums[i-1]
            for j in range(k+1):
                if dp[i-1][j][0] > dp[i-1][j][1]:
                    dp[i][j][0] = dp[i-1][j][0]
                else:
                    dp[i][j][0] = dp[i-1][j][1]
                
                if j > 0:
                    coeff = k - j + 1
                    if j % 2 == 0:
                        coeff = -coeff
                    prev_max = max(dp[i-1][j-1][0], dp[i-1][j-1][1])
                    new_val = prev_max + coeff * num
                    cont_val = dp[i-1][j][1] + coeff * num
                    dp[i][j][1] = max(new_val, cont_val)
        
        return max(dp[n][k][0], dp[n][k][1])
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 3}, {'name': 'maximumStrength', 'complexity': 8, 'lineno': 4}], 'maintainability_index': 50.804390158941146, 'raw_metrics': {'loc': 23, 'lloc': 23, 'sloc': 23, 'comments': 0}}"
sum-of-prefix-scores-of-strings,"```python
class Solution:
    def sumPrefixScores(self, words: List[str]) -> List[int]:
        prefix_counts = {}
        
        for word in words:
            for i in range(1, len(word)+1):
                prefix = word[:i]
                prefix_counts[prefix] = prefix_counts.get(prefix, 0) + 1
        
        answer = []
        for word in words:
            total = 0
            for i in range(1, len(word)+1):
                prefix = word[:i]
                total += prefix_counts[prefix]
            answer.append(total)
        
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'sumPrefixScores', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 61.11508815272096, 'raw_metrics': {'loc': 16, 'lloc': 18, 'sloc': 16, 'comments': 0}}"
maximal-score-after-applying-k-operations,"```python
import heapq
from typing import List

class Solution:
    def maxKelements(self, nums: List[int], k: int) -> int:
        max_heap = []
        for num in nums:
            heapq.heappush(max_heap, -num)
        
        total = 0
        for _ in range(k):
            if not max_heap:
                break
            current = -heapq.heappop(max_heap)
            total += current
            new_val = (current + 2) // 3  # Equivalent to math.ceil(current / 3)
            heapq.heappush(max_heap, -new_val)
        
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 4}, {'name': 'maxKelements', 'complexity': 4, 'lineno': 5}], 'maintainability_index': 73.97573286908013, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 1}}"
minimum-moves-to-convert-string,"```python
class Solution:
    def minimumMoves(self, s: str) -> int:
        moves = 0
        i = 0
        n = len(s)
        while i < n:
            if s[i] == 'X':
                moves += 1
                i += 3
            else:
                i += 1
        return moves
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'minimumMoves', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 64.03497972244963, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
minimize-the-total-price-of-the-trips,"```python
from typing import List
from collections import defaultdict, deque

class Solution:
    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:
        graph = defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        count = [0] * n
        for start, end in trips:
            parent = {}
            visited = set()
            q = deque()
            q.append(start)
            visited.add(start)
            found = False
            while q and not found:
                node = q.popleft()
                for neighbor in graph[node]:
                    if neighbor not in visited:
                        parent[neighbor] = node
                        visited.add(neighbor)
                        q.append(neighbor)
                        if neighbor == end:
                            found = True
                            break
            path = []
            current = end
            while current != start:
                path.append(current)
                current = parent[current]
            path.append(start)
            for node in path:
                count[node] += 1
        
        dp = [[0, 0] for _ in range(n)]
        
        visited = [False] * n
        
        def dfs(node, parent):
            visited[node] = True
            for neighbor in graph[node]:
                if neighbor != parent and not visited[neighbor]:
                    dfs(neighbor, node)
            halve = (price[node] // 2) * count[node]
            no_halve = price[node] * count[node]
            
            for neighbor in graph[node]:
                if neighbor != parent:
                    halve += dp[neighbor][0]
                    no_halve += min(dp[neighbor][0], dp[neighbor][1])
            
            dp[node][0] = no_halve
            dp[node][1] = halve
        
        dfs(0, -1)
        
        return min(dp[0][0], dp[0][1])
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 4}, {'name': 'minimumTotalPrice', 'complexity': 11, 'lineno': 5}], 'maintainability_index': 43.97771276761826, 'raw_metrics': {'loc': 52, 'lloc': 52, 'sloc': 52, 'comments': 0}}"
find-the-longest-semi-repetitive-substring,"```python
class Solution:
    def longestSemiRepetitiveSubstring(self, s: str) -> int:
        max_len = 1
        n = len(s)
        for i in range(n):
            count = 0
            for j in range(i + 1, n):
                if s[j] == s[j - 1]:
                    count += 1
                    if count > 1:
                        break
                current_len = j - i + 1
                if current_len > max_len:
                    max_len = current_len
        return max_len
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 1}, {'name': 'longestSemiRepetitiveSubstring', 'complexity': 6, 'lineno': 2}], 'maintainability_index': 59.7600925243392, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
furthest-point-from-origin,"```python
class Solution:
    def furthestDistanceFromOrigin(self, moves: str) -> int:
        left = moves.count('L')
        right = moves.count('R')
        underscore = moves.count('_')
        return abs(left - right) + underscore
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 1}, {'name': 'furthestDistanceFromOrigin', 'complexity': 1, 'lineno': 2}], 'maintainability_index': 74.41979541019013, 'raw_metrics': {'loc': 6, 'lloc': 6, 'sloc': 6, 'comments': 0}}"
partition-array-into-two-arrays-to-minimize-sum-difference,"```python
class Solution:
    def minimumDifference(self, nums: List[int]) -> int:
        n = len(nums) // 2
        total = sum(nums)
        half = total // 2
        
        left = nums[:n]
        right = nums[n:]
        
        left_sums = [[] for _ in range(n+1)]
        right_sums = [[] for _ in range(n+1)]
        
        for mask in range(1 << n):
            cnt = bin(mask).count('1')
            sum_l = 0
            sum_r = 0
            for i in range(n):
                if mask & (1 << i):
                    sum_l += left[i]
                    sum_r += right[i]
            left_sums[cnt].append(sum_l)
            right_sums[cnt].append(sum_r)
        
        for k in range(n+1):
            right_sums[k].sort()
        
        min_diff = float('inf')
        
        for k in range(n+1):
            for sum_l in left_sums[k]:
                remaining = half - sum_l
                arr = right_sums[n -k]
                low, high = 0, len(arr) -1
                while low <= high:
                    mid = (low + high) // 2
                    if arr[mid] <= remaining:
                        low = mid +1
                    else:
                        high = mid -1
                if high >=0:
                    sum_r = arr[high]
                    current_sum = sum_l + sum_r
                    diff = abs(total - 2 * current_sum)
                    if diff < min_diff:
                        min_diff = diff
                if low < len(arr):
                    sum_r = arr[low]
                    current_sum = sum_l + sum_r
                    diff = abs(total - 2 * current_sum)
                    if diff < min_diff:
                        min_diff = diff
                if min_diff ==0:
                    return 0
        return min_diff
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 17, 'lineno': 2}, {'name': 'minimumDifference', 'complexity': 16, 'lineno': 3}], 'maintainability_index': 41.63986815263003, 'raw_metrics': {'loc': 49, 'lloc': 51, 'sloc': 49, 'comments': 0}}"
count-tested-devices-after-test-operations,"```python
from typing import List

class Solution:
    def countTestedDevices(self, batteryPercentages: List[int]) -> int:
        count = 0
        for i in range(len(batteryPercentages)):
            if batteryPercentages[i] > 0:
                count += 1
                for j in range(i + 1, len(batteryPercentages)):
                    batteryPercentages[j] = max(0, batteryPercentages[j] - 1)
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'countTestedDevices', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 65.54578992527813, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
maximum-strictly-increasing-cells-in-a-matrix,"```python
from collections import defaultdict
from bisect import bisect_right

class Solution:
    def maxIncreasingCells(self, mat: List[List[int]]) -> int:
        m = len(mat)
        n = len(mat[0]) if m > 0 else 0
        
        value_positions = defaultdict(list)
        for i in range(m):
            for j in range(n):
                value_positions[mat[i][j]].append((i, j))
        
        sorted_values = sorted(value_positions.keys())
        
        row_max = [0] * m
        col_max = [0] * n
        
        temp_row = defaultdict(int)
        temp_col = defaultdict(int)
        
        for val in sorted_values:
            for i, j in value_positions[val]:
                max_step = max(row_max[i], col_max[j]) + 1
                temp_row[i] = max(temp_row[i], max_step)
                temp_col[j] = max(temp_col[j], max_step)
            
            for i, j in value_positions[val]:
                row_max[i] = max(row_max[i], temp_row[i])
                col_max[j] = max(col_max[j], temp_col[j])
        
        return max(max(row_max), max(col_max))
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 4}, {'name': 'maxIncreasingCells', 'complexity': 7, 'lineno': 5}], 'maintainability_index': 57.222141026855866, 'raw_metrics': {'loc': 25, 'lloc': 25, 'sloc': 25, 'comments': 0}}"
minimum-penalty-for-a-shop,"```python
class Solution:
    def bestClosingTime(self, customers: str) -> int:
        n = len(customers)
        prefix_n = [0] * (n + 1)
        suffix_y = [0] * (n + 1)
        
        for i in range(1, n + 1):
            prefix_n[i] = prefix_n[i - 1] + (1 if customers[i - 1] == 'N' else 0)
        
        for i in range(n - 1, -1, -1):
            suffix_y[i] = suffix_y[i + 1] + (1 if customers[i] == 'Y' else 0)
        
        min_penalty = float('inf')
        best_hour = 0
        
        for hour in range(n + 1):
            penalty = prefix_n[hour] + suffix_y[hour]
            if penalty < min_penalty:
                min_penalty = penalty
                best_hour = hour
        
        return best_hour
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 1}, {'name': 'bestClosingTime', 'complexity': 7, 'lineno': 2}], 'maintainability_index': 55.39803625030909, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
check-if-all-characters-have-equal-number-of-occurrences,"```python
class Solution:
    def areOccurrencesEqual(self, s: str) -> bool:
        from collections import Counter
        counts = Counter(s).values()
        return len(set(counts)) == 1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 1}, {'name': 'areOccurrencesEqual', 'complexity': 1, 'lineno': 2}], 'maintainability_index': 79.7423427057672, 'raw_metrics': {'loc': 5, 'lloc': 5, 'sloc': 5, 'comments': 0}}"
count-subarrays-of-length-three-with-a-condition,"```python
from typing import List

class Solution:
    def countSubarrays(self, nums: List[int]) -> int:
        count = 0
        for i in range(len(nums) - 2):
            first = nums[i]
            second = nums[i+1]
            third = nums[i+2]
            if first + third == second / 2:
                count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'countSubarrays', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 62.59703809801501, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
longest-even-odd-subarray-with-threshold,"```python
from typing import List

class Solution:
    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:
        max_len = 0
        n = len(nums)
        for l in range(n):
            if nums[l] % 2 == 0 and nums[l] <= threshold:
                current_len = 1
                if current_len > max_len:
                    max_len = current_len
                for r in range(l + 1, n):
                    if nums[r] > threshold:
                        break
                    if nums[r-1] % 2 == nums[r] % 2:
                        break
                    current_len += 1
                    if current_len > max_len:
                        max_len = current_len
        return max_len
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 3}, {'name': 'longestAlternatingSubarray', 'complexity': 9, 'lineno': 4}], 'maintainability_index': 54.464200062522714, 'raw_metrics': {'loc': 20, 'lloc': 20, 'sloc': 20, 'comments': 0}}"
count-integers-with-even-digit-sum,"```python
class Solution:
    def countEven(self, num: int) -> int:
        count = 0
        for i in range(1, num + 1):
            digit_sum = sum(int(d) for d in str(i))
            if digit_sum % 2 == 0:
                count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 1}, {'name': 'countEven', 'complexity': 4, 'lineno': 2}], 'maintainability_index': 68.42029037635967, 'raw_metrics': {'loc': 8, 'lloc': 8, 'sloc': 8, 'comments': 0}}"
neighboring-bitwise-xor,"```python
from typing import List

class Solution:
    def doesValidArrayExist(self, derived: List[int]) -> bool:
        n = len(derived)
        original0 = 0
        current = original0
        for i in range(n - 1):
            current = derived[i] ^ current
        if (current ^ original0) == derived[-1]:
            return True
        original0 = 1
        current = original0
        for i in range(n - 1):
            current = derived[i] ^ current
        if (current ^ original0) == derived[-1]:
            return True
        return False
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'doesValidArrayExist', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 57.61196118099657, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
minimum-score-by-changing-two-elements,"```python
from typing import List

class Solution:
    def minimizeSum(self, nums: List[int]) -> int:
        nums.sort()
        option1 = nums[-3] - nums[0]
        option2 = nums[-1] - nums[2]
        option3 = nums[-2] - nums[1]
        min_high = min(option1, option2, option3)
        return min_high
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 3}, {'name': 'minimizeSum', 'complexity': 1, 'lineno': 4}], 'maintainability_index': 65.90790530382287, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
booking-concert-tickets-in-groups,"```python
import bisect

class BookMyShow:

    def __init__(self, n: int, m: int):
        self.n = n
        self.m = m
        self.min_row = 0
        self.rows = [0] * n  # tracks the next available seat in each row
        self.seg_tree = [0] * (4 * n)  # segment tree for max remaining seats in a range
        self.sum_tree = [0] * (4 * n)  # segment tree for sum of remaining seats in a range
        
        def build(node, l, r):
            if l == r:
                self.seg_tree[node] = self.m
                self.sum_tree[node] = self.m
                return
            mid = (l + r) // 2
            build(2 * node + 1, l, mid)
            build(2 * node + 2, mid + 1, r)
            self.seg_tree[node] = max(self.seg_tree[2 * node + 1], self.seg_tree[2 * node + 2])
            self.sum_tree[node] = self.sum_tree[2 * node + 1] + self.sum_tree[2 * node + 2]
        
        build(0, 0, n - 1)

    def gather(self, k: int, maxRow: int) -> List[int]:
        def query_max(node, l, r, max_row, val):
            if l > max_row or self.seg_tree[node] < val:
                return -1
            if l == r:
                return l
            mid = (l + r) // 2
            left = query_max(2 * node + 1, l, mid, max_row, val)
            if left != -1:
                return left
            return query_max(2 * node + 2, mid + 1, r, max_row, val)
        
        row = query_max(0, 0, self.n - 1, maxRow, k)
        if row == -1:
            return []
        seat = self.rows[row]
        self.rows[row] += k
        
        def update_seg(node, l, r, pos):
            if l == r:
                self.seg_tree[node] = self.m - self.rows[pos]
                self.sum_tree[node] = self.m - self.rows[pos]
                return
            mid = (l + r) // 2
            if pos <= mid:
                update_seg(2 * node + 1, l, mid, pos)
            else:
                update_seg(2 * node + 2, mid + 1, r, pos)
            self.seg_tree[node] = max(self.seg_tree[2 * node + 1], self.seg_tree[2 * node + 2])
            self.sum_tree[node] = self.sum_tree[2 * node + 1] + self.sum_tree[2 * node + 2]
        
        update_seg(0, 0, self.n - 1, row)
        return [row, seat]

    def scatter(self, k: int, maxRow: int) -> bool:
        def query_sum(node, l, r, max_row):
            if l > max_row:
                return 0
            if r <= max_row:
                return self.sum_tree[node]
            mid = (l + r) // 2
            return query_sum(2 * node + 1, l, mid, max_row) + query_sum(2 * node + 2, mid + 1, r, max_row)
        
        total = query_sum(0, 0, self.n - 1, maxRow)
        if total < k:
            return False
        
        remaining = k
        while remaining > 0 and self.min_row <= maxRow:
            row = self.min_row
            available = self.m - self.rows[row]
            take = min(available, remaining)
            self.rows[row] += take
            remaining -= take
            if self.rows[row] == self.m:
                self.min_row += 1
            
            def update_seg(node, l, r, pos):
                if l == r:
                    self.seg_tree[node] = self.m - self.rows[pos]
                    self.sum_tree[node] = self.m - self.rows[pos]
                    return
                mid = (l + r) // 2
                if pos <= mid:
                    update_seg(2 * node + 1, l, mid, pos)
                else:
                    update_seg(2 * node + 2, mid + 1, r, pos)
                self.seg_tree[node] = max(self.seg_tree[2 * node + 1], self.seg_tree[2 * node + 2])
                self.sum_tree[node] = self.sum_tree[2 * node + 1] + self.sum_tree[2 * node + 2]
            
            update_seg(0, 0, self.n - 1, row)
        return True
```","{'cyclomatic_complexity': [{'name': 'BookMyShow', 'complexity': 4, 'lineno': 3}, {'name': '__init__', 'complexity': 1, 'lineno': 4}, {'name': 'gather', 'complexity': 2, 'lineno': 22}, {'name': 'scatter', 'complexity': 5, 'lineno': 52}], 'maintainability_index': 44.54926527679056, 'raw_metrics': {'loc': 85, 'lloc': 85, 'sloc': 85, 'comments': 3}}"
count-items-matching-a-rule,"```python
class Solution:
    def countMatches(self, items: List[List[str]], ruleKey: str, ruleValue: str) -> int:
        count = 0
        key_map = {""type"": 0, ""color"": 1, ""name"": 2}
        index = key_map[ruleKey]
        for item in items:
            if item[index] == ruleValue:
                count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'countMatches', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 68.40845037051814, 'raw_metrics': {'loc': 10, 'lloc': 11, 'sloc': 10, 'comments': 0}}"
create-sorted-array-through-instructions,"```python
import bisect

class Solution:
    def createSortedArray(self, instructions: List[int]) -> int:
        nums = []
        total_cost = 0
        mod = 10**9 + 7
        
        for num in instructions:
            left = bisect.bisect_left(nums, num)
            right = bisect.bisect_right(nums, num)
            cost = min(left, len(nums) - right)
            total_cost = (total_cost + cost) % mod
            bisect.insort(nums, num)
        
        return total_cost
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 3}, {'name': 'createSortedArray', 'complexity': 2, 'lineno': 4}], 'maintainability_index': 62.294356587622445, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
check-if-an-original-string-exists-given-two-encoded-strings,"```python
class Solution:
    def possiblyEquals(self, s1: str, s2: str) -> bool:
        from functools import lru_cache

        def get_possible_lengths(s):
            res = [int(s)]
            if len(s) >= 2:
                a, b = s[:1], s[1:]
                for la in get_possible_lengths(a):
                    for lb in get_possible_lengths(b):
                        res.append(la + lb)
            if len(s) >= 3:
                a, b = s[:2], s[2:]
                for la in get_possible_lengths(a):
                    for lb in get_possible_lengths(b):
                        res.append(la + lb)
            return list(set(res))

        @lru_cache(maxsize=None)
        def dfs(i, j, diff):
            if i == len(s1) and j == len(s2):
                return diff == 0
            if i < len(s1) and s1[i].isdigit():
                k = i
                while k < len(s1) and s1[k].isdigit():
                    k += 1
                for l in get_possible_lengths(s1[i:k]):
                    if dfs(k, j, diff - l):
                        return True
                return False
            if j < len(s2) and s2[j].isdigit():
                k = j
                while k < len(s2) and s2[k].isdigit():
                    k += 1
                for l in get_possible_lengths(s2[j:k]):
                    if dfs(i, k, diff + l):
                        return True
                return False
            if diff == 0:
                if i < len(s1) and j < len(s2) and s1[i] == s2[j]:
                    return dfs(i + 1, j + 1, 0)
                else:
                    return False
            elif diff > 0:
                if i < len(s1):
                    return dfs(i + 1, j, diff - 1)
                else:
                    return False
            else:
                if j < len(s2):
                    return dfs(i, j + 1, diff + 1)
                else:
                    return False

        return dfs(0, 0, 0)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 1}, {'name': 'possiblyEquals', 'complexity': 1, 'lineno': 2}], 'maintainability_index': 42.66718471618433, 'raw_metrics': {'loc': 52, 'lloc': 54, 'sloc': 52, 'comments': 0}}"
second-minimum-time-to-reach-destination,"```python
from typing import List
import heapq

class Solution:
    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:
        graph = [[] for _ in range(n + 1)]
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        min_times = [[float('inf')] * 2 for _ in range(n + 1)]
        min_times[1][0] = 0
        heap = []
        heapq.heappush(heap, (0, 1))
        
        while heap:
            current_time, node = heapq.heappop(heap)
            if node == n and current_time > min_times[n][0]:
                return current_time
            
            for neighbor in graph[node]:
                total_time = current_time
                if (total_time // change) % 2 == 1:
                    total_time += change - (total_time % change)
                total_time += time
                
                if total_time < min_times[neighbor][0]:
                    min_times[neighbor][1] = min_times[neighbor][0]
                    min_times[neighbor][0] = total_time
                    heapq.heappush(heap, (total_time, neighbor))
                elif min_times[neighbor][0] < total_time < min_times[neighbor][1]:
                    min_times[neighbor][1] = total_time
                    heapq.heappush(heap, (total_time, neighbor))
        
        return min_times[n][1]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 4}, {'name': 'secondMinimum', 'complexity': 11, 'lineno': 5}], 'maintainability_index': 49.68132770820343, 'raw_metrics': {'loc': 30, 'lloc': 30, 'sloc': 30, 'comments': 0}}"
count-substrings-starting-and-ending-with-given-character,"```python
class Solution:
    def countSubstrings(self, s: str, c: str) -> int:
        count = s.count(c)
        return count * (count + 1) // 2
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 1}, {'name': 'countSubstrings', 'complexity': 1, 'lineno': 2}], 'maintainability_index': 76.57525125534227, 'raw_metrics': {'loc': 4, 'lloc': 4, 'sloc': 4, 'comments': 0}}"
count-days-without-meetings,"```python
class Solution:
    def countDays(self, days: int, meetings: List[List[int]]) -> int:
        if not meetings:
            return days
        
        meetings.sort()
        
        merged = []
        for meeting in meetings:
            if not merged:
                merged.append(meeting)
            else:
                last_start, last_end = merged[-1]
                current_start, current_end = meeting
                if current_start <= last_end + 1:
                    new_start = last_start
                    new_end = max(last_end, current_end)
                    merged[-1] = [new_start, new_end]
                else:
                    merged.append(meeting)
        
        total_meeting_days = 0
        for interval in merged:
            start, end = interval
            total_meeting_days += end - start + 1
        
        return days - total_meeting_days
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 2}, {'name': 'countDays', 'complexity': 6, 'lineno': 3}], 'maintainability_index': 54.76153148233804, 'raw_metrics': {'loc': 24, 'lloc': 24, 'sloc': 24, 'comments': 0}}"
build-array-where-you-can-find-the-maximum-exactly-k-comparisons,"```python
class Solution:
    def numOfArrays(self, n: int, m: int, k: int) -> int:
        MOD = 10**9 + 7
        if k == 0:
            return 0
        
        dp = [[[0] * (m + 1) for _ in range(k + 1)] for __ in range(n + 1)]
        
        for num in range(1, m + 1):
            dp[1][1][num] = 1
        
        for i in range(2, n + 1):
            for cost in range(1, k + 1):
                for max_num in range(1, m + 1):
                    dp[i][cost][max_num] = dp[i - 1][cost][max_num] * max_num % MOD
                    for prev_max in range(1, max_num):
                        dp[i][cost][max_num] = (dp[i][cost][max_num] + dp[i - 1][cost - 1][prev_max]) % MOD
        
        total = 0
        for num in range(1, m + 1):
            total = (total + dp[n][k][num]) % MOD
        
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 1}, {'name': 'numOfArrays', 'complexity': 10, 'lineno': 2}], 'maintainability_index': 53.73241974776197, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
minimum-time-to-remove-all-cars-containing-illegal-goods,"```python
class Solution:
    def minimumTime(self, s: str) -> int:
        n = len(s)
        left = [0] * n
        left[0] = 1 if s[0] == '1' else 0
        for i in range(1, n):
            if s[i] == '1':
                left[i] = min(left[i-1] + 2, i + 1)
            else:
                left[i] = left[i-1]
        
        right = [0] * n
        right[-1] = 1 if s[-1] == '1' else 0
        for i in range(n-2, -1, -1):
            if s[i] == '1':
                right[i] = min(right[i+1] + 2, n - i)
            else:
                right[i] = right[i+1]
        
        res = min(left[-1], right[0])
        for i in range(n-1):
            res = min(res, left[i] + right[i+1])
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 1}, {'name': 'minimumTime', 'complexity': 8, 'lineno': 2}], 'maintainability_index': 52.848711138297006, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
count-symmetric-integers,"```python
class Solution:
    def countSymmetricIntegers(self, low: int, high: int) -> int:
        count = 0
        for num in range(low, high + 1):
            s = str(num)
            n = len(s)
            if n % 2 != 0:
                continue
            half = n // 2
            first_sum = sum(int(d) for d in s[:half])
            second_sum = sum(int(d) for d in s[half:])
            if first_sum == second_sum:
                count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 1}, {'name': 'countSymmetricIntegers', 'complexity': 6, 'lineno': 2}], 'maintainability_index': 59.93688251987633, 'raw_metrics': {'loc': 14, 'lloc': 16, 'sloc': 14, 'comments': 0}}"
maximum-number-of-achievable-transfer-requests,"```python
from typing import List

class Solution:
    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:
        max_requests = 0
        m = len(requests)
        
        for mask in range(1 << m):
            count = bin(mask).count('1')
            if count <= max_requests:
                continue
            
            balance = [0] * n
            for i in range(m):
                if mask & (1 << i):
                    from_b, to_b = requests[i]
                    balance[from_b] -= 1
                    balance[to_b] += 1
            
            if all(b == 0 for b in balance):
                max_requests = count
        
        return max_requests
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'maximumRequests', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 56.91401180746898, 'raw_metrics': {'loc': 19, 'lloc': 19, 'sloc': 19, 'comments': 0}}"
find-the-original-typed-string-i,"```python
class Solution:
    def possibleStringCount(self, word: str) -> int:
        if not word:
            return 0
        
        count = 0
        n = len(word)
        i = 0
        
        while i < n:
            current_char = word[i]
            j = i + 1
            while j < n and word[j] == current_char:
                j += 1
            length = j - i
            if length > 1:
                count += 1
            i = j
        
        if count == 0:
            return 1
        
        total = 0
        i = 0
        while i < n:
            current_char = word[i]
            j = i + 1
            while j < n and word[j] == current_char:
                j += 1
            length = j - i
            if length > 1:
                total += (length - 1)
            i = j
        
        return total + 1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 1}, {'name': 'possibleStringCount', 'complexity': 11, 'lineno': 2}], 'maintainability_index': 48.83936993758894, 'raw_metrics': {'loc': 30, 'lloc': 30, 'sloc': 30, 'comments': 0}}"
count-beautiful-substrings-i,"```python
class Solution:
    def beautifulSubstrings(self, s: str, k: int) -> int:
        vowels = {'a', 'e', 'i', 'o', 'u'}
        n = len(s)
        count = 0
        for i in range(n):
            v = 0
            c = 0
            for j in range(i, n):
                if s[j] in vowels:
                    v += 1
                else:
                    c += 1
                if v == c and (v * c) % k == 0:
                    count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 1}, {'name': 'beautifulSubstrings', 'complexity': 6, 'lineno': 2}], 'maintainability_index': 58.42727551725125, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
odd-string-difference,"```python
class Solution:
    def oddString(self, words: List[str]) -> str:
        diff_dict = {}
        for word in words:
            diff = []
            for i in range(len(word) - 1):
                diff.append(ord(word[i+1]) - ord(word[i]))
            diff_tuple = tuple(diff)
            if diff_tuple in diff_dict:
                diff_dict[diff_tuple].append(word)
            else:
                diff_dict[diff_tuple] = [word]
        for key in diff_dict:
            if len(diff_dict[key]) == 1:
                return diff_dict[key][0]
        return """"
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 2}, {'name': 'oddString', 'complexity': 6, 'lineno': 3}], 'maintainability_index': 60.099995969610205, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
count-pairs-of-similar-strings,"```python
class Solution:
    def similarPairs(self, words: List[str]) -> int:
        count = 0
        n = len(words)
        for i in range(n):
            set_i = set(words[i])
            for j in range(i + 1, n):
                set_j = set(words[j])
                if set_i == set_j:
                    count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'similarPairs', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 65.96566214576278, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
minimum-number-of-removals-to-make-mountain-array,"```python
from typing import List

class Solution:
    def minimumMountainRemovals(self, nums: List[int]) -> int:
        n = len(nums)
        left = [1] * n
        right = [1] * n
        
        for i in range(1, n):
            for j in range(i):
                if nums[j] < nums[i]:
                    left[i] = max(left[i], left[j] + 1)
        
        for i in range(n-2, -1, -1):
            for j in range(n-1, i, -1):
                if nums[j] < nums[i]:
                    right[i] = max(right[i], right[j] + 1)
        
        max_len = 0
        for i in range(1, n-1):
            if left[i] > 1 and right[i] > 1:
                max_len = max(max_len, left[i] + right[i] - 1)
        
        return n - max_len
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 3}, {'name': 'minimumMountainRemovals', 'complexity': 10, 'lineno': 4}], 'maintainability_index': 53.47709494679826, 'raw_metrics': {'loc': 20, 'lloc': 20, 'sloc': 20, 'comments': 0}}"
remove-max-number-of-edges-to-keep-graph-fully-traversable,"```python
class Solution:
    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:
        parent_alice = list(range(n + 1))
        parent_bob = list(range(n + 1))
        
        def find(parent, x):
            while parent[x] != x:
                parent[x] = parent[parent[x]]
                x = parent[x]
            return x
        
        def union(parent, x, y):
            x_root = find(parent, x)
            y_root = find(parent, y)
            if x_root == y_root:
                return False
            parent[y_root] = x_root
            return True
        
        edges.sort(reverse=True)
        removed = 0
        alice_components = n
        bob_components = n
        
        for typ, u, v in edges:
            if typ == 3:
                alice_union = union(parent_alice, u, v)
                bob_union = union(parent_bob, u, v)
                if alice_union and bob_union:
                    alice_components -= 1
                    bob_components -= 1
                elif not alice_union and not bob_union:
                    removed += 1
            elif typ == 2:
                if union(parent_bob, u, v):
                    bob_components -= 1
                else:
                    removed += 1
            elif typ == 1:
                if union(parent_alice, u, v):
                    alice_components -= 1
                else:
                    removed += 1
        
        if alice_components != 1 or bob_components != 1:
            return -1
        return removed
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 14, 'lineno': 2}, {'name': 'maxNumEdgesToRemove', 'complexity': 13, 'lineno': 3}], 'maintainability_index': 45.179208204265784, 'raw_metrics': {'loc': 43, 'lloc': 43, 'sloc': 43, 'comments': 0}}"
divisible-and-non-divisible-sums-difference,"```python
class Solution:
    def differenceOfSums(self, n: int, m: int) -> int:
        total_sum = n * (n + 1) // 2
        k = n // m
        divisible_sum = m * k * (k + 1) // 2
        non_divisible_sum = total_sum - divisible_sum
        return non_divisible_sum - divisible_sum
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 1}, {'name': 'differenceOfSums', 'complexity': 1, 'lineno': 2}], 'maintainability_index': 66.67182578058902, 'raw_metrics': {'loc': 7, 'lloc': 7, 'sloc': 7, 'comments': 0}}"
find-the-longest-balanced-substring-of-a-binary-string,"```python
class Solution:
    def findTheLongestBalancedSubstring(self, s: str) -> int:
        max_len = 0
        n = len(s)
        for i in range(n):
            zeros = 0
            ones = 0
            for j in range(i, n):
                if s[j] == '0':
                    if ones == 0:
                        zeros += 1
                    else:
                        break
                else:
                    ones += 1
                    if zeros == ones:
                        max_len = max(max_len, 2 * ones)
        return max_len
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 1}, {'name': 'findTheLongestBalancedSubstring', 'complexity': 6, 'lineno': 2}], 'maintainability_index': 59.235794431993014, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
minimum-index-of-a-valid-split,"```python
from collections import defaultdict
from typing import List

class Solution:
    def minimumIndex(self, nums: List[int]) -> int:
        freq = defaultdict(int)
        dominant = None
        max_count = 0
        
        for num in nums:
            freq[num] += 1
            if freq[num] > max_count:
                max_count = freq[num]
                dominant = num
        
        total = max_count
        left_count = 0
        
        for i in range(len(nums) - 1):
            if nums[i] == dominant:
                left_count += 1
            right_count = total - left_count
            
            left_len = i + 1
            right_len = len(nums) - left_len
            
            if left_count * 2 > left_len and right_count * 2 > right_len:
                return i
        
        return -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 4}, {'name': 'minimumIndex', 'complexity': 7, 'lineno': 5}], 'maintainability_index': 52.81704191945441, 'raw_metrics': {'loc': 24, 'lloc': 24, 'sloc': 24, 'comments': 0}}"
find-the-key-of-the-numbers,"```python
class Solution:
    def generateKey(self, num1: int, num2: int, num3: int) -> int:
        s1 = f""{num1:04d}""
        s2 = f""{num2:04d}""
        s3 = f""{num3:04d}""
        key_digits = []
        for i in range(4):
            min_digit = min(s1[i], s2[i], s3[i])
            key_digits.append(min_digit)
        key_str = ''.join(key_digits)
        return int(key_str)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 1}, {'name': 'generateKey', 'complexity': 2, 'lineno': 2}], 'maintainability_index': 100.0, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
difference-between-element-sum-and-digit-sum-of-an-array,"```python
from typing import List

class Solution:
    def differenceOfSum(self, nums: List[int]) -> int:
        element_sum = sum(nums)
        digit_sum = 0
        for num in nums:
            for digit in str(num):
                digit_sum += int(digit)
        return abs(element_sum - digit_sum)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'differenceOfSum', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 69.63772110572219, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
check-if-the-number-is-fascinating,"```python
class Solution:
    def isFascinating(self, n: int) -> bool:
        concatenated = str(n) + str(2 * n) + str(3 * n)
        if '0' in concatenated:
            return False
        if len(concatenated) != 9:
            return False
        digits = set(concatenated)
        return len(digits) == 9 and all(str(i) in digits for i in range(1, 10))
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 1}, {'name': 'isFascinating', 'complexity': 5, 'lineno': 2}], 'maintainability_index': 63.80847911671637, 'raw_metrics': {'loc': 9, 'lloc': 9, 'sloc': 9, 'comments': 0}}"
count-special-quadruplets,"```python
from typing import List

class Solution:
    def countQuadruplets(self, nums: List[int]) -> int:
        n = len(nums)
        count = 0
        for a in range(n):
            for b in range(a + 1, n):
                for c in range(b + 1, n):
                    for d in range(c + 1, n):
                        if nums[a] + nums[b] + nums[c] == nums[d]:
                            count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'countQuadruplets', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 61.521845102483304, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
count-square-sum-triples,"```python
class Solution:
    def countTriples(self, n: int) -> int:
        count = 0
        for a in range(1, n + 1):
            for b in range(1, n + 1):
                c_square = a * a + b * b
                c = int(c_square ** 0.5)
                if c * c == c_square and c <= n:
                    count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 1}, {'name': 'countTriples', 'complexity': 5, 'lineno': 2}], 'maintainability_index': 62.34785954931653, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
total-distance-traveled,"```python
class Solution:
    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:
        distance = 0
        while mainTank > 0:
            fuel_used = min(mainTank, 5)
            distance += fuel_used * 10
            mainTank -= fuel_used
            if fuel_used == 5 and additionalTank > 0:
                mainTank += 1
                additionalTank -= 1
        return distance
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 1}, {'name': 'distanceTraveled', 'complexity': 4, 'lineno': 2}], 'maintainability_index': 62.306747229000216, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
transformed-array,"```python
from typing import List

class Solution:
    def constructTransformedArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        result = [0] * n
        for i in range(n):
            if nums[i] == 0:
                result[i] = 0
            else:
                steps = nums[i]
                new_pos = (i + steps) % n
                result[i] = nums[new_pos]
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'constructTransformedArray', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 63.12983292579381, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
maximum-employees-to-be-invited-to-a-meeting,"```python
class Solution:
    def maximumInvitations(self, favorite: List[int]) -> int:
        n = len(favorite)
        visited = [False] * n
        max_cycle = 0
        pair_chains = {}

        for i in range(n):
            if not visited[i]:
                path = []
                current = i
                while True:
                    if visited[current]:
                        if current in path:
                            idx = path.index(current)
                            cycle_len = len(path) - idx
                            max_cycle = max(max_cycle, cycle_len)
                        break
                    visited[current] = True
                    path.append(current)
                    current = favorite[current]

        mutual_pairs = []
        for i in range(n):
            if favorite[favorite[i]] == i and i < favorite[i]:
                mutual_pairs.append((i, favorite[i]))

        from collections import defaultdict
        graph = defaultdict(list)
        for u in range(n):
            v = favorite[u]
            if favorite[v] != u:
                graph[v].append(u)

        def dfs(node, forbidden):
            max_depth = 0
            for neighbor in graph[node]:
                if neighbor != forbidden:
                    max_depth = max(max_depth, dfs(neighbor, forbidden))
            return max_depth + 1

        total_pairs = 0
        for a, b in mutual_pairs:
            len_a = dfs(a, b)
            len_b = dfs(b, a)
            total_pairs += len_a + len_b

        return max(max_cycle, total_pairs)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 13, 'lineno': 2}, {'name': 'maximumInvitations', 'complexity': 12, 'lineno': 3}], 'maintainability_index': 46.941243526322644, 'raw_metrics': {'loc': 43, 'lloc': 43, 'sloc': 43, 'comments': 0}}"
sum-of-scores-of-built-strings,"```python
class Solution:
    def sumScores(self, s: str) -> int:
        n = len(s)
        z = [0] * n
        l, r = 0, 0
        for i in range(1, n):
            if i <= r:
                z[i] = min(r - i + 1, z[i - l])
            while i + z[i] < n and s[z[i]] == s[i + z[i]]:
                z[i] += 1
            if i + z[i] - 1 > r:
                l, r = i, i + z[i] - 1
        return sum(z) + n
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 1}, {'name': 'sumScores', 'complexity': 6, 'lineno': 2}], 'maintainability_index': 57.99595786127684, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
make-number-of-distinct-characters-equal,"```python
class Solution:
    def isItPossible(self, word1: str, word2: str) -> bool:
        from collections import defaultdict

        count1 = defaultdict(int)
        count2 = defaultdict(int)
        
        for c in word1:
            count1[c] += 1
        for c in word2:
            count2[c] += 1
        
        distinct1 = len(count1)
        distinct2 = len(count2)
        
        for c1 in list(count1.keys()):
            for c2 in list(count2.keys()):
                new_count1 = count1.copy()
                new_count2 = count2.copy()
                
                new_count1[c1] -= 1
                if new_count1[c1] == 0:
                    del new_count1[c1]
                new_count1[c2] += 1
                
                new_count2[c2] -= 1
                if new_count2[c2] == 0:
                    del new_count2[c2]
                new_count2[c1] += 1
                
                if len(new_count1) == len(new_count2):
                    return True
        return False
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 1}, {'name': 'isItPossible', 'complexity': 8, 'lineno': 2}], 'maintainability_index': 53.756857865764665, 'raw_metrics': {'loc': 26, 'lloc': 26, 'sloc': 26, 'comments': 0}}"
number-of-possible-sets-of-closing-branches,"```python
from typing import List

class Solution:
    def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:
        res = 0
        for mask in range(1 << n):
            active = [i for i in range(n) if (mask & (1 << i))]
            m = len(active)
            if m == 0:
                res += 1
                continue
            
            dist = [[float('inf')] * m for _ in range(m)]
            for i in range(m):
                dist[i][i] = 0
            
            node_to_idx = {node: idx for idx, node in enumerate(active)}
            
            for u, v, w in roads:
                if u in node_to_idx and v in node_to_idx:
                    i = node_to_idx[u]
                    j = node_to_idx[v]
                    if w < dist[i][j]:
                        dist[i][j] = w
                        dist[j][i] = w
            
            for k in range(m):
                for i in range(m):
                    for j in range(m):
                        if dist[i][k] + dist[k][j] < dist[i][j]:
                            dist[i][j] = dist[i][k] + dist[k][j]
            
            valid = True
            for i in range(m):
                for j in range(i + 1, m):
                    if dist[i][j] > maxDistance:
                        valid = False
                        break
                if not valid:
                    break
            if valid:
                res += 1
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 22, 'lineno': 3}, {'name': 'numberOfSets', 'complexity': 21, 'lineno': 4}], 'maintainability_index': 45.465473154365604, 'raw_metrics': {'loc': 38, 'lloc': 39, 'sloc': 38, 'comments': 0}}"
find-words-containing-character,"```python
class Solution:
    def findWordsContaining(self, words: List[str], x: str) -> List[int]:
        result = []
        for index, word in enumerate(words):
            if x in word:
                result.append(index)
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'findWordsContaining', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 75.0206708965386, 'raw_metrics': {'loc': 8, 'lloc': 8, 'sloc': 8, 'comments': 0}}"
last-day-where-you-can-still-cross,"```python
from typing import List

class Solution:
    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:
        left, right = 0, len(cells) - 1
        answer = 0
        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        while left <= right:
            mid = (left + right) // 2
            grid = [[0 for _ in range(col)] for _ in range(row)]
            for i in range(mid + 1):
                r, c = cells[i]
                grid[r-1][c-1] = 1
            
            queue = []
            for c in range(col):
                if grid[0][c] == 0:
                    queue.append((0, c))
                    grid[0][c] = 1
            
            found = False
            while queue:
                r, c = queue.pop(0)
                if r == row - 1:
                    found = True
                    break
                for dr, dc in dirs:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < row and 0 <= nc < col and grid[nr][nc] == 0:
                        grid[nr][nc] = 1
                        queue.append((nr, nc))
            
            if found:
                answer = mid
                left = mid + 1
            else:
                right = mid - 1
        
        return answer + 1 if answer + 1 < len(cells) else answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 16, 'lineno': 3}, {'name': 'latestDayToCross', 'complexity': 15, 'lineno': 4}], 'maintainability_index': 46.23956392871932, 'raw_metrics': {'loc': 35, 'lloc': 35, 'sloc': 35, 'comments': 0}}"
time-needed-to-buy-tickets,"```python
from typing import List

class Solution:
    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:
        time = 0
        while True:
            for i in range(len(tickets)):
                if tickets[i] > 0:
                    tickets[i] -= 1
                    time += 1
                    if i == k and tickets[i] == 0:
                        return time
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'timeRequiredToBuy', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 62.583813860820136, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
maximum-value-of-an-ordered-triplet-i,"```python
from typing import List

class Solution:
    def maximumTripletValue(self, nums: List[int]) -> int:
        max_val = 0
        n = len(nums)
        for i in range(n - 2):
            for j in range(i + 1, n - 1):
                for k in range(j + 1, n):
                    current = (nums[i] - nums[j]) * nums[k]
                    if current > max_val:
                        max_val = current
        return max_val if max_val > 0 else 0
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'maximumTripletValue', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 60.87907006636862, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
minimum-time-to-complete-all-tasks,"```python
class Solution:
    def findMinimumTime(self, tasks: List[List[int]]) -> int:
        tasks.sort(key=lambda x: x[1])
        used = set()
        for start, end, duration in tasks:
            needed = duration
            for t in range(end, start - 1, -1):
                if t in used:
                    needed -= 1
                    if needed == 0:
                        break
            for t in range(end, start - 1, -1):
                if needed <= 0:
                    break
                if t not in used:
                    used.add(t)
                    needed -= 1
        return len(used)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 2}, {'name': 'findMinimumTime', 'complexity': 8, 'lineno': 3}], 'maintainability_index': 56.39332400174851, 'raw_metrics': {'loc': 19, 'lloc': 20, 'sloc': 19, 'comments': 0}}"
find-x-sum-of-all-k-long-subarrays-i,"```python
from typing import List
from collections import defaultdict

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        answer = []
        n = len(nums)
        for i in range(n - k + 1):
            subarray = nums[i:i + k]
            freq = defaultdict(int)
            for num in subarray:
                freq[num] += 1
            
            sorted_items = sorted(freq.items(), key=lambda item: (-item[1], -item[0]))
            
            selected = []
            for item in sorted_items[:x]:
                selected.extend([item[0]] * item[1])
            
            answer.append(sum(selected))
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 4}, {'name': 'findXSum', 'complexity': 4, 'lineno': 5}], 'maintainability_index': 57.927481887188826, 'raw_metrics': {'loc': 18, 'lloc': 20, 'sloc': 18, 'comments': 0}}"
maximum-units-on-a-truck,"```python
class Solution:
    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:
        boxTypes.sort(key=lambda x: -x[1])
        total_units = 0
        remaining = truckSize
        for boxes, units in boxTypes:
            if remaining <= 0:
                break
            take = min(boxes, remaining)
            total_units += take * units
            remaining -= take
        return total_units
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'maximumUnits', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 62.55268039398196, 'raw_metrics': {'loc': 13, 'lloc': 14, 'sloc': 13, 'comments': 0}}"
divide-intervals-into-minimum-number-of-groups,"```python
import heapq

class Solution:
    def minGroups(self, intervals: List[List[int]]) -> int:
        intervals.sort()
        heap = []
        for start, end in intervals:
            if heap and heap[0] < start:
                heapq.heappop(heap)
            heapq.heappush(heap, end)
        return len(heap)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'minGroups', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 68.27394744654153, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
match-substring-after-replacement,"```python
from typing import List

class Solution:
    def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:
        from collections import defaultdict
        
        replace_map = defaultdict(set)
        for old, new in mappings:
            replace_map[old].add(new)
        
        len_sub = len(sub)
        len_s = len(s)
        
        for i in range(len_s - len_sub + 1):
            window = s[i:i+len_sub]
            match = True
            for j in range(len_sub):
                original_char = sub[j]
                window_char = window[j]
                if original_char == window_char:
                    continue
                if window_char in replace_map.get(original_char, set()):
                    continue
                match = False
                break
            if match:
                return True
        return False
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'matchReplacement', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 55.940283839646874, 'raw_metrics': {'loc': 25, 'lloc': 26, 'sloc': 25, 'comments': 0}}"
minimum-operations-to-make-the-array-k-increasing,"```python
import bisect
from typing import List

class Solution:
    def kIncreasing(self, arr: List[int], k: int) -> int:
        total_operations = 0
        for i in range(k):
            subseq = []
            for j in range(i, len(arr), k):
                subseq.append(arr[j])
            lis = []
            for num in subseq:
                idx = bisect.bisect_right(lis, num)
                if idx == len(lis):
                    lis.append(num)
                else:
                    lis[idx] = num
            total_operations += len(subseq) - len(lis)
        return total_operations
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 4}, {'name': 'kIncreasing', 'complexity': 5, 'lineno': 5}], 'maintainability_index': 61.10832719638137, 'raw_metrics': {'loc': 19, 'lloc': 19, 'sloc': 19, 'comments': 0}}"
average-value-of-even-numbers-that-are-divisible-by-three,"```python
from typing import List

class Solution:
    def averageValue(self, nums: List[int]) -> int:
        total = 0
        count = 0
        for num in nums:
            if num % 2 == 0 and num % 3 == 0:
                total += num
                count += 1
        return total // count if count > 0 else 0
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'averageValue', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 62.172244305023604, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
count-pairs-that-form-a-complete-day-ii,"```python
from typing import List
from collections import defaultdict

class Solution:
    def countCompleteDayPairs(self, hours: List[int]) -> int:
        mod_counts = defaultdict(int)
        count = 0
        for hour in hours:
            mod = hour % 24
            complement = (24 - mod) % 24
            count += mod_counts.get(complement, 0)
            mod_counts[mod] += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 4}, {'name': 'countCompleteDayPairs', 'complexity': 2, 'lineno': 5}], 'maintainability_index': 63.28784619015425, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
length-of-the-longest-valid-substring,"```python
class Solution:
    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:
        forbidden_set = set(forbidden)
        max_len = max(len(f) for f in forbidden) if forbidden else 0
        left = 0
        res = 0
        n = len(word)
        
        for right in range(n):
            for l in range(1, min(max_len + 1, right - left + 2)):
                substring = word[right - l + 1 : right + 1]
                if substring in forbidden_set:
                    left = right - l + 2
                    break
            res = max(res, right - left + 1)
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 2}, {'name': 'longestValidSubstring', 'complexity': 6, 'lineno': 3}], 'maintainability_index': 57.440846243445435, 'raw_metrics': {'loc': 16, 'lloc': 17, 'sloc': 16, 'comments': 0}}"
minimum-sum-of-mountain-triplets-i,"```python
from typing import List

class Solution:
    def minimumSum(self, nums: List[int]) -> int:
        min_sum = float('inf')
        n = len(nums)
        for i in range(n):
            for j in range(i + 1, n):
                for k in range(j + 1, n):
                    if nums[i] < nums[j] and nums[k] < nums[j]:
                        current_sum = nums[i] + nums[j] + nums[k]
                        if current_sum < min_sum:
                            min_sum = current_sum
        return min_sum if min_sum != float('inf') else -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 3}, {'name': 'minimumSum', 'complexity': 8, 'lineno': 4}], 'maintainability_index': 59.047998056541864, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
the-number-of-beautiful-subsets,"```python
from typing import List

class Solution:
    def beautifulSubsets(self, nums: List[int], k: int) -> int:
        from collections import defaultdict
        
        count = 0
        freq = defaultdict(int)
        
        def backtrack(index):
            nonlocal count
            if index == len(nums):
                if freq:
                    count += 1
                return
            
            backtrack(index + 1)
            
            num = nums[index]
            if freq[num - k] == 0 and freq[num + k] == 0:
                freq[num] += 1
                backtrack(index + 1)
                freq[num] -= 1
                if freq[num] == 0:
                    del freq[num]
        
        backtrack(0)
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 3}, {'name': 'beautifulSubsets', 'complexity': 1, 'lineno': 4}], 'maintainability_index': 54.786915415194514, 'raw_metrics': {'loc': 23, 'lloc': 23, 'sloc': 23, 'comments': 0}}"
difference-of-number-of-distinct-values-on-diagonals,"```python
from typing import List

class Solution:
    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:
        m = len(grid)
        n = len(grid[0]) if m > 0 else 0
        answer = [[0 for _ in range(n)] for _ in range(m)]
        
        for r in range(m):
            for c in range(n):
                left_above = set()
                i, j = r - 1, c - 1
                while i >= 0 and j >= 0:
                    left_above.add(grid[i][j])
                    i -= 1
                    j -= 1
                
                right_below = set()
                i, j = r + 1, c + 1
                while i < m and j < n:
                    right_below.add(grid[i][j])
                    i += 1
                    j += 1
                
                answer[r][c] = abs(len(left_above) - len(right_below))
        
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 3}, {'name': 'differenceOfDistinctValues', 'complexity': 10, 'lineno': 4}], 'maintainability_index': 52.59269006801424, 'raw_metrics': {'loc': 23, 'lloc': 23, 'sloc': 23, 'comments': 0}}"
defuse-the-bomb,"```python
from typing import List

class Solution:
    def decrypt(self, code: List[int], k: int) -> List[int]:
        n = len(code)
        result = []
        if k == 0:
            return [0] * n
        for i in range(n):
            total = 0
            if k > 0:
                for j in range(1, k + 1):
                    total += code[(i + j) % n]
            else:
                for j in range(1, -k + 1):
                    total += code[(i - j) % n]
            result.append(total)
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'decrypt', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 56.41340302538875, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
count-subarrays-with-score-less-than-k,"```python
class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        left = 0
        current_sum = 0
        result = 0
        
        for right in range(len(nums)):
            current_sum += nums[right]
            
            while current_sum * (right - left + 1) >= k and left <= right:
                current_sum -= nums[left]
                left += 1
            
            result += right - left + 1
        
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'countSubarrays', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 59.6305647143478, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
merge-similar-items,"```python
from typing import List

class Solution:
    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:
        weight_map = {}
        
        for value, weight in items1:
            weight_map[value] = weight_map.get(value, 0) + weight
        
        for value, weight in items2:
            weight_map[value] = weight_map.get(value, 0) + weight
        
        return sorted(weight_map.items())
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'mergeSimilarItems', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 70.09158299099349, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
distribute-repeating-integers,"```python
from collections import Counter
from typing import List

class Solution:
    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:
        freq = list(Counter(nums).values())
        quantity.sort(reverse=True)
        
        def backtrack(index: int) -> bool:
            if index == len(quantity):
                return True
            for i in range(len(freq)):
                if freq[i] >= quantity[index]:
                    freq[i] -= quantity[index]
                    if backtrack(index + 1):
                        return True
                    freq[i] += quantity[index]
            return False
        
        return backtrack(0)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 4}, {'name': 'canDistribute', 'complexity': 1, 'lineno': 5}], 'maintainability_index': 60.13460109276947, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
number-of-changing-keys,"```python
class Solution:
    def countKeyChanges(self, s: str) -> int:
        if not s:
            return 0
        count = 0
        prev = s[0].lower()
        for c in s[1:]:
            current = c.lower()
            if current != prev:
                count += 1
                prev = current
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 1}, {'name': 'countKeyChanges', 'complexity': 4, 'lineno': 2}], 'maintainability_index': 66.12200722551172, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
semi-ordered-permutation,"```python
from typing import List

class Solution:
    def semiOrderedPermutation(self, nums: List[int]) -> int:
        n = len(nums)
        pos1 = nums.index(1)
        posn = nums.index(n)
        if pos1 < posn:
            return pos1 + (n - 1 - posn)
        else:
            return pos1 + (n - 1 - posn) - 1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 3}, {'name': 'semiOrderedPermutation', 'complexity': 2, 'lineno': 4}], 'maintainability_index': 63.33282280136416, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
substrings-of-size-three-with-distinct-characters,"```python
class Solution:
    def countGoodSubstrings(self, s: str) -> int:
        count = 0
        for i in range(len(s) - 2):
            substring = s[i:i+3]
            if len(set(substring)) == 3:
                count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'countGoodSubstrings', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 67.43895401517055, 'raw_metrics': {'loc': 8, 'lloc': 9, 'sloc': 8, 'comments': 0}}"
stone-game-viii,"```python
class Solution:
    def stoneGameVIII(self, stones: List[int]) -> int:
        n = len(stones)
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i+1] = prefix[i] + stones[i]
        
        dp = [0] * n
        dp[-1] = prefix[n]
        
        for i in range(n-2, 0, -1):
            dp[i] = max(dp[i+1], prefix[i+1] - dp[i+1])
        
        return dp[1]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'stoneGameVIII', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 61.053321704712545, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
maximum-number-of-darts-inside-of-a-circular-dartboard,"```python
import math

class Solution:
    def numPoints(self, darts: List[List[int]], r: int) -> int:
        max_points = 1
        n = len(darts)
        for i in range(n):
            for j in range(i + 1, n):
                x1, y1 = darts[i]
                x2, y2 = darts[j]
                dx, dy = x2 - x1, y2 - y1
                d_squared = dx**2 + dy**2
                if d_squared > (2 * r) ** 2 + 1e-8:
                    continue
                d = math.sqrt(d_squared)
                mid_x, mid_y = (x1 + x2) / 2, (y1 + y2) / 2
                if d_squared == 0:
                    h = 0
                else:
                    h = math.sqrt(r**2 - d_squared / 4)
                for sign in (-1, 1):
                    cx = mid_x - sign * h * dy / d
                    cy = mid_y + sign * h * dx / d
                    count = 0
                    for (x, y) in darts:
                        if (x - cx)**2 + (y - cy)**2 <= r**2 + 1e-8:
                            count += 1
                    if count > max_points:
                        max_points = count
        return max_points
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 3}, {'name': 'numPoints', 'complexity': 9, 'lineno': 4}], 'maintainability_index': 46.78985582048728, 'raw_metrics': {'loc': 30, 'lloc': 30, 'sloc': 30, 'comments': 0}}"
maximum-height-of-a-triangle,"```python
class Solution:
    def maxHeightOfTriangle(self, red: int, blue: int) -> int:
        max_height = 0
        r, b = red, blue
        height = 0
        turn = 0  # 0 for red, 1 for blue
        while True:
            needed = height + 1
            if turn == 0:
                if r >= needed:
                    r -= needed
                    height += 1
                    turn = 1
                else:
                    break
            else:
                if b >= needed:
                    b -= needed
                    height += 1
                    turn = 0
                else:
                    break
        max_height = max(max_height, height)
        
        r, b = red, blue
        height = 0
        turn = 1  # 0 for red, 1 for blue
        while True:
            needed = height + 1
            if turn == 0:
                if r >= needed:
                    r -= needed
                    height += 1
                    turn = 1
                else:
                    break
            else:
                if b >= needed:
                    b -= needed
                    height += 1
                    turn = 0
                else:
                    break
        max_height = max(max_height, height)
        
        return max_height
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 1}, {'name': 'maxHeightOfTriangle', 'complexity': 9, 'lineno': 2}], 'maintainability_index': 59.759701654024, 'raw_metrics': {'loc': 44, 'lloc': 44, 'sloc': 44, 'comments': 2}}"
minimum-number-of-operations-to-sort-a-binary-tree-by-level,"```python
from collections import deque

class Solution:
    def minimumOperations(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        
        queue = deque([root])
        operations = 0
        
        while queue:
            level_size = len(queue)
            current_level = []
            for _ in range(level_size):
                node = queue.popleft()
                current_level.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            sorted_level = sorted(current_level)
            value_to_index = {val: idx for idx, val in enumerate(current_level)}
            
            for i in range(len(current_level)):
                if current_level[i] != sorted_level[i]:
                    correct_val = sorted_level[i]
                    current_val = current_level[i]
                    
                    swap_idx = value_to_index[correct_val]
                    current_level[i], current_level[swap_idx] = current_level[swap_idx], current_level[i]
                    
                    value_to_index[current_val] = swap_idx
                    value_to_index[correct_val] = i
                    
                    operations += 1
        
        return operations
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 3}, {'name': 'minimumOperations', 'complexity': 9, 'lineno': 4}], 'maintainability_index': 56.45820314007678, 'raw_metrics': {'loc': 30, 'lloc': 31, 'sloc': 30, 'comments': 0}}"
maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k,"```python
class Solution:
    def findMaximumNumber(self, k: int, x: int) -> int:
        left = 1
        right = 1 << 60
        
        def calculate_accumulated_price(num):
            total = 0
            for i in range(x, 60, x):
                divisor = 1 << i
                full_cycles = num // divisor
                remainder = num % divisor
                count = full_cycles * (1 << (i - 1))
                count += max(0, remainder - (1 << (i - 1)) + 1)
                total += count
            return total
        
        best = 0
        while left <= right:
            mid = (left + right) // 2
            price = calculate_accumulated_price(mid)
            if price <= k:
                best = mid
                left = mid + 1
            else:
                right = mid - 1
        return best
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'findMaximumNumber', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 52.22241576429881, 'raw_metrics': {'loc': 24, 'lloc': 24, 'sloc': 24, 'comments': 0}}"
maximum-sum-of-distinct-subarrays-with-length-k,"```python
from typing import List
from collections import defaultdict

class Solution:
    def maximumSubarraySum(self, nums: List[int], k: int) -> int:
        max_sum = 0
        current_sum = 0
        freq = defaultdict(int)
        left = 0
        
        for right in range(len(nums)):
            freq[nums[right]] += 1
            current_sum += nums[right]
            
            if right - left + 1 == k:
                if len(freq) == k:
                    max_sum = max(max_sum, current_sum)
                
                freq[nums[left]] -= 1
                if freq[nums[left]] == 0:
                    del freq[nums[left]]
                current_sum -= nums[left]
                left += 1
        
        return max_sum
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 4}, {'name': 'maximumSubarraySum', 'complexity': 5, 'lineno': 5}], 'maintainability_index': 55.72590819203733, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
count-of-substrings-containing-every-vowel-and-k-consonants-i,"```python
class Solution:
    def countOfSubstrings(self, word: str, k: int) -> int:
        vowels = {'a', 'e', 'i', 'o', 'u'}
        n = len(word)
        count = 0
        
        for i in range(n):
            vowel_set = set()
            consonant_count = 0
            for j in range(i, n):
                char = word[j]
                if char in vowels:
                    vowel_set.add(char)
                else:
                    consonant_count += 1
                
                if consonant_count == k and len(vowel_set) == 5:
                    count += 1
                elif consonant_count > k:
                    break
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 1}, {'name': 'countOfSubstrings', 'complexity': 7, 'lineno': 2}], 'maintainability_index': 57.62708446255554, 'raw_metrics': {'loc': 19, 'lloc': 19, 'sloc': 19, 'comments': 0}}"
difference-between-ones-and-zeros-in-row-and-column,"```python
from typing import List

class Solution:
    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:
        m = len(grid)
        n = len(grid[0]) if m > 0 else 0
        
        onesRow = [0] * m
        zerosRow = [0] * m
        for i in range(m):
            onesRow[i] = sum(grid[i])
            zerosRow[i] = n - onesRow[i]
        
        onesCol = [0] * n
        zerosCol = [0] * n
        for j in range(n):
            col_sum = sum(grid[i][j] for i in range(m))
            onesCol[j] = col_sum
            zerosCol[j] = m - col_sum
        
        diff = [[0] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                diff[i][j] = onesRow[i] + onesCol[j] - zerosRow[i] - zerosCol[j]
        
        return diff
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 3}, {'name': 'onesMinusZeros', 'complexity': 8, 'lineno': 4}], 'maintainability_index': 54.42223655382877, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
split-strings-by-separator,"```python
class Solution:
    def splitWordsBySeparator(self, words: List[str], separator: str) -> List[str]:
        result = []
        for word in words:
            parts = word.split(separator)
            for part in parts:
                if part:
                    result.append(part)
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'splitWordsBySeparator', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 100.0, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
sort-the-students-by-their-kth-score,"```python
class Solution:
    def sortTheStudents(self, score: List[List[int]], k: int) -> List[List[int]]:
        return sorted(score, key=lambda x: -x[k])
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 2}, {'name': 'sortTheStudents', 'complexity': 1, 'lineno': 3}], 'maintainability_index': 82.37587162552974, 'raw_metrics': {'loc': 4, 'lloc': 5, 'sloc': 4, 'comments': 0}}"
find-the-sum-of-the-power-of-all-subsequences,"```python
class Solution:
    def sumOfPower(self, nums: List[int], k: int) -> int:
        MOD = 10**9 + 7
        n = len(nums)
        dp = [[0] * (k + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        
        for num in nums:
            for i in range(n, -1, -1):
                for j in range(k, -1, -1):
                    if dp[i][j]:
                        if i + 1 <= n and j + num <= k:
                            dp[i + 1][j + num] = (dp[i + 1][j + num] + dp[i][j]) % MOD
        
        total = 0
        for i in range(1, n + 1):
            if dp[i][k] != 0:
                total = (total + dp[i][k] * pow(2, (n - i), MOD)) % MOD
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 2}, {'name': 'sumOfPower', 'complexity': 10, 'lineno': 3}], 'maintainability_index': 53.05378742187968, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
find-the-number-of-winning-players,"```python
from typing import List

class Solution:
    def winningPlayerCount(self, n: int, pick: List[List[int]]) -> int:
        color_counts = {}
        for player, color in pick:
            if player not in color_counts:
                color_counts[player] = {}
            if color not in color_counts[player]:
                color_counts[player][color] = 0
            color_counts[player][color] += 1
        
        winners = 0
        for player in range(n):
            max_count = max(color_counts.get(player, {}).values(), default=0)
            if max_count > player:
                winners += 1
        return winners
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'winningPlayerCount', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 60.208386200192955, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
design-an-ordered-stream,"```python
class OrderedStream:

    def __init__(self, n: int):
        self.stream = [None] * (n + 2)  # 1-based indexing, extra space to avoid index issues
        self.ptr = 1

    def insert(self, idKey: int, value: str) -> List[str]:
        self.stream[idKey] = value
        result = []
        while self.ptr < len(self.stream) and self.stream[self.ptr] is not None:
            result.append(self.stream[self.ptr])
            self.ptr += 1
        return result


```","{'cyclomatic_complexity': [{'name': 'OrderedStream', 'complexity': 3, 'lineno': 2}, {'name': '__init__', 'complexity': 1, 'lineno': 3}, {'name': 'insert', 'complexity': 3, 'lineno': 6}], 'maintainability_index': 79.24672147388088, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 1}}"
choose-k-elements-with-maximum-sum,"```python
import bisect
import heapq

class Solution:
    def findMaxSum(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:
        n = len(nums1)
        indices = sorted(range(n), key=lambda i: nums1[i])
        sorted_nums1 = [nums1[i] for i in indices]
        sorted_nums2 = [nums2[i] for i in indices]
        
        prefix_heap = []
        prefix_sums = []
        current_sum = 0
        res = [0] * n
        
        for i in range(n):
            num = sorted_nums2[i]
            if len(prefix_heap) < k:
                heapq.heappush(prefix_heap, num)
                current_sum += num
            else:
                if prefix_heap[0] < num:
                    popped = heapq.heappop(prefix_heap)
                    current_sum -= popped
                    heapq.heappush(prefix_heap, num)
                    current_sum += num
            prefix_sums.append(current_sum)
        
        original_indices = [0] * n
        for pos, idx in enumerate(indices):
            original_indices[idx] = pos
        
        for i in range(n):
            target = nums1[i]
            pos = bisect.bisect_left(sorted_nums1, target)
            if pos == 0:
                res[i] = 0
            else:
                res[i] = prefix_sums[pos - 1] if k <= pos else prefix_sums[pos - 1]
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 4}, {'name': 'findMaxSum', 'complexity': 10, 'lineno': 5}], 'maintainability_index': 49.33697113072777, 'raw_metrics': {'loc': 36, 'lloc': 37, 'sloc': 36, 'comments': 0}}"
most-frequent-prime,"```python
import math
from typing import List
from collections import defaultdict

class Solution:
    def mostFrequentPrime(self, mat: List[List[int]]) -> int:
        def is_prime(num):
            if num < 2:
                return False
            for i in range(2, int(math.sqrt(num)) + 1):
                if num % i == 0:
                    return False
            return True
        
        directions = [
            (0, 1),   # east
            (1, 1),    # south-east
            (1, 0),    # south
            (1, -1),   # south-west
            (0, -1),   # west
            (-1, -1),  # north-west
            (-1, 0),   # north
            (-1, 1)    # north-east
        ]
        
        m = len(mat)
        n = len(mat[0]) if m > 0 else 0
        prime_counts = defaultdict(int)
        
        for i in range(m):
            for j in range(n):
                for di, dj in directions:
                    num = 0
                    ni, nj = i, j
                    while 0 <= ni < m and 0 <= nj < n:
                        num = num * 10 + mat[ni][nj]
                        if num > 10 and is_prime(num):
                            prime_counts[num] += 1
                        ni += di
                        nj += dj
        
        if not prime_counts:
            return -1
        
        max_freq = max(prime_counts.values())
        candidates = [num for num, freq in prime_counts.items() if freq == max_freq]
        return max(candidates)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 13, 'lineno': 5}, {'name': 'mostFrequentPrime', 'complexity': 12, 'lineno': 6}], 'maintainability_index': 70.25918220019535, 'raw_metrics': {'loc': 42, 'lloc': 33, 'sloc': 42, 'comments': 8}}"
longest-subarray-with-maximum-bitwise-and,"```python
from typing import List

class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        max_and = max(nums)
        max_length = 0
        current_length = 0
        
        for num in nums:
            if num == max_and:
                current_length += 1
                max_length = max(max_length, current_length)
            else:
                current_length = 0
        
        return max_length
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'longestSubarray', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 66.12375720067395, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
minimum-space-wasted-from-packaging,"```python
import bisect

class Solution:
    def minWastedSpace(self, packages: List[int], boxes: List[List[int]]) -> int:
        MOD = 10**9 + 7
        packages.sort()
        prefix = [0]
        for p in packages:
            prefix.append(prefix[-1] + p)
        
        min_waste = float('inf')
        
        for supplier_boxes in boxes:
            supplier_boxes.sort()
            if supplier_boxes[-1] < packages[-1]:
                continue  # cannot fit the largest package
            
            total = 0
            prev_idx = 0
            for box in supplier_boxes:
                idx = bisect.bisect_right(packages, box) - 1
                if idx < 0:
                    continue
                count = idx - prev_idx + 1
                total += box * count - (prefix[idx + 1] - prefix[prev_idx])
                prev_idx = idx + 1
                if prev_idx >= len(packages):
                    break
            
            if prev_idx >= len(packages):
                if total < min_waste:
                    min_waste = total
        
        return min_waste % MOD if min_waste != float('inf') else -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 3}, {'name': 'minWastedSpace', 'complexity': 10, 'lineno': 4}], 'maintainability_index': 59.9050743633768, 'raw_metrics': {'loc': 29, 'lloc': 29, 'sloc': 29, 'comments': 1}}"
maximize-happiness-of-selected-children,"```python
class Solution:
    def maximumHappinessSum(self, happiness: List[int], k: int) -> int:
        happiness.sort(reverse=True)
        total = 0
        for i in range(k):
            current = max(happiness[i] - i, 0)
            total += current
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 2}, {'name': 'maximumHappinessSum', 'complexity': 2, 'lineno': 3}], 'maintainability_index': 70.44404409360986, 'raw_metrics': {'loc': 9, 'lloc': 9, 'sloc': 9, 'comments': 0}}"
count-palindromic-subsequences,"```python
class Solution:
    def countPalindromes(self, s: str) -> int:
        MOD = 10**9 + 7
        n = len(s)
        if n < 5:
            return 0
        
        prefix = [[0] * 10 for _ in range(n+1)]
        for i in range(n):
            for d in range(10):
                prefix[i+1][d] = prefix[i][d]
            prefix[i+1][int(s[i])] += 1
        
        suffix = [[0] * 10 for _ in range(n+1)]
        for i in range(n-1, -1, -1):
            for d in range(10):
                suffix[i][d] = suffix[i+1][d]
            suffix[i][int(s[i])] += 1
        
        prefix_2 = [[[0] * 10 for _ in range(10)] for __ in range(n+1)]
        for i in range(n):
            current_d = int(s[i])
            for d1 in range(10):
                for d2 in range(10):
                    prefix_2[i+1][d1][d2] = prefix_2[i][d1][d2]
            for d in range(10):
                prefix_2[i+1][d][current_d] += prefix[i][d]
        
        suffix_2 = [[[0] * 10 for _ in range(10)] for __ in range(n+1)]
        for i in range(n-1, -1, -1):
            current_d = int(s[i])
            for d1 in range(10):
                for d2 in range(10):
                    suffix_2[i][d1][d2] = suffix_2[i+1][d1][d2]
            for d in range(10):
                suffix_2[i][current_d][d] += suffix[i+1][d]
        
        res = 0
        for i in range(2, n-2):
            for d1 in range(10):
                for d2 in range(10):
                    cnt_prefix = prefix_2[i][d1][d2]
                    cnt_suffix = suffix_2[i+1][d2][d1]
                    res = (res + cnt_prefix * cnt_suffix) % MOD
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 24, 'lineno': 1}, {'name': 'countPalindromes', 'complexity': 23, 'lineno': 2}], 'maintainability_index': 43.08240693706087, 'raw_metrics': {'loc': 40, 'lloc': 40, 'sloc': 40, 'comments': 0}}"
count-the-number-of-good-subarrays,"```python
from collections import defaultdict
from typing import List

class Solution:
    def countGood(self, nums: List[int], k: int) -> int:
        left = 0
        count = defaultdict(int)
        res = 0
        pairs = 0
        
        for right in range(len(nums)):
            num = nums[right]
            pairs += count[num]
            count[num] += 1
            
            while pairs >= k:
                res += len(nums) - right
                left_num = nums[left]
                count[left_num] -= 1
                pairs -= count[left_num]
                left += 1
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 4}, {'name': 'countGood', 'complexity': 3, 'lineno': 5}], 'maintainability_index': 57.2730993100843, 'raw_metrics': {'loc': 20, 'lloc': 20, 'sloc': 20, 'comments': 0}}"
minimum-operations-to-write-the-letter-y-on-a-grid,"```python
from typing import List

class Solution:
    def minimumOperationsToWriteY(self, grid: List[List[int]]) -> int:
        n = len(grid)
        center = n // 2
        y_cells = set()
        non_y_cells = set()
        
        for i in range(center + 1):
            y_cells.add((i, i))  # top-left to center diagonal
            y_cells.add((i, n - 1 - i))  # top-right to center diagonal
        for i in range(center, n):
            y_cells.add((i, center))  # vertical line from center to bottom
        
        for i in range(n):
            for j in range(n):
                if (i, j) not in y_cells:
                    non_y_cells.add((i, j))
        
        y_counts = [0, 0, 0]
        non_y_counts = [0, 0, 0]
        
        for (i, j) in y_cells:
            val = grid[i][j]
            y_counts[val] += 1
        
        for (i, j) in non_y_cells:
            val = grid[i][j]
            non_y_counts[val] += 1
        
        total_y = sum(y_counts)
        total_non_y = sum(non_y_counts)
        
        min_operations = float('inf')
        
        for y_val in range(3):
            for non_y_val in range(3):
                if y_val == non_y_val:
                    continue
                operations = (total_y - y_counts[y_val]) + (total_non_y - non_y_counts[non_y_val])
                if operations < min_operations:
                    min_operations = operations
        
        return min_operations
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 13, 'lineno': 3}, {'name': 'minimumOperationsToWriteY', 'complexity': 12, 'lineno': 4}], 'maintainability_index': 65.1642856512227, 'raw_metrics': {'loc': 36, 'lloc': 36, 'sloc': 36, 'comments': 3}}"
minimum-cost-for-cutting-cake-i,"```python
from typing import List

class Solution:
    def minimumCost(self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]) -> int:
        horizontalCut.sort(reverse=True)
        verticalCut.sort(reverse=True)
        h_pieces = 1
        v_pieces = 1
        total_cost = 0
        i = j = 0
        while i < len(horizontalCut) and j < len(verticalCut):
            if horizontalCut[i] > verticalCut[j]:
                total_cost += horizontalCut[i] * v_pieces
                h_pieces += 1
                i += 1
            else:
                total_cost += verticalCut[j] * h_pieces
                v_pieces += 1
                j += 1
        while i < len(horizontalCut):
            total_cost += horizontalCut[i] * v_pieces
            h_pieces += 1
            i += 1
        while j < len(verticalCut):
            total_cost += verticalCut[j] * h_pieces
            v_pieces += 1
            j += 1
        return total_cost
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'minimumCost', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 50.008410809893924, 'raw_metrics': {'loc': 28, 'lloc': 28, 'sloc': 28, 'comments': 0}}"
minimum-equal-sum-of-two-arrays-after-replacing-zeros,"```python
from typing import List

class Solution:
    def minSum(self, nums1: List[int], nums2: List[int]) -> int:
        sum1 = sum(nums1)
        sum2 = sum(nums2)
        zero1 = nums1.count(0)
        zero2 = nums2.count(0)
        
        min_sum1 = sum1 + zero1
        min_sum2 = sum2 + zero2
        
        if zero1 == 0 and zero2 == 0:
            return sum1 if sum1 == sum2 else -1
        elif zero1 == 0:
            if sum1 < min_sum2:
                return -1
            else:
                return sum1
        elif zero2 == 0:
            if sum2 < min_sum1:
                return -1
            else:
                return sum2
        else:
            return max(min_sum1, min_sum2)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 3}, {'name': 'minSum', 'complexity': 8, 'lineno': 4}], 'maintainability_index': 53.64033452515768, 'raw_metrics': {'loc': 24, 'lloc': 24, 'sloc': 24, 'comments': 0}}"
sum-of-imbalance-numbers-of-all-subarrays,"```python
class Solution:
    def sumImbalanceNumbers(self, nums: List[int]) -> int:
        n = len(nums)
        total = 0
        for i in range(n):
            seen = set()
            current_imbalance = 0
            for j in range(i, n):
                x = nums[j]
                if x not in seen:
                    seen.add(x)
                    left = x - 1 in seen
                    right = x + 1 in seen
                    if left and right:
                        current_imbalance -= 1
                    elif not left and not right and len(seen) > 1:
                        current_imbalance += 1
                total += current_imbalance
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 2}, {'name': 'sumImbalanceNumbers', 'complexity': 9, 'lineno': 3}], 'maintainability_index': 54.761661233289914, 'raw_metrics': {'loc': 20, 'lloc': 20, 'sloc': 20, 'comments': 0}}"
maximum-building-height,"```python
from typing import List

class Solution:
    def maxBuilding(self, n: int, restrictions: List[List[int]]) -> int:
        if not restrictions:
            return n - 1
        
        restrictions.append([1, 0])
        restrictions.sort()
        if restrictions[-1][0] != n:
            restrictions.append([n, float('inf')])
        
        for i in range(1, len(restrictions)):
            prev_id, prev_h = restrictions[i-1]
            curr_id, curr_h = restrictions[i]
            restrictions[i][1] = min(curr_h, prev_h + (curr_id - prev_id))
        
        for i in range(len(restrictions)-2, -1, -1):
            next_id, next_h = restrictions[i+1]
            curr_id, curr_h = restrictions[i]
            restrictions[i][1] = min(curr_h, next_h + (next_id - curr_id))
        
        max_height = 0
        for i in range(1, len(restrictions)):
            prev_id, prev_h = restrictions[i-1]
            curr_id, curr_h = restrictions[i]
            distance = curr_id - prev_id
            max_possible = max(prev_h, curr_h) + (distance - abs(prev_h - curr_h)) // 2
            max_height = max(max_height, max_possible)
        
        return max_height
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'maxBuilding', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 51.412576967454456, 'raw_metrics': {'loc': 26, 'lloc': 26, 'sloc': 26, 'comments': 0}}"
find-the-length-of-the-longest-common-prefix,"```python
class Solution:
    def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:
        max_len = 0
        prefixes = set()
        
        for num in arr1:
            s = str(num)
            for i in range(1, len(s)+1):
                prefixes.add(s[:i])
        
        for num in arr2:
            s = str(num)
            for i in range(1, len(s)+1):
                prefix = s[:i]
                if prefix in prefixes and i > max_len:
                    max_len = i
        
        return max_len
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 2}, {'name': 'longestCommonPrefix', 'complexity': 7, 'lineno': 3}], 'maintainability_index': 59.32758354890982, 'raw_metrics': {'loc': 16, 'lloc': 18, 'sloc': 16, 'comments': 0}}"
find-all-k-distant-indices-in-an-array,"```python
from typing import List

class Solution:
    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:
        key_indices = [i for i, num in enumerate(nums) if num == key]
        result = set()
        n = len(nums)
        for j in key_indices:
            start = max(0, j - k)
            end = min(n - 1, j + k)
            for i in range(start, end + 1):
                result.add(i)
        return sorted(result)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'findKDistantIndices', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 63.00767453864186, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
visit-array-positions-to-maximize-score,"```python
from typing import List

class Solution:
    def maxScore(self, nums: List[int], x: int) -> int:
        n = len(nums)
        dp_even = -float('inf')
        dp_odd = -float('inf')
        
        if nums[0] % 2 == 0:
            dp_even = nums[0]
        else:
            dp_odd = nums[0]
        
        for i in range(1, n):
            current_num = nums[i]
            if current_num % 2 == 0:
                current_max = max(dp_even + current_num, dp_odd + current_num - x)
                dp_even = max(dp_even, current_max)
            else:
                current_max = max(dp_odd + current_num, dp_even + current_num - x)
                dp_odd = max(dp_odd, current_max)
        
        return max(dp_even, dp_odd)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'maxScore', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 55.88128220960699, 'raw_metrics': {'loc': 20, 'lloc': 20, 'sloc': 20, 'comments': 0}}"
number-of-ways-to-earn-points,"```python
class Solution:
    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:
        MOD = 10**9 + 7
        dp = [0] * (target + 1)
        dp[0] = 1
        
        for count, mark in types:
            for t in range(target, -1, -1):
                for k in range(1, count + 1):
                    if t - k * mark >= 0:
                        dp[t] = (dp[t] + dp[t - k * mark]) % MOD
        
        return dp[target]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'waysToReachTarget', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 59.692771532360396, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
longest-alternating-subarray,"```python
from typing import List

class Solution:
    def alternatingSubarray(self, nums: List[int]) -> int:
        max_len = -1
        n = len(nums)
        for i in range(n - 1):
            if nums[i + 1] - nums[i] == 1:
                current_len = 2
                for j in range(i + 2, n):
                    expected_diff = 1 if (j - i) % 2 == 1 else -1
                    if nums[j] - nums[j - 1] == expected_diff:
                        current_len += 1
                    else:
                        break
                if current_len > max_len:
                    max_len = current_len
        return max_len if max_len != -1 else -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 3}, {'name': 'alternatingSubarray', 'complexity': 8, 'lineno': 4}], 'maintainability_index': 54.880112206735134, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
find-xor-beauty-of-array,"```python
from typing import List

class Solution:
    def xorBeauty(self, nums: List[int]) -> int:
        result = 0
        for num in nums:
            result ^= num
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 3}, {'name': 'xorBeauty', 'complexity': 2, 'lineno': 4}], 'maintainability_index': 75.15517382051522, 'raw_metrics': {'loc': 8, 'lloc': 8, 'sloc': 8, 'comments': 0}}"
find-the-pivot-integer,"```python
class Solution:
    def pivotInteger(self, n: int) -> int:
        total_sum = n * (n + 1) // 2
        for x in range(1, n + 1):
            left_sum = x * (x + 1) // 2
            right_sum = total_sum - left_sum + x
            if left_sum == right_sum:
                return x
        return -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'pivotInteger', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 63.76495046233994, 'raw_metrics': {'loc': 9, 'lloc': 9, 'sloc': 9, 'comments': 0}}"
sliding-subarray-beauty,"```python
from typing import List
from collections import defaultdict

class Solution:
    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:
        result = []
        freq = defaultdict(int)
        negatives = []
        
        for i in range(len(nums)):
            num = nums[i]
            if num < 0:
                freq[num] += 1
            
            if i >= k:
                left_num = nums[i - k]
                if left_num < 0:
                    freq[left_num] -= 1
                    if freq[left_num] == 0:
                        del freq[left_num]
            
            if i >= k - 1:
                sorted_negatives = sorted(freq.keys())
                count = 0
                beauty = 0
                for num in sorted_negatives:
                    count += freq[num]
                    if count >= x:
                        beauty = num
                        break
                if count < x:
                    beauty = 0
                result.append(beauty)
        
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 4}, {'name': 'getSubarrayBeauty', 'complexity': 10, 'lineno': 5}], 'maintainability_index': 50.74856078676928, 'raw_metrics': {'loc': 31, 'lloc': 31, 'sloc': 31, 'comments': 0}}"
minimum-time-to-visit-disappearing-nodes,"```python
import heapq
from typing import List

class Solution:
    def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:
        graph = [[] for _ in range(n)]
        for u, v, length in edges:
            graph[u].append((v, length))
            graph[v].append((u, length))
        
        answer = [-1] * n
        heap = []
        heapq.heappush(heap, (0, 0))
        
        while heap:
            current_time, node = heapq.heappop(heap)
            if answer[node] != -1:
                continue
            if current_time >= disappear[node]:
                continue
            answer[node] = current_time
            
            for neighbor, length in graph[node]:
                if answer[neighbor] == -1:
                    new_time = current_time + length
                    if new_time < disappear[neighbor]:
                        heapq.heappush(heap, (new_time, neighbor))
        
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 4}, {'name': 'minimumTime', 'complexity': 9, 'lineno': 5}], 'maintainability_index': 54.09759612560605, 'raw_metrics': {'loc': 25, 'lloc': 25, 'sloc': 25, 'comments': 0}}"
insert-greatest-common-divisors-in-linked-list,"```python
class Solution:
    def insertGreatestCommonDivisors(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        
        def gcd(a, b):
            while b:
                a, b = b, a % b
            return a
        
        current = head
        while current and current.next:
            a = current.val
            b = current.next.val
            gcd_val = gcd(a, b)
            new_node = ListNode(gcd_val, current.next)
            current.next = new_node
            current = new_node.next
        return head
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'insertGreatestCommonDivisors', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 60.23654882166918, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
minimum-seconds-to-equalize-a-circular-array,"```python
from collections import defaultdict

class Solution:
    def minimumSeconds(self, nums: List[int]) -> int:
        value_indices = defaultdict(list)
        for i, num in enumerate(nums):
            value_indices[num].append(i)
        
        n = len(nums)
        min_time = float('inf')
        
        for indices in value_indices.values():
            max_gap = 0
            m = len(indices)
            for i in range(m):
                prev = indices[i-1] if i > 0 else indices[-1] - n
                gap = indices[i] - prev - 1
                max_gap = max(max_gap, gap)
            current_time = (max_gap + 1) // 2
            min_time = min(min_time, current_time)
        
        return min_time
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'minimumSeconds', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 57.547829202835466, 'raw_metrics': {'loc': 19, 'lloc': 19, 'sloc': 19, 'comments': 0}}"
the-score-of-students-solving-math-expression,"```python
from typing import List

class Solution:
    def scoreOfStudents(self, s: str, answers: List[int]) -> int:
        def compute_correct(s):
            stack = []
            num = 0
            op = '+'
            for i, c in enumerate(s):
                if c.isdigit():
                    num = num * 10 + int(c)
                if not c.isdigit() or i == len(s) - 1:
                    if op == '+':
                        stack.append(num)
                    elif op == '*':
                        stack.append(stack.pop() * num)
                    op = c
                    num = 0
            return sum(stack)
        
        correct = compute_correct(s)
        
        n = len(s)
        dp = [[set() for _ in range(n)] for __ in range(n)]
        
        for i in range(n):
            if s[i].isdigit():
                dp[i][i].add(int(s[i]))
        
        for length in range(2, n + 1):
            for i in range(n - length + 1):
                j = i + length - 1
                if s[j].isdigit() or s[j] in {'+', '*'}:
                    for k in range(i, j):
                        if s[k] in {'+', '*'}:
                            left = dp[i][k - 1]
                            right = dp[k + 1][j]
                            for a in left:
                                for b in right:
                                    res = a + b if s[k] == '+' else a * b
                                    if res <= 1000:
                                        dp[i][j].add(res)
        
        possible_wrong = dp[0][n - 1]
        
        total = 0
        for ans in answers:
            if ans == correct:
                total += 5
            elif ans in possible_wrong:
                total += 2
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 19, 'lineno': 3}, {'name': 'scoreOfStudents', 'complexity': 18, 'lineno': 4}], 'maintainability_index': 42.505049170538484, 'raw_metrics': {'loc': 46, 'lloc': 46, 'sloc': 46, 'comments': 0}}"
maximum-score-of-a-good-subarray,"```python
class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
        left = right = k
        min_val = nums[k]
        max_score = min_val
        
        while left > 0 or right < len(nums) - 1:
            if left == 0:
                right += 1
            elif right == len(nums) - 1:
                left -= 1
            elif nums[left - 1] > nums[right + 1]:
                left -= 1
            else:
                right += 1
            min_val = min(min_val, nums[left], nums[right])
            max_score = max(max_score, min_val * (right - left + 1))
        
        return max_score
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 2}, {'name': 'maximumScore', 'complexity': 6, 'lineno': 3}], 'maintainability_index': 55.17331776466075, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
minimum-operations-to-make-the-integer-zero,"```python
class Solution:
    def makeTheIntegerZero(self, num1: int, num2: int) -> int:
        for k in range(1, 61):
            target = num1 - k * num2
            if target < 0:
                continue
            bits = bin(target).count('1')
            if bits <= k and target >= k:
                return k
        return -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 1}, {'name': 'makeTheIntegerZero', 'complexity': 5, 'lineno': 2}], 'maintainability_index': 63.98778161120596, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
maximum-palindromes-after-operations,"```python
from collections import defaultdict

class Solution:
    def maxPalindromesAfterOperations(self, words: List[str]) -> int:
        char_counts = defaultdict(int)
        word_lengths = []
        
        for word in words:
            word_lengths.append(len(word))
            for c in word:
                char_counts[c] += 1
        
        total_pairs = 0
        for count in char_counts.values():
            total_pairs += count // 2
        
        word_lengths.sort()
        max_palindromes = 0
        
        for length in word_lengths:
            required_pairs = length // 2
            if total_pairs >= required_pairs:
                total_pairs -= required_pairs
                max_palindromes += 1
            else:
                break
        
        return max_palindromes
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'maxPalindromesAfterOperations', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 56.116683285421715, 'raw_metrics': {'loc': 23, 'lloc': 23, 'sloc': 23, 'comments': 0}}"
maximum-tastiness-of-candy-basket,"```python
class Solution:
    def maximumTastiness(self, price: List[int], k: int) -> int:
        price.sort()
        left, right = 0, price[-1] - price[0]
        answer = 0
        
        def is_possible(mid):
            count = 1
            last = price[0]
            for i in range(1, len(price)):
                if price[i] - last >= mid:
                    count += 1
                    last = price[i]
                    if count >= k:
                        return True
            return count >= k
        
        while left <= right:
            mid = (left + right) // 2
            if is_possible(mid):
                answer = mid
                left = mid + 1
            else:
                right = mid - 1
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'maximumTastiness', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 54.04237529883144, 'raw_metrics': {'loc': 24, 'lloc': 24, 'sloc': 24, 'comments': 0}}"
sorting-three-groups,"```python
from typing import List

class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [[0] * 4 for _ in range(n)]
        
        for j in range(1, 4):
            dp[0][j] = 0 if nums[0] == j else 1
        
        for i in range(1, n):
            for j in range(1, 4):
                min_prev = float('inf')
                for k in range(1, j + 1):
                    if dp[i-1][k] < min_prev:
                        min_prev = dp[i-1][k]
                dp[i][j] = min_prev + (0 if nums[i] == j else 1)
        
        return min(dp[-1][1], dp[-1][2], dp[-1][3])
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 3}, {'name': 'minimumOperations', 'complexity': 9, 'lineno': 4}], 'maintainability_index': 57.82988633757246, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
the-two-sneaky-numbers-of-digitville,"```python
from typing import List

class Solution:
    def getSneakyNumbers(self, nums: List[int]) -> List[int]:
        count = {}
        result = []
        for num in nums:
            if num in count:
                count[num] += 1
            else:
                count[num] = 1
        for num, freq in count.items():
            if freq == 2:
                result.append(num)
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'getSneakyNumbers', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 63.34779983067407, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
find-the-maximum-number-of-marked-indices,"```python
class Solution:
    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:
        nums.sort()
        n = len(nums)
        left = 0
        right = n // 2
        marked = 0
        
        while left < n // 2 and right < n:
            if 2 * nums[left] <= nums[right]:
                marked += 2
                left += 1
                right += 1
            else:
                right += 1
        
        return marked
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'maxNumOfMarkedIndices', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 58.0860546889453, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
count-equal-and-divisible-pairs-in-an-array,"```python
from typing import List

class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        count = 0
        n = len(nums)
        for i in range(n):
            for j in range(i + 1, n):
                if nums[i] == nums[j] and (i * j) % k == 0:
                    count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'countPairs', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 62.93647531500063, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
high-access-employees,"```python
from typing import List

class Solution:
    def findHighAccessEmployees(self, access_times: List[List[str]]) -> List[str]:
        from collections import defaultdict

        employee_times = defaultdict(list)
        
        for name, time in access_times:
            hours = int(time[:2])
            minutes = int(time[2:])
            total_minutes = hours * 60 + minutes
            employee_times[name].append(total_minutes)
        
        high_access = []
        
        for name in employee_times:
            times = sorted(employee_times[name])
            n = len(times)
            found = False
            for i in range(n - 2):
                if times[i+2] - times[i] < 60:
                    found = True
                    break
            if found:
                high_access.append(name)
        
        return high_access
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'findHighAccessEmployees', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 55.70889944234394, 'raw_metrics': {'loc': 23, 'lloc': 25, 'sloc': 23, 'comments': 0}}"
find-the-largest-area-of-square-inside-two-rectangles,"```python
from typing import List

class Solution:
    def largestSquareArea(self, bottomLeft: List[List[int]], topRight: List[List[int]]) -> int:
        max_area = 0
        n = len(bottomLeft)
        
        for i in range(n):
            for j in range(i + 1, n):
                x1 = max(bottomLeft[i][0], bottomLeft[j][0])
                y1 = max(bottomLeft[i][1], bottomLeft[j][1])
                x2 = min(topRight[i][0], topRight[j][0])
                y2 = min(topRight[i][1], topRight[j][1])
                
                if x1 < x2 and y1 < y2:
                    side = min(x2 - x1, y2 - y1)
                    max_area = max(max_area, side * side)
        
        return max_area
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'largestSquareArea', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 59.60262314262386, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
minimum-number-of-operations-to-make-x-and-y-equal,"```python
from collections import deque

class Solution:
    def minimumOperationsToMakeEqual(self, x: int, y: int) -> int:
        if x == y:
            return 0
        
        visited = set()
        queue = deque()
        queue.append((x, 0))
        visited.add(x)
        
        while queue:
            current, steps = queue.popleft()
            
            if current == y:
                return steps
            
            next_steps = steps + 1
            candidates = []
            
            if current % 11 == 0:
                candidates.append(current // 11)
            if current % 5 == 0:
                candidates.append(current // 5)
            candidates.append(current - 1)
            candidates.append(current + 1)
            
            for num in candidates:
                if num == y:
                    return next_steps
                if num > 0 and num not in visited:
                    if num <= 10000 + 100:  # Adding a buffer to handle possible +1 operations
                        visited.add(num)
                        queue.append((num, next_steps))
        
        return -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 2}, {'name': 'minimumOperationsToMakeEqual', 'complexity': 11, 'lineno': 3}], 'maintainability_index': 60.64569343196557, 'raw_metrics': {'loc': 29, 'lloc': 29, 'sloc': 29, 'comments': 1}}"
count-the-number-of-ideal-arrays,"```python
import math

class Solution:
    def idealArrays(self, n: int, maxValue: int) -> int:
        MOD = 10**9 + 7
        
        divisors = [[] for _ in range(maxValue + 1)]
        for i in range(1, maxValue + 1):
            for j in range(2 * i, maxValue + 1, i):
                divisors[j].append(i)
        
        max_k = 20  # Since maxValue can be 1e4, log2(1e4) ~ 13.29
        comb = [[0] * (max_k + 1) for _ in range(n + 1)]
        comb[0][0] = 1
        for i in range(1, n + 1):
            comb[i][0] = 1
            for j in range(1, max_k + 1):
                comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD
        
        dp_k = [{} for _ in range(maxValue + 1)]
        for v in range(1, maxValue + 1):
            dp_k[v][1] = 1
        
        for v in range(1, maxValue + 1):
            for u in divisors[v]:
                for k in dp_k[u]:
                    new_k = k + 1
                    if new_k in dp_k[v]:
                        dp_k[v][new_k] = (dp_k[v][new_k] + dp_k[u][k]) % MOD
                    else:
                        dp_k[v][new_k] = dp_k[u][k] % MOD
        
        res = 0
        for v in range(1, maxValue + 1):
            for k in dp_k[v]:
                res = (res + dp_k[v][k] * comb[n-1][k-1]) % MOD
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 16, 'lineno': 2}, {'name': 'idealArrays', 'complexity': 15, 'lineno': 3}], 'maintainability_index': 57.29229435915383, 'raw_metrics': {'loc': 31, 'lloc': 31, 'sloc': 31, 'comments': 1}}"
find-missing-and-repeated-values,"```python
from typing import List

class Solution:
    def findMissingAndRepeatedValues(self, grid: List[List[int]]) -> List[int]:
        n = len(grid)
        total_numbers = n * n
        count = [0] * (total_numbers + 1)
        
        for row in grid:
            for num in row:
                count[num] += 1
        
        a, b = 0, 0
        for num in range(1, total_numbers + 1):
            if count[num] == 2:
                a = num
            if count[num] == 0:
                b = num
        
        return [a, b]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'findMissingAndRepeatedValues', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 58.980396808428445, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
meeting-rooms-iii,"```python
import heapq

class Solution:
    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:
        meetings.sort()
        available = list(range(n))
        used = []
        count = [0] * n
        
        for start, end in meetings:
            while used and used[0][0] <= start:
                time, room = heapq.heappop(used)
                heapq.heappush(available, room)
            
            if available:
                room = heapq.heappop(available)
                heapq.heappush(used, (end, room))
            else:
                time, room = heapq.heappop(used)
                new_end = time + (end - start)
                heapq.heappush(used, (new_end, room))
            
            count[room] += 1
        
        max_count = max(count)
        return count.index(max_count)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'mostBooked', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 56.90435581094257, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
find-the-substring-with-maximum-cost,"```python
from typing import List

class Solution:
    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:
        char_to_val = {}
        for c, v in zip(chars, vals):
            char_to_val[c] = v
        
        max_cost = current_cost = 0
        for c in s:
            if c in char_to_val:
                val = char_to_val[c]
            else:
                val = ord(c) - ord('a') + 1
            current_cost = max(val, current_cost + val)
            max_cost = max(max_cost, current_cost)
        return max_cost
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'maximumCostSubstring', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 61.73029575590064, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
cycle-length-queries-in-a-tree,"```python
from typing import List

class Solution:
    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        res = []
        for a, b in queries:
            path_a = []
            path_b = []
            while a != b:
                if a > b:
                    path_a.append(a)
                    a = a // 2
                else:
                    path_b.append(b)
                    b = b // 2
            cycle_length = len(path_a) + len(path_b) + 1
            res.append(cycle_length)
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'cycleLengthQueries', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 59.38146315952879, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
find-the-punishment-number-of-an-integer,"```python
class Solution:
    def punishmentNumber(self, n: int) -> int:
        def can_partition(s, target):
            if not s and target == 0:
                return True
            if target < 0:
                return False
            for i in range(1, len(s)+1):
                num = int(s[:i])
                if can_partition(s[i:], target - num):
                    return True
            return False
        
        total = 0
        for i in range(1, n+1):
            square = i * i
            if can_partition(str(square), i):
                total += square
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'punishmentNumber', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 57.20861877828631, 'raw_metrics': {'loc': 18, 'lloc': 19, 'sloc': 18, 'comments': 0}}"
subarray-with-elements-greater-than-varying-threshold,"```python
class Solution:
    def validSubarraySize(self, nums: List[int], threshold: int) -> int:
        n = len(nums)
        left = [-1] * n
        right = [n] * n
        stack = []
        
        for i in range(n):
            while stack and nums[stack[-1]] >= nums[i]:
                stack.pop()
            if stack:
                left[i] = stack[-1]
            stack.append(i)
        
        stack = []
        for i in range(n-1, -1, -1):
            while stack and nums[stack[-1]] >= nums[i]:
                stack.pop()
            if stack:
                right[i] = stack[-1]
            stack.append(i)
        
        for i in range(n):
            k = right[i] - left[i] - 1
            if nums[i] > threshold / k:
                return k
        
        return -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 2}, {'name': 'validSubarraySize', 'complexity': 11, 'lineno': 3}], 'maintainability_index': 51.38708279843424, 'raw_metrics': {'loc': 25, 'lloc': 25, 'sloc': 25, 'comments': 0}}"
find-score-of-an-array-after-marking-all-elements,"```python
import heapq

class Solution:
    def findScore(self, nums: List[int]) -> int:
        n = len(nums)
        marked = [False] * n
        heap = []
        for i in range(n):
            heapq.heappush(heap, (nums[i], i))
        
        score = 0
        while heap:
            num, i = heapq.heappop(heap)
            if not marked[i]:
                score += num
                marked[i] = True
                if i > 0:
                    marked[i-1] = True
                if i < n - 1:
                    marked[i+1] = True
        return score
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'findScore', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 56.999011587849026, 'raw_metrics': {'loc': 20, 'lloc': 20, 'sloc': 20, 'comments': 0}}"
permutation-difference-between-two-strings,"```python
class Solution:
    def findPermutationDifference(self, s: str, t: str) -> int:
        s_indices = {char: idx for idx, char in enumerate(s)}
        t_indices = {char: idx for idx, char in enumerate(t)}
        total = 0
        for char in s:
            total += abs(s_indices[char] - t_indices[char])
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 1}, {'name': 'findPermutationDifference', 'complexity': 4, 'lineno': 2}], 'maintainability_index': 69.17688599205619, 'raw_metrics': {'loc': 8, 'lloc': 10, 'sloc': 8, 'comments': 0}}"
make-lexicographically-smallest-array-by-swapping-elements,"```python
from typing import List

class Solution:
    def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:
        n = len(nums)
        indices = list(range(n))
        indices.sort(key=lambda i: nums[i])
        sorted_nums = [nums[i] for i in indices]
        
        groups = []
        current_group = [indices[0]]
        
        for i in range(1, n):
            if sorted_nums[i] - sorted_nums[i-1] <= limit:
                current_group.append(indices[i])
            else:
                groups.append(current_group)
                current_group = [indices[i]]
        groups.append(current_group)
        
        for group in groups:
            group.sort()
        
        res = [0] * n
        for group in groups:
            sorted_values = sorted([nums[i] for i in group])
            for idx, val in zip(sorted(group), sorted_values):
                res[idx] = val
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 3}, {'name': 'lexicographicallySmallestArray', 'complexity': 8, 'lineno': 4}], 'maintainability_index': 56.592736331536, 'raw_metrics': {'loc': 25, 'lloc': 26, 'sloc': 25, 'comments': 0}}"
minimum-moves-to-spread-stones-over-grid,"```python
from itertools import permutations

class Solution:
    def minimumMoves(self, grid: List[List[int]]) -> int:
        sources = []
        targets = []
        for i in range(3):
            for j in range(3):
                if grid[i][j] > 1:
                    for _ in range(grid[i][j] - 1):
                        sources.append((i, j))
                elif grid[i][j] == 0:
                    targets.append((i, j))
        
        min_moves = float('inf')
        for target_perm in permutations(targets):
            total = 0
            for (s_i, s_j), (t_i, t_j) in zip(sources, target_perm):
                total += abs(s_i - t_i) + abs(s_j - t_j)
            if total < min_moves:
                min_moves = total
        return min_moves
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 3}, {'name': 'minimumMoves', 'complexity': 9, 'lineno': 4}], 'maintainability_index': 55.74936505645132, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
minimum-number-of-operations-to-make-word-k-periodic,"```python
class Solution:
    def minimumOperationsToMakeKPeriodic(self, word: str, k: int) -> int:
        n = len(word)
        segments = [word[i:i+k] for i in range(0, n, k)]
        freq = {}
        max_freq = 0
        for seg in segments:
            freq[seg] = freq.get(seg, 0) + 1
            if freq[seg] > max_freq:
                max_freq = freq[seg]
        return len(segments) - max_freq
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 1}, {'name': 'minimumOperationsToMakeKPeriodic', 'complexity': 4, 'lineno': 2}], 'maintainability_index': 64.579041983756, 'raw_metrics': {'loc': 11, 'lloc': 12, 'sloc': 11, 'comments': 0}}"
longest-unequal-adjacent-groups-subsequence-ii,"```python
from typing import List

class Solution:
    def getWordsInLongestSubsequence(self, words: List[str], groups: List[int]) -> List[str]:
        n = len(words)
        dp = [1] * n
        prev = [-1] * n
        
        for i in range(n):
            for j in range(i):
                if groups[i] != groups[j] and len(words[i]) == len(words[j]):
                    hamming = sum(1 for a, b in zip(words[i], words[j]) if a != b)
                    if hamming == 1 and dp[j] + 1 > dp[i]:
                        dp[i] = dp[j] + 1
                        prev[i] = j
        
        max_len = max(dp)
        if max_len == 1:
            return [words[0]]
        
        idx = dp.index(max_len)
        res = []
        while idx != -1:
            res.append(words[idx])
            idx = prev[idx]
        
        return res[::-1]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 3}, {'name': 'getWordsInLongestSubsequence', 'complexity': 11, 'lineno': 4}], 'maintainability_index': 51.89569814349967, 'raw_metrics': {'loc': 23, 'lloc': 24, 'sloc': 23, 'comments': 0}}"
valid-arrangement-of-pairs,"```python
from collections import defaultdict, deque

class Solution:
    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:
        graph = defaultdict(list)
        in_degree = defaultdict(int)
        out_degree = defaultdict(int)
        
        for u, v in pairs:
            graph[u].append(v)
            out_degree[u] += 1
            in_degree[v] += 1
        
        start = pairs[0][0]
        for u in out_degree:
            if out_degree[u] - in_degree[u] == 1:
                start = u
                break
        
        stack = []
        path = []
        stack.append(start)
        
        while stack:
            current = stack[-1]
            if graph[current]:
                next_node = graph[current].pop()
                stack.append(next_node)
            else:
                path.append(stack.pop())
        
        path.reverse()
        result = []
        for i in range(len(path) - 1):
            result.append([path[i], path[i+1]])
        
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'validArrangement', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 53.39912853352955, 'raw_metrics': {'loc': 31, 'lloc': 31, 'sloc': 31, 'comments': 0}}"
check-if-every-row-and-column-contains-all-numbers,"```python
from typing import List

class Solution:
    def checkValid(self, matrix: List[List[int]]) -> bool:
        n = len(matrix)
        for i in range(n):
            row_set = set()
            col_set = set()
            for j in range(n):
                row_val = matrix[i][j]
                col_val = matrix[j][i]
                if row_val < 1 or row_val > n or col_val < 1 or col_val > n:
                    return False
                row_set.add(row_val)
                col_set.add(col_val)
            if len(row_set) != n or len(col_set) != n:
                return False
        return True
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 3}, {'name': 'checkValid', 'complexity': 9, 'lineno': 4}], 'maintainability_index': 57.14920751260058, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
maximum-number-of-integers-to-choose-from-a-range-i,"```python
from typing import List

class Solution:
    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:
        banned_set = set(banned)
        total = 0
        count = 0
        for num in range(1, n + 1):
            if num not in banned_set:
                if total + num <= maxSum:
                    total += num
                    count += 1
                else:
                    break
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'maxCount', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 61.10872001336626, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
shortest-impossible-sequence-of-rolls,"```python
from typing import List

class Solution:
    def shortestSequence(self, rolls: List[int], k: int) -> int:
        res = 1
        seen = set()
        for num in rolls:
            seen.add(num)
            if len(seen) == k:
                res += 1
                seen = set()
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'shortestSequence', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 67.58413206219534, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
count-substrings-that-satisfy-k-constraint-i,"```python
class Solution:
    def countKConstraintSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        count = 0
        for i in range(n):
            zeros = 0
            ones = 0
            for j in range(i, n):
                if s[j] == '0':
                    zeros += 1
                else:
                    ones += 1
                if zeros <= k or ones <= k:
                    count += 1
                else:
                    break
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 1}, {'name': 'countKConstraintSubstrings', 'complexity': 6, 'lineno': 2}], 'maintainability_index': 58.980396808428445, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
count-pairs-of-connectable-servers-in-a-weighted-tree-network,"```python
from typing import List

class Solution:
    def countPairsOfConnectableServers(self, edges: List[List[int]], signalSpeed: int) -> List[int]:
        n = len(edges) + 1
        graph = [[] for _ in range(n)]
        for a, b, w in edges:
            graph[a].append((b, w))
            graph[b].append((a, w))
        
        res = [0] * n
        
        for c in range(n):
            counts = []
            visited = [False] * n
            visited[c] = True
            
            for neighbor, w in graph[c]:
                stack = [(neighbor, w)]
                visited[neighbor] = True
                cnt = 0
                
                while stack:
                    node, dist = stack.pop()
                    if dist % signalSpeed == 0:
                        cnt += 1
                    for child, child_w in graph[node]:
                        if not visited[child]:
                            visited[child] = True
                            stack.append((child, dist + child_w))
                
                counts.append(cnt)
            
            total = 0
            for i in range(len(counts)):
                for j in range(i + 1, len(counts)):
                    total += counts[i] * counts[j]
            res[c] = total
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 3}, {'name': 'countPairsOfConnectableServers', 'complexity': 11, 'lineno': 4}], 'maintainability_index': 50.17581283937936, 'raw_metrics': {'loc': 33, 'lloc': 33, 'sloc': 33, 'comments': 0}}"
minimum-changes-to-make-alternating-binary-string,"```python
class Solution:
    def minOperations(self, s: str) -> int:
        count1 = 0  # starts with '0'
        count2 = 0  # starts with '1'
        
        for i in range(len(s)):
            current_char = s[i]
            if i % 2 == 0:
                if current_char != '0':
                    count1 += 1
                if current_char != '1':
                    count2 += 1
            else:
                if current_char != '1':
                    count1 += 1
                if current_char != '0':
                    count2 += 1
        
        return min(count1, count2)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 1}, {'name': 'minOperations', 'complexity': 7, 'lineno': 2}], 'maintainability_index': 76.7500168584277, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 2}}"
maximum-difference-between-adjacent-elements-in-a-circular-array,"```python
from typing import List

class Solution:
    def maxAdjacentDistance(self, nums: List[int]) -> int:
        max_diff = 0
        n = len(nums)
        for i in range(n):
            diff = abs(nums[i] - nums[(i + 1) % n])
            if diff > max_diff:
                max_diff = diff
        return max_diff
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'maxAdjacentDistance', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 65.30613586505524, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
find-special-substring-of-length-k,"```python
class Solution:
    def hasSpecialSubstring(self, s: str, k: int) -> bool:
        n = len(s)
        for i in range(n - k + 1):
            substring = s[i:i+k]
            if len(set(substring)) == 1:
                left_ok = (i == 0) or (s[i-1] != substring[0])
                right_ok = (i + k == n) or (s[i+k] != substring[0])
                if left_ok and right_ok:
                    return True
        return False
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 1}, {'name': 'hasSpecialSubstring', 'complexity': 7, 'lineno': 2}], 'maintainability_index': 59.3860609579077, 'raw_metrics': {'loc': 11, 'lloc': 12, 'sloc': 11, 'comments': 0}}"
find-the-maximum-factor-score-of-array,"```python
import math
from typing import List

class Solution:
    def maxScore(self, nums: List[int]) -> int:
        if not nums:
            return 0
        max_score = 0
        n = len(nums)
        for i in range(-1, n):
            current_nums = nums[:i] + nums[i+1:] if i != -1 else nums
            if not current_nums:
                continue
            current_gcd = current_nums[0]
            current_lcm = current_nums[0]
            for num in current_nums[1:]:
                current_gcd = math.gcd(current_gcd, num)
                current_lcm = (current_lcm * num) // math.gcd(current_lcm, num)
            score = current_gcd * current_lcm
            if score > max_score:
                max_score = score
        return max_score
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 4}, {'name': 'maxScore', 'complexity': 7, 'lineno': 5}], 'maintainability_index': 54.4794146891237, 'raw_metrics': {'loc': 22, 'lloc': 23, 'sloc': 22, 'comments': 0}}"
minimum-deletions-to-make-array-divisible,"```python
import math
from typing import List

class Solution:
    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:
        overall_gcd = numsDivide[0]
        for num in numsDivide[1:]:
            overall_gcd = math.gcd(overall_gcd, num)
            if overall_gcd == 1:
                break
        
        nums.sort()
        for i, num in enumerate(nums):
            if overall_gcd % num == 0:
                return i
        return -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 4}, {'name': 'minOperations', 'complexity': 5, 'lineno': 5}], 'maintainability_index': 62.905115451765205, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
check-balanced-string,"```python
class Solution:
    def isBalanced(self, num: str) -> bool:
        even_sum = 0
        odd_sum = 0
        for i, c in enumerate(num):
            digit = int(c)
            if i % 2 == 0:
                even_sum += digit
            else:
                odd_sum += digit
        return even_sum == odd_sum
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'isBalanced', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 64.85929803077245, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
determine-the-minimum-sum-of-a-k-avoiding-array,"```python
class Solution:
    def minimumSum(self, n: int, k: int) -> int:
        used = set()
        num = 1
        total = 0
        count = 0
        
        while count < n:
            if (k - num) not in used:
                used.add(num)
                total += num
                count += 1
            num += 1
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'minimumSum', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 62.49052490967176, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
minimum-levels-to-gain-more-points,"```python
from typing import List

class Solution:
    def minimumLevels(self, possible: List[int]) -> int:
        n = len(possible)
        total = sum(1 if x == 1 else -1 for x in possible)
        alice_sum = 0
        for i in range(n - 1):
            alice_sum += 1 if possible[i] == 1 else -1
            bob_sum = total - alice_sum
            if alice_sum > bob_sum:
                return i + 1
        return -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'minimumLevels', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 60.670998980253586, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
maximum-subsequence-score,"```python
import heapq
from typing import List

class Solution:
    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:
        pairs = sorted(zip(nums2, nums1), reverse=True)
        min_heap = []
        total = 0
        res = 0
        
        for num2, num1 in pairs:
            heapq.heappush(min_heap, num1)
            total += num1
            if len(min_heap) > k:
                val = heapq.heappop(min_heap)
                total -= val
            if len(min_heap) == k:
                res = max(res, total * num2)
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 4}, {'name': 'maxScore', 'complexity': 4, 'lineno': 5}], 'maintainability_index': 59.82750105486918, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
find-champion-ii,"```python
from typing import List

class Solution:
    def findChampion(self, n: int, edges: List[List[int]]) -> int:
        in_degree = [0] * n
        for u, v in edges:
            in_degree[v] += 1
        
        champions = []
        for team in range(n):
            if in_degree[team] == 0:
                champions.append(team)
        
        if len(champions) == 1:
            return champions[0]
        else:
            return -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'findChampion', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 61.738448099366686, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
maximum-odd-binary-number,"```python
class Solution:
    def maximumOddBinaryNumber(self, s: str) -> str:
        count_ones = s.count('1')
        count_zeros = len(s) - count_ones
        if count_ones == 1:
            return '0' * count_zeros + '1'
        else:
            return '1' * (count_ones - 1) + '0' * count_zeros + '1'
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 1}, {'name': 'maximumOddBinaryNumber', 'complexity': 2, 'lineno': 2}], 'maintainability_index': 65.73008063812414, 'raw_metrics': {'loc': 8, 'lloc': 8, 'sloc': 8, 'comments': 0}}"
find-the-first-player-to-win-k-games-in-a-row,"```python
from collections import deque

class Solution:
    def findWinningPlayer(self, skills: List[int], k: int) -> int:
        n = len(skills)
        if k >= n - 1:
            return skills.index(max(skills))
        
        queue = deque(range(n))
        current_winner = queue.popleft()
        consecutive_wins = 0
        
        while True:
            next_player = queue.popleft()
            if skills[current_winner] > skills[next_player]:
                consecutive_wins += 1
            else:
                queue.append(current_winner)
                current_winner = next_player
                consecutive_wins = 1
            
            if consecutive_wins == k:
                return current_winner
            
            queue.append(next_player)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'findWinningPlayer', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 58.232623269371175, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
cat-and-mouse-ii,"```python
from typing import List
from functools import lru_cache

class Solution:
    def canMouseWin(self, grid: List[str], catJump: int, mouseJump: int) -> bool:
        rows = len(grid)
        cols = len(grid[0]) if rows > 0 else 0
        
        cat_pos = None
        mouse_pos = None
        food_pos = None
        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == 'C':
                    cat_pos = (i, j)
                elif grid[i][j] == 'M':
                    mouse_pos = (i, j)
                elif grid[i][j] == 'F':
                    food_pos = (i, j)
        
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        @lru_cache(maxsize=None)
        def dfs(turn, cat, mouse):
            if turn > 100:
                return False
            if cat == mouse:
                return False
            if cat == food_pos:
                return False
            if mouse == food_pos:
                return True
            
            if turn % 2 == 0:  # Mouse's turn
                i, j = mouse
                for di, dj in directions:
                    for step in range(1, mouseJump + 1):
                        ni, nj = i + di * step, j + dj * step
                        if 0 <= ni < rows and 0 <= nj < cols and grid[ni][nj] != '#':
                            if dfs(turn + 1, cat, (ni, nj)):
                                return True
                        else:
                            break
                if dfs(turn + 1, cat, mouse):
                    return True
                return False
            else:  # Cat's turn
                i, j = cat
                for di, dj in directions:
                    for step in range(1, catJump + 1):
                        ni, nj = i + di * step, j + dj * step
                        if 0 <= ni < rows and 0 <= nj < cols and grid[ni][nj] != '#':
                            if not dfs(turn + 1, (ni, nj), mouse):
                                return False
                        else:
                            break
                if not dfs(turn + 1, cat, mouse):
                    return False
                return True
        
        return dfs(0, cat_pos, mouse_pos)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 4}, {'name': 'canMouseWin', 'complexity': 7, 'lineno': 5}], 'maintainability_index': 52.210346913806596, 'raw_metrics': {'loc': 56, 'lloc': 56, 'sloc': 56, 'comments': 2}}"
special-array-ii,"```python
from typing import List

class Solution:
    def isArraySpecial(self, nums: List[int], queries: List[List[int]]) -> List[bool]:
        n = len(nums)
        prefix = [0] * n
        for i in range(1, n):
            prefix[i] = prefix[i-1] + (1 if (nums[i] % 2) == (nums[i-1] % 2) else 0)
        
        answer = []
        for query in queries:
            fromi, toi = query
            if fromi == toi:
                answer.append(True)
            else:
                answer.append(prefix[toi] - prefix[fromi] == 0)
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'isArraySpecial', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 58.03726635130211, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
snake-in-matrix,"```python
class Solution:
    def finalPositionOfSnake(self, n: int, commands: List[str]) -> int:
        x, y = 0, 0
        for cmd in commands:
            if cmd == ""UP"":
                x -= 1
            elif cmd == ""DOWN"":
                x += 1
            elif cmd == ""LEFT"":
                y -= 1
            elif cmd == ""RIGHT"":
                y += 1
        return x * n + y
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 2}, {'name': 'finalPositionOfSnake', 'complexity': 6, 'lineno': 3}], 'maintainability_index': 59.64852890404834, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
count-paths-that-can-form-a-palindrome-in-a-tree,"```python
from collections import defaultdict
from typing import List

class Solution:
    def countPalindromePaths(self, parent: List[int], s: str) -> int:
        n = len(parent)
        children = [[] for _ in range(n)]
        for i in range(1, n):
            children[parent[i]].append(i)
        
        mask_count = defaultdict(int)
        mask_count[0] = 1
        result = 0
        
        stack = [(0, 0)]
        while stack:
            node, mask = stack.pop()
            for child in children[node]:
                edge_char = s[child]
                new_mask = mask ^ (1 << (ord(edge_char) - ord('a')))
                result += mask_count[new_mask]
                for i in range(26):
                    result += mask_count[new_mask ^ (1 << i)]
                mask_count[new_mask] += 1
                stack.append((child, new_mask))
        
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 4}, {'name': 'countPalindromePaths', 'complexity': 6, 'lineno': 5}], 'maintainability_index': 55.00493620742716, 'raw_metrics': {'loc': 24, 'lloc': 24, 'sloc': 24, 'comments': 0}}"
check-if-strings-can-be-made-equal-with-operations-ii,"```python
class Solution:
    def checkStrings(self, s1: str, s2: str) -> bool:
        if len(s1) != len(s2):
            return False
        n = len(s1)
        even_s1 = []
        odd_s1 = []
        even_s2 = []
        odd_s2 = []
        for i in range(n):
            if i % 2 == 0:
                even_s1.append(s1[i])
                even_s2.append(s2[i])
            else:
                odd_s1.append(s1[i])
                odd_s2.append(s2[i])
        return sorted(even_s1) == sorted(even_s2) and sorted(odd_s1) == sorted(odd_s2)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 1}, {'name': 'checkStrings', 'complexity': 5, 'lineno': 2}], 'maintainability_index': 59.34694737275195, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
find-number-of-ways-to-reach-the-k-th-stair,"```python
class Solution:
    def waysToReachStair(self, k: int) -> int:
        from functools import lru_cache
        
        @lru_cache(maxsize=None)
        def dfs(pos, jump, can_down):
            if pos == k:
                res = 1
            else:
                res = 0
            
            if can_down and pos - 1 >= 0:
                res += dfs(pos - 1, jump, False)
            
            new_pos = pos + (1 << jump)
            if new_pos <= k + 1:  # To prevent infinite recursion, limit the upper bound
                res += dfs(new_pos, jump + 1, True)
            
            return res
        
        return dfs(1, 0, True)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 1}, {'name': 'waysToReachStair', 'complexity': 1, 'lineno': 2}], 'maintainability_index': 72.54534357609545, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 1}}"
minimum-number-of-increments-on-subarrays-to-form-a-target-array,"```python
class Solution:
    def minNumberOperations(self, target: List[int]) -> int:
        operations = target[0]
        for i in range(1, len(target)):
            if target[i] > target[i-1]:
                operations += target[i] - target[i-1]
        return operations
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'minNumberOperations', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 67.75289099463588, 'raw_metrics': {'loc': 8, 'lloc': 8, 'sloc': 8, 'comments': 0}}"
find-the-original-array-of-prefix-xor,"```python
from typing import List

class Solution:
    def findArray(self, pref: List[int]) -> List[int]:
        arr = [pref[0]]
        for i in range(1, len(pref)):
            arr.append(pref[i] ^ pref[i-1])
        return arr
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 3}, {'name': 'findArray', 'complexity': 2, 'lineno': 4}], 'maintainability_index': 71.55988337877561, 'raw_metrics': {'loc': 8, 'lloc': 8, 'sloc': 8, 'comments': 0}}"
minimize-string-length,"```python
class Solution:
    def minimizedStringLength(self, s: str) -> int:
        return len(set(s))
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 1}, {'name': 'minimizedStringLength', 'complexity': 1, 'lineno': 2}], 'maintainability_index': 100.0, 'raw_metrics': {'loc': 3, 'lloc': 3, 'sloc': 3, 'comments': 0}}"
minimize-maximum-of-array,"```python
class Solution:
    def minimizeArrayValue(self, nums: List[int]) -> int:
        total = 0
        res = 0
        for i in range(len(nums)):
            total += nums[i]
            res = max(res, (total + i) // (i + 1))
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 2}, {'name': 'minimizeArrayValue', 'complexity': 2, 'lineno': 3}], 'maintainability_index': 67.88342886969677, 'raw_metrics': {'loc': 9, 'lloc': 9, 'sloc': 9, 'comments': 0}}"
minimize-the-maximum-difference-of-pairs,"```python
class Solution:
    def minimizeMax(self, nums: List[int], p: int) -> int:
        if p == 0:
            return 0
        
        nums.sort()
        left, right = 0, nums[-1] - nums[0]
        answer = right
        
        def is_possible(mid):
            count = 0
            i = 0
            while i < len(nums) - 1:
                if nums[i+1] - nums[i] <= mid:
                    count += 1
                    i += 2
                else:
                    i += 1
                if count >= p:
                    return True
            return count >= p
        
        while left <= right:
            mid = (left + right) // 2
            if is_possible(mid):
                answer = mid
                right = mid - 1
            else:
                left = mid + 1
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'minimizeMax', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 50.87925719796344, 'raw_metrics': {'loc': 28, 'lloc': 28, 'sloc': 28, 'comments': 0}}"
count-vowel-substrings-of-a-string,"```python
class Solution:
    def countVowelSubstrings(self, word: str) -> int:
        vowels = {'a', 'e', 'i', 'o', 'u'}
        count = 0
        n = len(word)
        for i in range(n):
            if word[i] in vowels:
                seen = set()
                for j in range(i, n):
                    if word[j] not in vowels:
                        break
                    seen.add(word[j])
                    if len(seen) == 5:
                        count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 1}, {'name': 'countVowelSubstrings', 'complexity': 6, 'lineno': 2}], 'maintainability_index': 62.07270747661916, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
minimum-time-to-visit-a-cell-in-a-grid,"```python
import heapq
from typing import List

class Solution:
    def minimumTime(self, grid: List[List[int]]) -> int:
        if grid[0][1] > 1 and grid[1][0] > 1:
            return -1
        
        m, n = len(grid), len(grid[0])
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        heap = []
        heapq.heappush(heap, (0, 0, 0))  # (time, row, col)
        visited = [[False for _ in range(n)] for _ in range(m)]
        
        while heap:
            time, row, col = heapq.heappop(heap)
            if row == m - 1 and col == n - 1:
                return time
            if visited[row][col]:
                continue
            visited[row][col] = True
            for dr, dc in directions:
                nr, nc = row + dr, col + dc
                if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc]:
                    if grid[nr][nc] <= time + 1:
                        heapq.heappush(heap, (time + 1, nr, nc))
                    else:
                        diff = grid[nr][nc] - time
                        wait_time = diff + (1 if diff % 2 == 0 else 0)
                        heapq.heappush(heap, (time + wait_time, nr, nc))
        return -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 16, 'lineno': 4}, {'name': 'minimumTime', 'complexity': 15, 'lineno': 5}], 'maintainability_index': 58.56972538304771, 'raw_metrics': {'loc': 29, 'lloc': 29, 'sloc': 29, 'comments': 1}}"
find-the-n-th-value-after-k-seconds,"```python
class Solution:
    def valueAfterKSeconds(self, n: int, k: int) -> int:
        MOD = 10**9 + 7
        dp = [1] * n
        for _ in range(k):
            for i in range(1, n):
                dp[i] = (dp[i] + dp[i-1]) % MOD
        return dp[-1]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'valueAfterKSeconds', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 66.31004054989037, 'raw_metrics': {'loc': 8, 'lloc': 8, 'sloc': 8, 'comments': 0}}"
find-all-good-indices,"```python
from typing import List

class Solution:
    def goodIndices(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        non_inc = [1] * n
        non_dec = [1] * n
        
        for i in range(1, n):
            if nums[i] <= nums[i-1]:
                non_inc[i] = non_inc[i-1] + 1
        
        for i in range(n-2, -1, -1):
            if nums[i] <= nums[i+1]:
                non_dec[i] = non_dec[i+1] + 1
        
        res = []
        for i in range(k, n - k):
            if non_inc[i-1] >= k and non_dec[i+1] >= k:
                res.append(i)
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 3}, {'name': 'goodIndices', 'complexity': 8, 'lineno': 4}], 'maintainability_index': 54.590280081014384, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
maximum-energy-boost-from-two-drinks,"```python
from typing import List

class Solution:
    def maxEnergyBoost(self, energyDrinkA: List[int], energyDrinkB: List[int]) -> int:
        n = len(energyDrinkA)
        if n == 0:
            return 0
        
        dpA = [0] * n
        dpB = [0] * n
        
        dpA[0] = energyDrinkA[0]
        dpB[0] = energyDrinkB[0]
        
        for i in range(1, n):
            dpA[i] = max(dpA[i-1] + energyDrinkA[i], (dpB[i-2] + energyDrinkA[i] if i >= 2 else energyDrinkA[i]))
            dpB[i] = max(dpB[i-1] + energyDrinkB[i], (dpA[i-2] + energyDrinkB[i] if i >= 2 else energyDrinkB[i]))
        
        return max(dpA[-1], dpB[-1])
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'maxEnergyBoost', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 57.600052557263794, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
collecting-chocolates,"```python
class Solution:
    def minCost(self, nums: List[int], x: int) -> int:
        n = len(nums)
        res = float('inf')
        min_costs = nums.copy()
        
        for rotate in range(n):
            current_cost = sum(min_costs) + rotate * x
            if current_cost < res:
                res = current_cost
            new_min_costs = [0] * n
            for i in range(n):
                new_min_costs[i] = min(min_costs[i], min_costs[(i + 1) % n])
            min_costs = new_min_costs
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'minCost', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 60.73882817000716, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
sum-of-number-and-its-reverse,"```python
class Solution:
    def sumOfNumberAndReverse(self, num: int) -> bool:
        for i in range(num + 1):
            reversed_i = int(str(i)[::-1])
            if i + reversed_i == num:
                return True
        return False
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'sumOfNumberAndReverse', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 69.1293612310883, 'raw_metrics': {'loc': 7, 'lloc': 8, 'sloc': 7, 'comments': 0}}"
painting-a-grid-with-three-different-colors,"```python
class Solution:
    def colorTheGrid(self, m: int, n: int) -> int:
        MOD = 10**9 + 7
        
        def get_valid_states(m):
            from itertools import product
            colors = [0, 1, 2]
            states = []
            for state in product(colors, repeat=m):
                valid = True
                for i in range(m - 1):
                    if state[i] == state[i + 1]:
                        valid = False
                        break
                if valid:
                    states.append(state)
            return states
        
        states = get_valid_states(m)
        if not states:
            return 0
        
        state_to_idx = {state: idx for idx, state in enumerate(states)}
        k = len(states)
        
        transition = [[0] * k for _ in range(k)]
        for i in range(k):
            for j in range(k):
                valid = True
                for x in range(m):
                    if states[i][x] == states[j][x]:
                        valid = False
                        break
                if valid:
                    transition[i][j] = 1
        
        dp = [1] * k
        
        for _ in range(1, n):
            new_dp = [0] * k
            for i in range(k):
                for j in range(k):
                    if transition[i][j]:
                        new_dp[j] = (new_dp[j] + dp[i]) % MOD
            dp = new_dp
        
        return sum(dp) % MOD
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 14, 'lineno': 1}, {'name': 'colorTheGrid', 'complexity': 13, 'lineno': 2}], 'maintainability_index': 47.09936841032752, 'raw_metrics': {'loc': 40, 'lloc': 41, 'sloc': 40, 'comments': 0}}"
maximum-number-of-robots-within-budget,"```python
from collections import deque

class Solution:
    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:
        n = len(chargeTimes)
        left = 0
        current_sum = 0
        max_deque = deque()
        max_k = 0
        
        for right in range(n):
            current_sum += runningCosts[right]
            
            while max_deque and chargeTimes[right] >= chargeTimes[max_deque[-1]]:
                max_deque.pop()
            max_deque.append(right)
            
            while left <= right and (chargeTimes[max_deque[0]] + (right - left + 1) * current_sum) > budget:
                current_sum -= runningCosts[left]
                if max_deque[0] == left:
                    max_deque.popleft()
                left += 1
            
            max_k = max(max_k, right - left + 1)
        
        return max_k
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'maximumRobots', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 53.56650865720178, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
apply-operations-on-array-to-maximize-sum-of-squares,"```python
class Solution:
    def maxSum(self, nums: List[int], k: int) -> int:
        MOD = 10**9 + 7
        bits = [0] * 30
        
        for num in nums:
            for i in range(30):
                if num & (1 << i):
                    bits[i] += 1
        
        res = 0
        for _ in range(k):
            current = 0
            for i in range(30):
                if bits[i] > 0:
                    current += (1 << i)
                    bits[i] -= 1
            res = (res + current * current) % MOD
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 2}, {'name': 'maxSum', 'complexity': 7, 'lineno': 3}], 'maintainability_index': 55.626135938628664, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
find-the-k-th-character-in-string-game-i,"```python
class Solution:
    def kthCharacter(self, k: int) -> str:
        word = ""a""
        while len(word) < k:
            next_part = []
            for c in word:
                if c == 'z':
                    next_part.append('a')
                else:
                    next_part.append(chr(ord(c) + 1))
            word += ''.join(next_part)
        return word[k-1]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 1}, {'name': 'kthCharacter', 'complexity': 4, 'lineno': 2}], 'maintainability_index': 63.668749447472834, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
merge-bsts-to-create-single-bst,"```python
class Solution:
    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:
        if not trees:
            return None
        
        leaves = set()
        root_dict = {}
        
        for tree in trees:
            root_dict[tree.val] = tree
            if tree.left:
                leaves.add(tree.left.val)
            if tree.right:
                leaves.add(tree.right.val)
        
        candidates = []
        for tree in trees:
            if tree.val not in leaves:
                candidates.append(tree)
        
        if len(candidates) != 1:
            return None
        
        root = candidates[0]
        del root_dict[root.val]
        stack = [(root, float('-inf'), float('inf'))]
        count = 1
        
        while stack:
            node, lower, upper = stack.pop()
            if not node:
                continue
            if node.val <= lower or node.val >= upper:
                return None
            if node.left:
                if node.left.val in root_dict:
                    left_node = root_dict[node.left.val]
                    node.left = left_node
                    del root_dict[left_node.val]
                    count += 1
                stack.append((node.left, lower, node.val))
            if node.right:
                if node.right.val in root_dict:
                    right_node = root_dict[node.right.val]
                    node.right = right_node
                    del root_dict[right_node.val]
                    count += 1
                stack.append((node.right, node.val, upper))
        
        return root if len(root_dict) == 0 and count == len(trees) else None
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 19, 'lineno': 2}, {'name': 'canMerge', 'complexity': 18, 'lineno': 3}], 'maintainability_index': 45.63523682890412, 'raw_metrics': {'loc': 44, 'lloc': 44, 'sloc': 44, 'comments': 0}}"
process-restricted-friend-requests,"```python
class Solution:
    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:
        parent = list(range(n))
        
        def find(u):
            while parent[u] != u:
                parent[u] = parent[parent[u]]
                u = parent[u]
            return u
        
        def union(u, v):
            u_root = find(u)
            v_root = find(v)
            if u_root != v_root:
                parent[v_root] = u_root
        
        res = []
        for u, v in requests:
            u_root = find(u)
            v_root = find(v)
            if u_root == v_root:
                res.append(True)
                continue
            
            valid = True
            for x, y in restrictions:
                x_root = find(x)
                y_root = find(y)
                if (x_root == u_root and y_root == v_root) or (x_root == v_root and y_root == u_root):
                    valid = False
                    break
            if valid:
                union(u, v)
                res.append(True)
            else:
                res.append(False)
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 2}, {'name': 'friendRequests', 'complexity': 9, 'lineno': 3}], 'maintainability_index': 50.56237617226994, 'raw_metrics': {'loc': 34, 'lloc': 34, 'sloc': 34, 'comments': 0}}"
find-the-longest-equal-subarray,"```python
from collections import defaultdict
from typing import List

class Solution:
    def longestEqualSubarray(self, nums: List[int], k: int) -> int:
        pos_dict = defaultdict(list)
        for idx, num in enumerate(nums):
            pos_dict[num].append(idx)
        
        max_len = 0
        for num in pos_dict:
            indices = pos_dict[num]
            left = 0
            for right in range(len(indices)):
                while (indices[right] - indices[left] + 1) - (right - left + 1) > k:
                    left += 1
                max_len = max(max_len, right - left + 1)
        return max_len
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 4}, {'name': 'longestEqualSubarray', 'complexity': 5, 'lineno': 5}], 'maintainability_index': 58.18557584368123, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
intersection-of-multiple-arrays,"```python
from typing import List

class Solution:
    def intersection(self, nums: List[List[int]]) -> List[int]:
        if not nums:
            return []
        common = set(nums[0])
        for arr in nums[1:]:
            common.intersection_update(arr)
        return sorted(common)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'intersection', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 75.54020827753493, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
find-xor-sum-of-all-pairs-bitwise-and,"```python
from typing import List

class Solution:
    def getXORSum(self, arr1: List[int], arr2: List[int]) -> int:
        xor1 = 0
        for num in arr1:
            xor1 ^= num
        
        xor2 = 0
        for num in arr2:
            xor2 ^= num
        
        return xor1 & xor2
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'getXORSum', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 67.50178924900142, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
beautiful-towers-i,"```python
from typing import List

class Solution:
    def maximumSumOfHeights(self, heights: List[int]) -> int:
        n = len(heights)
        max_sum = 0
        
        for peak in range(n):
            current_sum = 0
            left = peak
            current_height = heights[peak]
            
            for i in range(peak, -1, -1):
                if heights[i] < current_height:
                    current_height = heights[i]
                current_sum += current_height
            
            current_height = heights[peak]
            for i in range(peak + 1, n):
                if heights[i] < current_height:
                    current_height = heights[i]
                current_sum += current_height
            
            if current_sum > max_sum:
                max_sum = current_sum
        
        return max_sum
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'maximumSumOfHeights', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 56.46663691222468, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
put-marbles-in-bags,"```python
class Solution:
    def putMarbles(self, weights: List[int], k: int) -> int:
        if k == 1 or k == len(weights):
            return 0
        
        n = len(weights)
        splits = []
        for i in range(n - 1):
            splits.append(weights[i] + weights[i + 1])
        
        splits.sort()
        min_sum = sum(splits[:k-1])
        max_sum = sum(splits[-(k-1):])
        
        return max_sum - min_sum
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'putMarbles', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 59.151135269216965, 'raw_metrics': {'loc': 13, 'lloc': 15, 'sloc': 13, 'comments': 0}}"
earliest-second-to-mark-indices-i,"```python
from typing import List

class Solution:
    def earliestSecondToMarkIndices(self, nums: List[int], changeIndices: List[int]) -> int:
        n = len(nums)
        m = len(changeIndices)
        
        last_pos = {}
        for s in range(m):
            idx = changeIndices[s] - 1  # converting to 0-based
            last_pos[idx] = s + 1  # 1-based second
        
        if len(last_pos) < n:
            return -1
        
        left = 1
        right = m
        answer = -1
        
        while left <= right:
            mid = (left + right) // 2
            total_required = 0
            required_positions = []
            possible = True
            
            last_positions = {}
            for s in range(mid):
                idx = changeIndices[s] - 1
                last_positions[idx] = s + 1  # 1-based
            
            if len(last_positions) < n:
                possible = False
            else:
                total_required = sum(nums[i] + 1 for i in range(n))
                if total_required > mid:
                    possible = False
                else:
                    indices_order = sorted(range(n), key=lambda x: last_positions[x])
                    current_time = 0
                    possible = True
                    for i in indices_order:
                        required = nums[i] + 1
                        if current_time + required > last_positions[i]:
                            possible = False
                            break
                        current_time += required
            
            if possible:
                answer = mid
                right = mid - 1
            else:
                left = mid + 1
        
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 3}, {'name': 'earliestSecondToMarkIndices', 'complexity': 11, 'lineno': 4}], 'maintainability_index': 59.77902602982598, 'raw_metrics': {'loc': 46, 'lloc': 47, 'sloc': 46, 'comments': 3}}"
divide-players-into-teams-of-equal-skill,"```python
from typing import List

class Solution:
    def dividePlayers(self, skill: List[int]) -> int:
        skill.sort()
        n = len(skill)
        total_skill = sum(skill)
        if total_skill % (n // 2) != 0:
            return -1
        target = total_skill // (n // 2)
        left, right = 0, n - 1
        chemistry_sum = 0
        while left < right:
            if skill[left] + skill[right] != target:
                return -1
            chemistry_sum += skill[left] * skill[right]
            left += 1
            right -= 1
        return chemistry_sum
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'dividePlayers', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 55.28891018518323, 'raw_metrics': {'loc': 19, 'lloc': 19, 'sloc': 19, 'comments': 0}}"
find-the-width-of-columns-of-a-grid,"```python
from typing import List

class Solution:
    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:
        if not grid:
            return []
        n = len(grid[0])
        ans = [0] * n
        for row in grid:
            for i in range(n):
                num = row[i]
                if num < 0:
                    length = len(str(abs(num))) + 1
                else:
                    length = len(str(num))
                if length > ans[i]:
                    ans[i] = length
        return ans
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'findColumnWidth', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 59.585274244687625, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
decode-the-message,"```python
class Solution:
    def decodeMessage(self, key: str, message: str) -> str:
        substitution = {}
        alphabet = 'abcdefghijklmnopqrstuvwxyz'
        index = 0
        
        for char in key:
            if char == ' ':
                continue
            if char not in substitution:
                substitution[char] = alphabet[index]
                index += 1
                if index == 26:
                    break
        
        decoded = []
        for char in message:
            if char == ' ':
                decoded.append(' ')
            else:
                decoded.append(substitution[char])
        
        return ''.join(decoded)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 1}, {'name': 'decodeMessage', 'complexity': 7, 'lineno': 2}], 'maintainability_index': 58.7999970135384, 'raw_metrics': {'loc': 20, 'lloc': 20, 'sloc': 20, 'comments': 0}}"
count-prefix-and-suffix-pairs-i,"```python
class Solution:
    def countPrefixSuffixPairs(self, words: List[str]) -> int:
        count = 0
        n = len(words)
        for i in range(n):
            for j in range(i + 1, n):
                s1 = words[i]
                s2 = words[j]
                if s2.startswith(s1) and s2.endswith(s1):
                    count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'countPrefixSuffixPairs', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 65.83115922178618, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
longest-non-decreasing-subarray-from-two-arrays,"```python
from typing import List

class Solution:
    def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        if n == 0:
            return 0
        
        dp1 = dp2 = 1
        max_len = 1
        
        for i in range(1, n):
            new_dp1 = new_dp2 = 1
            if nums1[i] >= nums1[i-1]:
                new_dp1 = max(new_dp1, dp1 + 1)
            if nums1[i] >= nums2[i-1]:
                new_dp1 = max(new_dp1, dp2 + 1)
            if nums2[i] >= nums1[i-1]:
                new_dp2 = max(new_dp2, dp1 + 1)
            if nums2[i] >= nums2[i-1]:
                new_dp2 = max(new_dp2, dp2 + 1)
            
            dp1, dp2 = new_dp1, new_dp2
            max_len = max(max_len, dp1, dp2)
        
        return max_len
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'maxNonDecreasingLength', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 54.15761510744312, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
check-if-string-is-transformable-with-substring-sort-operations,"```python
from collections import defaultdict, deque

class Solution:
    def isTransformable(self, s: str, t: str) -> bool:
        if sorted(s) != sorted(t):
            return False
        
        pos = defaultdict(deque)
        for idx, ch in enumerate(s):
            pos[int(ch)].append(idx)
        
        for ch in t:
            d = int(ch)
            if not pos[d]:
                return False
            for smaller in range(d):
                if pos[smaller] and pos[smaller][0] < pos[d][0]:
                    return False
            pos[d].popleft()
        
        return True
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 2}, {'name': 'isTransformable', 'complexity': 8, 'lineno': 3}], 'maintainability_index': 60.88254153772511, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
find-the-divisibility-array-of-a-string,"```python
class Solution:
    def divisibilityArray(self, word: str, m: int) -> List[int]:
        n = len(word)
        div = [0] * n
        current_remainder = 0
        for i in range(n):
            digit = int(word[i])
            current_remainder = (current_remainder * 10 + digit) % m
            if current_remainder == 0:
                div[i] = 1
        return div
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'divisibilityArray', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 63.70684363741992, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
design-graph-with-shortest-path-calculator,"```python
import heapq
from typing import List

class Graph:

    def __init__(self, n: int, edges: List[List[int]]):
        self.n = n
        self.graph = [[] for _ in range(n)]
        for edge in edges:
            from_node, to_node, cost = edge
            self.graph[from_node].append((to_node, cost))

    def addEdge(self, edge: List[int]) -> None:
        from_node, to_node, cost = edge
        self.graph[from_node].append((to_node, cost))

    def shortestPath(self, node1: int, node2: int) -> int:
        heap = []
        heapq.heappush(heap, (0, node1))
        visited = {}
        
        while heap:
            current_cost, current_node = heapq.heappop(heap)
            if current_node == node2:
                return current_cost
            if current_node in visited:
                continue
            visited[current_node] = current_cost
            for neighbor, cost in self.graph[current_node]:
                if neighbor not in visited:
                    heapq.heappush(heap, (current_cost + cost, neighbor))
        
        return -1
```","{'cyclomatic_complexity': [{'name': 'Graph', 'complexity': 4, 'lineno': 4}, {'name': '__init__', 'complexity': 3, 'lineno': 5}, {'name': 'addEdge', 'complexity': 1, 'lineno': 11}, {'name': 'shortestPath', 'complexity': 6, 'lineno': 14}], 'maintainability_index': 55.044502426104096, 'raw_metrics': {'loc': 28, 'lloc': 28, 'sloc': 28, 'comments': 0}}"
extra-characters-in-a-string,"```python
from typing import List

class Solution:
    def minExtraChar(self, s: str, dictionary: List[str]) -> int:
        n = len(s)
        dp = [float('inf')] * (n + 1)
        dp[0] = 0
        dictionary_set = set(dictionary)
        
        for i in range(1, n + 1):
            dp[i] = dp[i - 1] + 1
            for j in range(i):
                if s[j:i] in dictionary_set:
                    dp[i] = min(dp[i], dp[j])
        
        return dp[n]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'minExtraChar', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 61.65394646002831, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
fruits-into-baskets-ii,"```python
from typing import List

class Solution:
    def numOfUnplacedFruits(self, fruits: List[int], baskets: List[int]) -> int:
        unplaced = 0
        used_baskets = [False] * len(baskets)
        
        for fruit in fruits:
            placed = False
            for i in range(len(baskets)):
                if not used_baskets[i] and baskets[i] >= fruit:
                    used_baskets[i] = True
                    placed = True
                    break
            if not placed:
                unplaced += 1
                
        return unplaced
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'numOfUnplacedFruits', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 60.21657538812676, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
faulty-keyboard,"```python
class Solution:
    def finalString(self, s: str) -> str:
        result = []
        for char in s:
            if char == 'i':
                result.reverse()
            else:
                result.append(char)
        return ''.join(result)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'finalString', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 73.90483161137286, 'raw_metrics': {'loc': 9, 'lloc': 9, 'sloc': 9, 'comments': 0}}"
count-the-number-of-incremovable-subarrays-i,"```python
from typing import List

class Solution:
    def incremovableSubarrayCount(self, nums: List[int]) -> int:
        n = len(nums)
        count = 0
        
        for i in range(n):
            for j in range(i, n):
                remaining = nums[:i] + nums[j+1:]
                strictly_increasing = True
                for k in range(len(remaining) - 1):
                    if remaining[k] >= remaining[k+1]:
                        strictly_increasing = False
                        break
                if strictly_increasing:
                    count += 1
        
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'incremovableSubarrayCount', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 59.00406708099282, 'raw_metrics': {'loc': 17, 'lloc': 18, 'sloc': 17, 'comments': 0}}"
smallest-missing-non-negative-integer-after-operations,"```python
from typing import List
from collections import defaultdict

class Solution:
    def findSmallestInteger(self, nums: List[int], value: int) -> int:
        freq = defaultdict(int)
        for num in nums:
            mod = num % value
            if mod < 0:
                mod += value
            freq[mod] += 1
        
        mex = 0
        while True:
            mod = mex % value
            if freq[mod] > 0:
                freq[mod] -= 1
                mex += 1
            else:
                return mex
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 4}, {'name': 'findSmallestInteger', 'complexity': 5, 'lineno': 5}], 'maintainability_index': 57.568507701770415, 'raw_metrics': {'loc': 19, 'lloc': 19, 'sloc': 19, 'comments': 0}}"
sum-multiples,"```python
class Solution:
    def sumOfMultiples(self, n: int) -> int:
        total = 0
        for num in range(1, n + 1):
            if num % 3 == 0 or num % 5 == 0 or num % 7 == 0:
                total += num
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 1}, {'name': 'sumOfMultiples', 'complexity': 5, 'lineno': 2}], 'maintainability_index': 66.28287852070146, 'raw_metrics': {'loc': 7, 'lloc': 7, 'sloc': 7, 'comments': 0}}"
lexicographically-smallest-string-after-substring-operation,"```python
class Solution:
    def smallestString(self, s: str) -> str:
        s = list(s)
        n = len(s)
        i = 0
        while i < n and s[i] == 'a':
            i += 1
        if i == n:
            s[-1] = 'z'
            return ''.join(s)
        j = i
        while j < n and s[j] != 'a':
            s[j] = chr(ord(s[j]) - 1)
            j += 1
        return ''.join(s)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 1}, {'name': 'smallestString', 'complexity': 6, 'lineno': 2}], 'maintainability_index': 58.46568286727844, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
length-of-longest-subarray-with-at-most-k-frequency,"```python
from typing import List
from collections import defaultdict

class Solution:
    def maxSubarrayLength(self, nums: List[int], k: int) -> int:
        freq = defaultdict(int)
        left = 0
        max_len = 0
        
        for right in range(len(nums)):
            freq[nums[right]] += 1
            
            while freq[nums[right]] > k:
                freq[nums[left]] -= 1
                left += 1
            
            max_len = max(max_len, right - left + 1)
        
        return max_len
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 4}, {'name': 'maxSubarrayLength', 'complexity': 3, 'lineno': 5}], 'maintainability_index': 61.24322293734288, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
decode-xored-array,"```python
from typing import List

class Solution:
    def decode(self, encoded: List[int], first: int) -> List[int]:
        arr = [first]
        for num in encoded:
            arr.append(arr[-1] ^ num)
        return arr
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 3}, {'name': 'decode', 'complexity': 2, 'lineno': 4}], 'maintainability_index': 72.44064369438814, 'raw_metrics': {'loc': 8, 'lloc': 8, 'sloc': 8, 'comments': 0}}"
destroy-sequential-targets,"```python
from typing import List
from collections import defaultdict

class Solution:
    def destroyTargets(self, nums: List[int], space: int) -> int:
        mod_counts = defaultdict(int)
        mod_min = {}
        
        for num in nums:
            mod = num % space
            mod_counts[mod] += 1
            if mod in mod_min:
                if num < mod_min[mod]:
                    mod_min[mod] = num
            else:
                mod_min[mod] = num
        
        max_count = max(mod_counts.values()) if mod_counts else 0
        candidates = [mod_min[mod] for mod in mod_counts if mod_counts[mod] == max_count]
        
        return min(candidates) if candidates else min(nums)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 4}, {'name': 'destroyTargets', 'complexity': 8, 'lineno': 5}], 'maintainability_index': 59.106465512680536, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
maximum-deletions-on-a-string,"```python
class Solution:
    def deleteString(self, s: str) -> int:
        n = len(s)
        dp = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            dp[i] = 1
            max_len = (n - i) // 2
            for l in range(1, max_len + 1):
                if s[i:i+l] == s[i+l:i+2*l]:
                    dp[i] = max(dp[i], 1 + dp[i + l])
        return dp[0]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 1}, {'name': 'deleteString', 'complexity': 4, 'lineno': 2}], 'maintainability_index': 60.77451089738033, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
minimum-difference-in-sums-after-removal-of-elements,"```python
import heapq

class Solution:
    def minimumDifference(self, nums: List[int]) -> int:
        n = len(nums) // 3
        
        max_heap = []
        left_sum = 0
        left_sums = [0] * (3 * n)
        
        for i in range(2 * n):
            num = nums[i]
            heapq.heappush(max_heap, -num)
            left_sum += num
            if len(max_heap) > n:
                val = -heapq.heappop(max_heap)
                left_sum -= val
            if i >= n - 1:
                left_sums[i] = left_sum
        
        min_heap = []
        right_sum = 0
        right_sums = [0] * (3 * n)
        
        for i in range(3 * n - 1, n - 1, -1):
            num = nums[i]
            heapq.heappush(min_heap, num)
            right_sum += num
            if len(min_heap) > n:
                val = heapq.heappop(min_heap)
                right_sum -= val
            if i <= 2 * n:
                right_sums[i] = right_sum
        
        min_diff = float('inf')
        for i in range(n - 1, 2 * n):
            diff = left_sums[i] - right_sums[i + 1]
            if diff < min_diff:
                min_diff = diff
        
        return min_diff
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 3}, {'name': 'minimumDifference', 'complexity': 9, 'lineno': 4}], 'maintainability_index': 46.80317674748986, 'raw_metrics': {'loc': 35, 'lloc': 35, 'sloc': 35, 'comments': 0}}"
make-array-empty,"```python
from typing import List
import bisect

class Solution:
    def countOperationsToEmptyArray(self, nums: List[int]) -> int:
        n = len(nums)
        sorted_nums = sorted((num, i) for i, num in enumerate(nums))
        res = n  # initial pass through all elements
        
        for k in range(1, n):
            if sorted_nums[k-1][1] > sorted_nums[k][1]:
                res += n - k
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 4}, {'name': 'countOperationsToEmptyArray', 'complexity': 4, 'lineno': 5}], 'maintainability_index': 81.04456553099892, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 1}}"
ways-to-split-array-into-good-subarrays,"```python
class Solution:
    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        ones = []
        for i, num in enumerate(nums):
            if num == 1:
                ones.append(i)
        if not ones:
            return 0
        if len(ones) == 1:
            return 1
        res = 1
        for i in range(1, len(ones)):
            res *= (ones[i] - ones[i-1])
            res %= MOD
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 2}, {'name': 'numberOfGoodSubarraySplits', 'complexity': 6, 'lineno': 3}], 'maintainability_index': 57.80969915845673, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
minimize-length-of-array-using-operations,"```python
from typing import List

class Solution:
    def minimumArrayLength(self, nums: List[int]) -> int:
        min_num = min(nums)
        for num in nums:
            if num % min_num != 0:
                return 1
        return (nums.count(min_num) + 1) // 2
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'minimumArrayLength', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 67.20722666417035, 'raw_metrics': {'loc': 9, 'lloc': 9, 'sloc': 9, 'comments': 0}}"
maximum-sum-of-almost-unique-subarray,"```python
from collections import defaultdict
from typing import List

class Solution:
    def maxSum(self, nums: List[int], m: int, k: int) -> int:
        max_sum = 0
        current_sum = 0
        freq = defaultdict(int)
        left = 0
        
        for right in range(len(nums)):
            freq[nums[right]] += 1
            current_sum += nums[right]
            
            if right - left + 1 == k:
                if len(freq) >= m:
                    max_sum = max(max_sum, current_sum)
                current_sum -= nums[left]
                freq[nums[left]] -= 1
                if freq[nums[left]] == 0:
                    del freq[nums[left]]
                left += 1
        
        return max_sum
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 4}, {'name': 'maxSum', 'complexity': 5, 'lineno': 5}], 'maintainability_index': 55.608811567074774, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
double-a-number-represented-as-a-linked-list,"```python
class Solution:
    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:
        def reverse(node):
            prev = None
            while node:
                next_node = node.next
                node.next = prev
                prev = node
                node = next_node
            return prev
        
        reversed_head = reverse(head)
        carry = 0
        current = reversed_head
        prev = None
        while current:
            new_val = current.val * 2 + carry
            current.val = new_val % 10
            carry = new_val // 10
            prev = current
            current = current.next
        
        if carry > 0:
            prev.next = ListNode(carry)
        
        return reverse(reversed_head)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'doubleIt', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 57.236594871407874, 'raw_metrics': {'loc': 24, 'lloc': 24, 'sloc': 24, 'comments': 0}}"
special-permutations,"```python
class Solution:
    def specialPerm(self, nums: List[int]) -> int:
        from functools import lru_cache
        
        n = len(nums)
        MOD = 10**9 + 7
        
        @lru_cache(maxsize=None)
        def dfs(prev, mask):
            if mask == (1 << n) - 1:
                return 1
            total = 0
            for i in range(n):
                if not (mask & (1 << i)):
                    if prev % nums[i] == 0 or nums[i] % prev == 0:
                        total += dfs(nums[i], mask | (1 << i))
                        total %= MOD
            return total
        
        result = 0
        for i in range(n):
            result += dfs(nums[i], 1 << i)
            result %= MOD
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 2}, {'name': 'specialPerm', 'complexity': 2, 'lineno': 3}], 'maintainability_index': 52.850400112277676, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
mice-and-cheese,"```python
from typing import List

class Solution:
    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:
        n = len(reward1)
        diff = [(reward1[i] - reward2[i], i) for i in range(n)]
        diff.sort(reverse=True, key=lambda x: x[0])
        
        total = 0
        for i in range(n):
            if i < k:
                total += reward1[diff[i][1]]
            else:
                total += reward2[diff[i][1]]
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'miceAndCheese', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 62.465050444989814, 'raw_metrics': {'loc': 14, 'lloc': 15, 'sloc': 14, 'comments': 0}}"
maximum-number-of-distinct-elements-after-operations,"```python
from typing import List

class Solution:
    def maxDistinctElements(self, nums: List[int], k: int) -> int:
        nums.sort()
        n = len(nums)
        res = 1
        prev = nums[0] - k - 1  # Initialize to ensure first element is considered
        
        for i in range(n):
            current = nums[i]
            optimal = max(prev + 1, current - k)
            if optimal <= current + k:
                res += 1
                prev = optimal
            else:
                pass
        return res - 1  # Subtract 1 because we started counting from 1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'maxDistinctElements', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 78.14961758589932, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 2}}"
number-of-increasing-paths-in-a-grid,"```python
class Solution:
    def countPaths(self, grid: List[List[int]]) -> int:
        MOD = 10**9 + 7
        m, n = len(grid), len(grid[0])
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        dp = [[1] * n for _ in range(m)]
        cells = [(i, j) for i in range(m) for j in range(n)]
        cells.sort(key=lambda x: grid[x[0]][x[1]])
        
        for i, j in cells:
            for di, dj in directions:
                ni, nj = i + di, j + dj
                if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] > grid[i][j]:
                    dp[ni][nj] = (dp[ni][nj] + dp[i][j]) % MOD
        
        return sum(sum(row) % MOD for row in dp) % MOD
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 2}, {'name': 'countPaths', 'complexity': 10, 'lineno': 3}], 'maintainability_index': 55.509938498530005, 'raw_metrics': {'loc': 15, 'lloc': 16, 'sloc': 15, 'comments': 0}}"
split-array-into-maximum-number-of-subarrays,"```python
from typing import List

class Solution:
    def maxSubarrays(self, nums: List[int]) -> int:
        if not nums:
            return 0
        
        total_and = (1 << 30) - 1  # Initialize with all bits set (for 32-bit integers, but 30 is sufficient for constraints)
        for num in nums:
            total_and &= num
        
        if total_and != 0:
            return 1
        
        res = 0
        current_and = (1 << 30) - 1
        for num in nums:
            current_and &= num
            if current_and == 0:
                res += 1
                current_and = (1 << 30) - 1
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'maxSubarrays', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 69.39208649664272, 'raw_metrics': {'loc': 19, 'lloc': 19, 'sloc': 19, 'comments': 1}}"
count-operations-to-obtain-zero,"```python
class Solution:
    def countOperations(self, num1: int, num2: int) -> int:
        count = 0
        while num1 != 0 and num2 != 0:
            if num1 >= num2:
                num1 -= num2
            else:
                num2 -= num1
            count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 1}, {'name': 'countOperations', 'complexity': 4, 'lineno': 2}], 'maintainability_index': 64.37281587415808, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
find-consecutive-integers-from-a-data-stream,"```python
class DataStream:

    def __init__(self, value: int, k: int):
        self.value = value
        self.k = k
        self.queue = []
        self.count = 0

    def consec(self, num: int) -> bool:
        self.queue.append(num)
        if num == self.value:
            self.count += 1
        else:
            self.count = 0
        
        if len(self.queue) < self.k:
            return False
        return self.count >= self.k
```","{'cyclomatic_complexity': [{'name': 'DataStream', 'complexity': 3, 'lineno': 1}, {'name': '__init__', 'complexity': 1, 'lineno': 2}, {'name': 'consec', 'complexity': 3, 'lineno': 7}], 'maintainability_index': 62.465050444989814, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
most-frequent-even-element,"```python
from typing import List
from collections import defaultdict

class Solution:
    def mostFrequentEven(self, nums: List[int]) -> int:
        freq = defaultdict(int)
        for num in nums:
            if num % 2 == 0:
                freq[num] += 1
        if not freq:
            return -1
        max_freq = max(freq.values())
        candidates = [num for num, count in freq.items() if count == max_freq]
        return min(candidates)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 4}, {'name': 'mostFrequentEven', 'complexity': 6, 'lineno': 5}], 'maintainability_index': 61.56008740053743, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
find-first-palindromic-string-in-the-array,"```python
from typing import List

class Solution:
    def firstPalindrome(self, words: List[str]) -> str:
        for word in words:
            if word == word[::-1]:
                return word
        return """"
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'firstPalindrome', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 72.30614077041155, 'raw_metrics': {'loc': 8, 'lloc': 8, 'sloc': 8, 'comments': 0}}"
maximum-strong-pair-xor-i,"```python
from typing import List

class Solution:
    def maximumStrongPairXor(self, nums: List[int]) -> int:
        max_xor = 0
        n = len(nums)
        for i in range(n):
            for j in range(i, n):
                x, y = nums[i], nums[j]
                if abs(x - y) <= min(x, y):
                    max_xor = max(max_xor, x ^ y)
        return max_xor
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'maximumStrongPairXor', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 65.96566214576278, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
make-three-strings-equal,"```python
class Solution:
    def findMinimumOperations(self, s1: str, s2: str, s3: str) -> int:
        min_len = min(len(s1), len(s2), len(s3))
        common_len = 0
        for i in range(min_len):
            if s1[i] == s2[i] == s3[i]:
                common_len += 1
            else:
                break
        if common_len == 0:
            return -1
        return (len(s1) - common_len) + (len(s2) - common_len) + (len(s3) - common_len)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 1}, {'name': 'findMinimumOperations', 'complexity': 4, 'lineno': 2}], 'maintainability_index': 61.371837254192876, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
minimum-positive-sum-subarray,"```python
from typing import List

class Solution:
    def minimumSumSubarray(self, nums: List[int], l: int, r: int) -> int:
        min_sum = float('inf')
        n = len(nums)
        
        for length in range(l, r + 1):
            current_sum = sum(nums[:length])
            if current_sum > 0:
                min_sum = min(min_sum, current_sum)
            
            for i in range(1, n - length + 1):
                current_sum = current_sum - nums[i-1] + nums[i + length - 1]
                if current_sum > 0:
                    min_sum = min(min_sum, current_sum)
        
        return min_sum if min_sum != float('inf') else -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'minimumSumSubarray', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 57.581760488556185, 'raw_metrics': {'loc': 15, 'lloc': 16, 'sloc': 15, 'comments': 0}}"
smallest-missing-genetic-value-in-each-subtree,"```python
from typing import List

class Solution:
    def smallestMissingValueSubtree(self, parents: List[int], nums: List[int]) -> List[int]:
        n = len(parents)
        children = [[] for _ in range(n)]
        for i in range(1, n):
            children[parents[i]].append(i)
        
        res = [1] * n
        if 1 not in nums:
            return res
        
        node = nums.index(1)
        visited = set()
        missing = 1
        while node != -1:
            stack = [node]
            while stack:
                u = stack.pop()
                if nums[u] not in visited:
                    visited.add(nums[u])
                    for v in children[u]:
                        stack.append(v)
            while missing in visited:
                missing += 1
            res[node] = missing
            node = parents[node]
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 3}, {'name': 'smallestMissingValueSubtree', 'complexity': 9, 'lineno': 4}], 'maintainability_index': 54.17741375314457, 'raw_metrics': {'loc': 27, 'lloc': 27, 'sloc': 27, 'comments': 0}}"
count-the-number-of-incremovable-subarrays-ii,"```python
from typing import List

class Solution:
    def incremovableSubarrayCount(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 1:
            return 1
        
        left = 0
        while left + 1 < n and nums[left] < nums[left + 1]:
            left += 1
        
        if left == n - 1:
            return n * (n + 1) // 2
        
        right = n - 1
        while right > 0 and nums[right - 1] < nums[right]:
            right -= 1
        
        res = left + 2  # subarrays ending at left + 1 (0...left + 1)
        res += n - right  # subarrays starting at right - 1 (right - 1...n - 1)
        
        i = 0
        j = right
        while i <= left and j < n:
            if nums[i] < nums[j]:
                res += n - j
                i += 1
            else:
                j += 1
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 3}, {'name': 'incremovableSubarrayCount', 'complexity': 10, 'lineno': 4}], 'maintainability_index': 64.97194924969997, 'raw_metrics': {'loc': 26, 'lloc': 26, 'sloc': 26, 'comments': 2}}"
maximize-area-of-square-hole-in-grid,"```python
from typing import List

class Solution:
    def maximizeSquareHoleArea(self, n: int, m: int, hBars: List[int], vBars: List[int]) -> int:
        def get_max_consecutive(bars):
            if not bars:
                return 0
            bars = sorted(bars)
            max_len = current = 1
            for i in range(1, len(bars)):
                if bars[i] == bars[i-1] + 1:
                    current += 1
                    max_len = max(max_len, current)
                else:
                    current = 1
            return max_len + 1
        
        h_max = get_max_consecutive(hBars)
        v_max = get_max_consecutive(vBars)
        side = min(h_max, v_max)
        return side * side
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 3}, {'name': 'maximizeSquareHoleArea', 'complexity': 1, 'lineno': 4}], 'maintainability_index': 58.17501105045476, 'raw_metrics': {'loc': 20, 'lloc': 20, 'sloc': 20, 'comments': 0}}"
string-compression-iii,"```python
class Solution:
    def compressedString(self, word: str) -> str:
        comp = []
        i = 0
        n = len(word)
        while i < n:
            c = word[i]
            j = i
            while j < n and word[j] == c and (j - i) < 9:
                j += 1
            length = j - i
            comp.append(f""{length}{c}"")
            i = j
        return ''.join(comp)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 1}, {'name': 'compressedString', 'complexity': 5, 'lineno': 2}], 'maintainability_index': 60.187360405318564, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
count-anagrams,"```python
import math
from collections import defaultdict

class Solution:
    def countAnagrams(self, s: str) -> int:
        MOD = 10**9 + 7
        words = s.split()
        result = 1
        for word in words:
            freq = defaultdict(int)
            for c in word:
                freq[c] += 1
            denominator = 1
            for cnt in freq.values():
                denominator = (denominator * math.factorial(cnt)) % MOD
            numerator = math.factorial(len(word))
            result = (result * numerator * pow(denominator, MOD-2, MOD)) % MOD
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'countAnagrams', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 57.96393909675451, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
merge-strings-alternately,"```python
class Solution:
    def mergeAlternately(self, word1: str, word2: str) -> str:
        merged = []
        i = 0
        while i < len(word1) or i < len(word2):
            if i < len(word1):
                merged.append(word1[i])
            if i < len(word2):
                merged.append(word2[i])
            i += 1
        return ''.join(merged)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 1}, {'name': 'mergeAlternately', 'complexity': 5, 'lineno': 2}], 'maintainability_index': 63.91252693647866, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
count-number-of-pairs-with-absolute-difference-k,"```python
from typing import List

class Solution:
    def countKDifference(self, nums: List[int], k: int) -> int:
        count = 0
        freq = {}
        for num in nums:
            count += freq.get(num - k, 0) + freq.get(num + k, 0)
            freq[num] = freq.get(num, 0) + 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 3}, {'name': 'countKDifference', 'complexity': 2, 'lineno': 4}], 'maintainability_index': 65.8967395002637, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
append-characters-to-string-to-make-subsequence,"```python
class Solution:
    def appendCharacters(self, s: str, t: str) -> int:
        s_ptr = 0
        t_ptr = 0
        s_len = len(s)
        t_len = len(t)
        
        while s_ptr < s_len and t_ptr < t_len:
            if s[s_ptr] == t[t_ptr]:
                t_ptr += 1
            s_ptr += 1
        
        return t_len - t_ptr
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 1}, {'name': 'appendCharacters', 'complexity': 4, 'lineno': 2}], 'maintainability_index': 63.286853482361195, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
manhattan-distances-of-all-arrangements-of-pieces,"```python
class Solution:
    def distanceSum(self, m: int, n: int, k: int) -> int:
        MOD = 10**9 + 7
        
        def compute_S(N, k):
            if N < k:
                return 0
            total = 0
            for d in range(1, N):
                cnt = (N - d) * d
                ways = comb(N * n_total - 2, k - 2) if m * n_total >= k else 0
                total += cnt * ways
            return total
        
        n_total = n
        m_total = m
        total_cells = m * n
        
        if k < 2 or total_cells < k:
            return 0
        
        max_n = total_cells
        fact = [1] * (max_n + 1)
        inv_fact = [1] * (max_n + 1)
        
        for i in range(1, max_n + 1):
            fact[i] = fact[i-1] * i % MOD
        
        inv_fact[max_n] = pow(fact[max_n], MOD-2, MOD)
        for i in range(max_n - 1, -1, -1):
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD
        
        def comb(a, b):
            if a < 0 or b < 0 or a < b:
                return 0
            return fact[a] * inv_fact[b] % MOD * inv_fact[a - b] % MOD
        
        x_sum = 0
        for d in range(1, m):
            cnt = (m - d) * d * n * n
            ways = comb(total_cells - 2, k - 2)
            x_sum = (x_sum + cnt * ways) % MOD
        
        y_sum = 0
        for d in range(1, n):
            cnt = (n - d) * d * m * m
            ways = comb(total_cells - 2, k - 2)
            y_sum = (y_sum + cnt * ways) % MOD
        
        total = (x_sum + y_sum) % MOD
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 1}, {'name': 'distanceSum', 'complexity': 7, 'lineno': 2}], 'maintainability_index': 42.35527889722212, 'raw_metrics': {'loc': 41, 'lloc': 41, 'sloc': 41, 'comments': 0}}"
longest-subsequence-with-limited-sum,"```python
class Solution:
    def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:
        nums.sort()
        prefix = [0]
        for num in nums:
            prefix.append(prefix[-1] + num)
        
        answer = []
        for query in queries:
            left, right = 0, len(prefix) - 1
            best = 0
            while left <= right:
                mid = (left + right) // 2
                if prefix[mid] <= query:
                    best = mid
                    left = mid + 1
                else:
                    right = mid - 1
            answer.append(best)
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'answerQueries', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 56.689066954906565, 'raw_metrics': {'loc': 20, 'lloc': 20, 'sloc': 20, 'comments': 0}}"
minimize-deviation-in-array,"```python
import heapq

class Solution:
    def minimumDeviation(self, nums: List[int]) -> int:
        max_heap = []
        min_val = float('inf')
        
        for num in nums:
            if num % 2 == 1:
                num *= 2
            heapq.heappush(max_heap, -num)
            min_val = min(min_val, num)
        
        min_deviation = float('inf')
        
        while True:
            current_max = -heapq.heappop(max_heap)
            min_deviation = min(min_deviation, current_max - min_val)
            
            if current_max % 2 == 1:
                break
            
            new_num = current_max // 2
            min_val = min(min_val, new_num)
            heapq.heappush(max_heap, -new_num)
        
        return min_deviation
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'minimumDeviation', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 56.18370021946558, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
reward-top-k-students,"```python
from typing import List

class Solution:
    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:
        positive = set(positive_feedback)
        negative = set(negative_feedback)
        student_points = {}
        
        for i in range(len(report)):
            words = report[i].split()
            points = 0
            for word in words:
                if word in positive:
                    points += 3
                elif word in negative:
                    points -= 1
            current_id = student_id[i]
            student_points[current_id] = points
        
        sorted_students = sorted(student_points.keys(), key=lambda x: (-student_points[x], x))
        return sorted_students[:k]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'topStudents', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 58.55081638400782, 'raw_metrics': {'loc': 19, 'lloc': 21, 'sloc': 19, 'comments': 0}}"
maximum-value-of-an-ordered-triplet-ii,"```python
from typing import List

class Solution:
    def maximumTripletValue(self, nums: List[int]) -> int:
        max_i_minus_j = 0
        max_i = nums[0]
        res = 0
        
        for j in range(1, len(nums)):
            res = max(res, max_i_minus_j * nums[j])
            max_i_minus_j = max(max_i_minus_j, max_i - nums[j])
            max_i = max(max_i, nums[j])
        
        return res if res > 0 else 0
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'maximumTripletValue', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 65.73079721739349, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
maximum-subarray-with-equal-products,"```python
import math
from typing import List

class Solution:
    def maxLength(self, nums: List[int]) -> int:
        max_len = 0
        n = len(nums)
        
        for i in range(n):
            current_gcd = nums[i]
            current_lcm = nums[i]
            current_prod = nums[i]
            
            for j in range(i + 1, n):
                current_gcd = math.gcd(current_gcd, nums[j])
                current_lcm = (current_lcm * nums[j]) // math.gcd(current_lcm, nums[j])
                current_prod *= nums[j]
                
                if current_prod == current_lcm * current_gcd:
                    max_len = max(max_len, j - i + 1)
        
        return max_len
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 4}, {'name': 'maxLength', 'complexity': 4, 'lineno': 5}], 'maintainability_index': 57.9993511628183, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
find-the-maximum-divisibility-score,"```python
from typing import List

class Solution:
    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:
        max_score = -1
        result = None
        for d in sorted(divisors):
            score = 0
            for num in nums:
                if num % d == 0:
                    score += 1
            if score > max_score or (score == max_score and d < result):
                max_score = score
                result = d
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'maxDivScore', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 58.91007971667258, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
min-max-game,"```python
from typing import List

class Solution:
    def minMaxGame(self, nums: List[int]) -> int:
        while len(nums) > 1:
            new_nums = []
            for i in range(len(nums) // 2):
                if i % 2 == 0:
                    new_nums.append(min(nums[2*i], nums[2*i+1]))
                else:
                    new_nums.append(max(nums[2*i], nums[2*i+1]))
            nums = new_nums
        return nums[0]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'minMaxGame', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 60.541132511174254, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
maximum-number-of-groups-with-increasing-length,"```python
class Solution:
    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:
        usageLimits = sorted(usageLimits)
        total = 0
        res = 0
        for num in usageLimits:
            total += num
            if total >= (res + 1) * (res + 2) // 2:
                res += 1
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'maxIncreasingGroups', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 63.5079715185905, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
longest-uploaded-prefix,"```python
class LUPrefix:

    def __init__(self, n: int):
        self.uploaded = set()
        self.longest_prefix = 0

    def upload(self, video: int) -> None:
        self.uploaded.add(video)
        while self.longest_prefix + 1 in self.uploaded:
            self.longest_prefix += 1

    def longest(self) -> int:
        return self.longest_prefix


```","{'cyclomatic_complexity': [{'name': 'LUPrefix', 'complexity': 2, 'lineno': 1}, {'name': '__init__', 'complexity': 1, 'lineno': 2}, {'name': 'upload', 'complexity': 2, 'lineno': 5}, {'name': 'longest', 'complexity': 1, 'lineno': 9}], 'maintainability_index': 67.94389268085007, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
count-fertile-pyramids-in-a-land,"```python
class Solution:
    def countPyramids(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        res = 0
        dp = [[0] * n for _ in range(m)]
        
        for i in range(m - 1, -1, -1):
            for j in range(n):
                if grid[i][j] == 0:
                    dp[i][j] = 0
                else:
                    if i == m - 1 or j == 0 or j == n - 1:
                        dp[i][j] = 1
                    else:
                        dp[i][j] = 1 + min(dp[i + 1][j - 1], dp[i + 1][j], dp[i + 1][j + 1])
                    res += dp[i][j] - 1
        
        dp = [[0] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 0:
                    dp[i][j] = 0
                else:
                    if i == 0 or j == 0 or j == n - 1:
                        dp[i][j] = 1
                    else:
                        dp[i][j] = 1 + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i - 1][j + 1])
                    res += dp[i][j] - 1
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 16, 'lineno': 2}, {'name': 'countPyramids', 'complexity': 15, 'lineno': 3}], 'maintainability_index': 47.3212579891381, 'raw_metrics': {'loc': 28, 'lloc': 28, 'sloc': 28, 'comments': 0}}"
build-a-matrix-with-conditions,"```python
from collections import deque

class Solution:
    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:
        def topological_sort(conditions, k):
            graph = [[] for _ in range(k+1)]
            in_degree = [0] * (k+1)
            
            for u, v in conditions:
                graph[u].append(v)
                in_degree[v] += 1
            
            queue = deque()
            for i in range(1, k+1):
                if in_degree[i] == 0:
                    queue.append(i)
            
            order = []
            while queue:
                u = queue.popleft()
                order.append(u)
                for v in graph[u]:
                    in_degree[v] -= 1
                    if in_degree[v] == 0:
                        queue.append(v)
            
            if len(order) != k:
                return None
            return order
        
        row_order = topological_sort(rowConditions, k)
        col_order = topological_sort(colConditions, k)
        
        if not row_order or not col_order:
            return []
        
        row_pos = {num: i for i, num in enumerate(row_order)}
        col_pos = {num: i for i, num in enumerate(col_order)}
        
        matrix = [[0] * k for _ in range(k)]
        for num in range(1, k+1):
            matrix[row_pos[num]][col_pos[num]] = num
        
        return matrix
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'buildMatrix', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 48.866953586802566, 'raw_metrics': {'loc': 35, 'lloc': 37, 'sloc': 35, 'comments': 0}}"
maximum-number-of-k-divisible-components,"```python
from typing import List

class Solution:
    def maxKDivisibleComponents(self, n: int, edges: List[List[int]], values: List[int], k: int) -> int:
        from collections import defaultdict
        
        graph = defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        res = 0
        
        def dfs(node, parent):
            nonlocal res
            total = values[node]
            for neighbor in graph[node]:
                if neighbor != parent:
                    total += dfs(neighbor, node)
            if total % k == 0:
                res += 1
                return 0
            return total
        
        dfs(0, -1)
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 3}, {'name': 'maxKDivisibleComponents', 'complexity': 2, 'lineno': 4}], 'maintainability_index': 57.553301424638036, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
strange-printer-ii,"```python
from typing import List

class Solution:
    def isPrintable(self, targetGrid: List[List[int]]) -> bool:
        m = len(targetGrid)
        n = len(targetGrid[0]) if m > 0 else 0
        
        color_rect = {}
        
        for i in range(m):
            for j in range(n):
                color = targetGrid[i][j]
                if color not in color_rect:
                    color_rect[color] = [i, i, j, j]  # min_row, max_row, min_col, max_col
                else:
                    rect = color_rect[color]
                    rect[0] = min(rect[0], i)
                    rect[1] = max(rect[1], i)
                    rect[2] = min(rect[2], j)
                    rect[3] = max(rect[3], j)
        
        graph = {}
        colors = color_rect.keys()
        
        for color in colors:
            graph[color] = set()
        
        for color in colors:
            min_row, max_row, min_col, max_col = color_rect[color]
            for i in range(min_row, max_row + 1):
                for j in range(min_col, max_col + 1):
                    other_color = targetGrid[i][j]
                    if other_color != color:
                        graph[other_color].add(color)
        
        visited = {}
        recursion_stack = {}
        
        def has_cycle(node):
            visited[node] = True
            recursion_stack[node] = True
            for neighbor in graph[node]:
                if neighbor not in visited:
                    if has_cycle(neighbor):
                        return True
                elif recursion_stack[neighbor]:
                    return True
            recursion_stack[node] = False
            return False
        
        for node in graph:
            if node not in visited:
                if has_cycle(node):
                    return False
        return True
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 14, 'lineno': 3}, {'name': 'isPrintable', 'complexity': 13, 'lineno': 4}], 'maintainability_index': 56.87164366948772, 'raw_metrics': {'loc': 47, 'lloc': 47, 'sloc': 47, 'comments': 1}}"
count-array-pairs-divisible-by-k,"```python
import math
from collections import defaultdict
from typing import List

class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        freq = defaultdict(int)
        res = 0
        
        def compute_gcd_of_factors(num, k):
            gcd_val = math.gcd(num, k)
            return gcd_val
        
        for num in nums:
            gcd_val = compute_gcd_of_factors(num, k)
            target = k // gcd_val
            for d in freq:
                if d % target == 0:
                    res += freq[d]
            freq[gcd_val] += 1
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 5}, {'name': 'countPairs', 'complexity': 4, 'lineno': 6}], 'maintainability_index': 59.13226142813171, 'raw_metrics': {'loc': 19, 'lloc': 19, 'sloc': 19, 'comments': 0}}"
minimum-number-of-days-to-disconnect-island,"```python
from typing import List

class Solution:
    def minDays(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        
        def count_islands():
            visited = [[False for _ in range(n)] for _ in range(m)]
            count = 0
            for i in range(m):
                for j in range(n):
                    if grid[i][j] == 1 and not visited[i][j]:
                        count += 1
                        if count > 1:
                            return count
                        stack = [(i, j)]
                        visited[i][j] = True
                        while stack:
                            x, y = stack.pop()
                            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                                nx, ny = x + dx, y + dy
                                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1 and not visited[nx][ny]:
                                    visited[nx][ny] = True
                                    stack.append((nx, ny))
            return count
        
        islands = count_islands()
        if islands != 1:
            return 0
        
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    grid[i][j] = 0
                    islands = count_islands()
                    grid[i][j] = 1
                    if islands != 1:
                        return 1
        
        return 2
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'minDays', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 48.11487250272632, 'raw_metrics': {'loc': 36, 'lloc': 36, 'sloc': 36, 'comments': 0}}"
number-of-unequal-triplets-in-array,"```python
from typing import List

class Solution:
    def unequalTriplets(self, nums: List[int]) -> int:
        count = 0
        n = len(nums)
        for i in range(n):
            for j in range(i + 1, n):
                if nums[i] != nums[j]:
                    for k in range(j + 1, n):
                        if nums[i] != nums[k] and nums[j] != nums[k]:
                            count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'unequalTriplets', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 61.22224929975988, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
divide-array-into-equal-pairs,"```python
from collections import defaultdict
from typing import List

class Solution:
    def divideArray(self, nums: List[int]) -> bool:
        freq = defaultdict(int)
        for num in nums:
            freq[num] += 1
        for count in freq.values():
            if count % 2 != 0:
                return False
        return True
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 4}, {'name': 'divideArray', 'complexity': 4, 'lineno': 5}], 'maintainability_index': 65.59629429341688, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
minimum-operations-to-make-binary-array-elements-equal-to-one-ii,"```python
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        operations = 0
        flip = 0
        for i in range(len(nums)):
            current = nums[i] ^ flip
            if current == 0:
                operations += 1
                flip ^= 1
        return operations
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'minOperations', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 65.68029284925473, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
frog-jump-ii,"```python
from typing import List

class Solution:
    def maxJump(self, stones: List[int]) -> int:
        if len(stones) == 2:
            return stones[1] - stones[0]
        max_cost = 0
        for i in range(2, len(stones)):
            max_cost = max(max_cost, stones[i] - stones[i-2])
        return max_cost
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'maxJump', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 66.5832313947694, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
count-submatrices-with-top-left-element-and-sum-less-than-k,"```python
from typing import List

class Solution:
    def countSubmatrices(self, grid: List[List[int]], k: int) -> int:
        m = len(grid)
        n = len(grid[0])
        prefix = [[0] * (n + 1) for _ in range(m + 1)]
        count = 0
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                prefix[i][j] = grid[i-1][j-1] + prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1]
                if prefix[i][j] <= k:
                    count += 1
                else:
                    break
        
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'countSubmatrices', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 56.70325673337551, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
minimum-increment-operations-to-make-array-beautiful,"```python
class Solution:
    def minIncrementOperations(self, nums: List[int], k: int) -> int:
        n = len(nums)
        dp = [0] * n
        
        for i in range(n):
            if i < 3:
                dp[i] = max(0, k - nums[i])
            else:
                dp[i] = max(0, k - nums[i]) + min(dp[i-1], dp[i-2], dp[i-3])
        
        return min(dp[-1], dp[-2], dp[-3]) if n >=3 else 0
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'minIncrementOperations', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 61.69652055274104, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
goal-parser-interpretation,"```python
class Solution:
    def interpret(self, command: str) -> str:
        result = []
        i = 0
        n = len(command)
        while i < n:
            if command[i] == 'G':
                result.append('G')
                i += 1
            elif command[i] == '(':
                if i + 1 < n and command[i+1] == ')':
                    result.append('o')
                    i += 2
                elif i + 3 < n and command[i+1] == 'a' and command[i+2] == 'l' and command[i+3] == ')':
                    result.append('al')
                    i += 4
                else:
                    i += 1
            else:
                i += 1
        return ''.join(result)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 1}, {'name': 'interpret', 'complexity': 10, 'lineno': 2}], 'maintainability_index': 52.03979957063837, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
number-of-beautiful-integers-in-the-range,"```python
class Solution:
    def numberOfBeautifulIntegers(self, low: int, high: int, k: int) -> int:
        def countBeautifulNumbers(n):
            s = str(n)
            length = len(s)
            from functools import lru_cache
            
            @lru_cache(maxsize=None)
            def dp(pos, tight, even_odd_diff, mod, leading_zero):
                if pos == length:
                    return 1 if (even_odd_diff == 0 and mod == 0 and not leading_zero) else 0
                limit = int(s[pos]) if tight else 9
                total = 0
                for d in range(0, limit + 1):
                    new_tight = tight and (d == limit)
                    new_leading_zero = leading_zero and (d == 0)
                    new_mod = (mod * 10 + d) % k if not new_leading_zero else 0
                    if new_leading_zero:
                        new_even_odd_diff = even_odd_diff
                    else:
                        if d % 2 == 0:
                            new_even_odd_diff = even_odd_diff + 1
                        else:
                            new_even_odd_diff = even_odd_diff - 1
                    total += dp(pos + 1, new_tight, new_even_odd_diff, new_mod, new_leading_zero)
                return total
            return dp(0, True, 0, 0, True)
        
        return countBeautifulNumbers(high) - countBeautifulNumbers(low - 1)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 1}, {'name': 'numberOfBeautifulIntegers', 'complexity': 1, 'lineno': 2}], 'maintainability_index': 50.84140722617799, 'raw_metrics': {'loc': 27, 'lloc': 27, 'sloc': 27, 'comments': 0}}"
count-of-interesting-subarrays,"```python
from typing import List
from collections import defaultdict

class Solution:
    def countInterestingSubarrays(self, nums: List[int], modulo: int, k: int) -> int:
        prefix_counts = defaultdict(int)
        prefix_counts[0] = 1
        res = 0
        current = 0
        
        for num in nums:
            if num % modulo == k:
                current += 1
            key = current % modulo
            target = (key - k) % modulo
            res += prefix_counts.get(target, 0)
            prefix_counts[key] += 1
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 4}, {'name': 'countInterestingSubarrays', 'complexity': 3, 'lineno': 5}], 'maintainability_index': 58.812752326379005, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
stone-game-iii,"```python
class Solution:
    def stoneGameIII(self, stoneValue: List[int]) -> str:
        n = len(stoneValue)
        dp = [0] * (n + 1)
        
        for i in range(n - 1, -1, -1):
            dp[i] = -float('inf')
            take = 0
            for k in range(3):
                if i + k >= n:
                    break
                take += stoneValue[i + k]
                dp[i] = max(dp[i], take - dp[i + k + 1])
        
        if dp[0] > 0:
            return ""Alice""
        elif dp[0] < 0:
            return ""Bob""
        else:
            return ""Tie""
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 2}, {'name': 'stoneGameIII', 'complexity': 6, 'lineno': 3}], 'maintainability_index': 55.251517934552275, 'raw_metrics': {'loc': 19, 'lloc': 19, 'sloc': 19, 'comments': 0}}"
longest-nice-substring,"```python
class Solution:
    def longestNiceSubstring(self, s: str) -> str:
        if not s:
            return """"
        chars = set(s)
        for i, c in enumerate(s):
            if c.swapcase() not in chars:
                left = self.longestNiceSubstring(s[:i])
                right = self.longestNiceSubstring(s[i+1:])
                return max(left, right, key=lambda x: (len(x), -s.find(x)))
        return s
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 1}, {'name': 'longestNiceSubstring', 'complexity': 4, 'lineno': 2}], 'maintainability_index': 63.67309524815774, 'raw_metrics': {'loc': 11, 'lloc': 14, 'sloc': 11, 'comments': 0}}"
minimum-number-of-changes-to-make-binary-string-beautiful,"```python
class Solution:
    def minChanges(self, s: str) -> int:
        changes = 0
        for i in range(0, len(s), 2):
            if s[i] != s[i+1]:
                changes += 1
        return changes
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'minChanges', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 71.2064477082596, 'raw_metrics': {'loc': 7, 'lloc': 7, 'sloc': 7, 'comments': 0}}"
sum-in-a-matrix,"```python
from typing import List

class Solution:
    def matrixSum(self, nums: List[List[int]]) -> int:
        score = 0
        for row in nums:
            row.sort(reverse=True)
        for i in range(len(nums[0])):
            max_val = 0
            for row in nums:
                if i < len(row):
                    if row[i] > max_val:
                        max_val = row[i]
            score += max_val
        return score
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'matrixSum', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 63.380839204047774, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
cousins-in-binary-tree-ii,"```python
from collections import deque

class Solution:
    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None
        
        root.val = 0
        queue = deque([root])
        
        while queue:
            level_size = len(queue)
            level_sum = 0
            level_nodes = []
            parent_sum = {}
            
            for _ in range(level_size):
                node = queue.popleft()
                level_nodes.append(node)
                if node.left:
                    level_sum += node.left.val
                    queue.append(node.left)
                if node.right:
                    level_sum += node.right.val
                    queue.append(node.right)
                parent_sum[node] = (node.left.val if node.left else 0) + (node.right.val if node.right else 0)
            
            for node in level_nodes:
                total = level_sum - parent_sum.get(node, 0)
                if node.left:
                    node.left.val = total
                if node.right:
                    node.right.val = total
        
        return root
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 3}, {'name': 'replaceValueInTree', 'complexity': 11, 'lineno': 4}], 'maintainability_index': 54.630539809082194, 'raw_metrics': {'loc': 30, 'lloc': 30, 'sloc': 30, 'comments': 0}}"
count-the-number-of-arrays-with-k-matching-adjacent-elements,"```python
class Solution:
    def countGoodArrays(self, n: int, m: int, k: int) -> int:
        MOD = 10**9 + 7
        
        if k > n - 1:
            return 0
        
        
        
        max_n = n - 1
        fact = [1] * (max_n + 1)
        inv_fact = [1] * (max_n + 1)
        
        for i in range(1, max_n + 1):
            fact[i] = fact[i-1] * i % MOD
        
        inv_fact[max_n] = pow(fact[max_n], MOD-2, MOD)
        for i in range(max_n - 1, -1, -1):
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD
        
        def comb(a, b):
            if a < 0 or b < 0 or a < b:
                return 0
            return fact[a] * inv_fact[b] % MOD * inv_fact[a - b] % MOD
        
        c = comb(n - 1, k)
        res = c * m % MOD
        exponent = (n - 1 - k)
        res = res * pow(m - 1, exponent, MOD) % MOD
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 1}, {'name': 'countGoodArrays', 'complexity': 4, 'lineno': 2}], 'maintainability_index': 50.405698432892706, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
largest-element-in-an-array-after-merge-operations,"```python
class Solution:
    def maxArrayValue(self, nums: List[int]) -> int:
        stack = []
        for num in reversed(nums):
            if stack and stack[-1] >= num:
                stack[-1] += num
            else:
                stack.append(num)
        return max(stack) if stack else 0
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'maxArrayValue', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 65.92839118852774, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
maximum-prime-difference,"```python
class Solution:
    def maximumPrimeDifference(self, nums: List[int]) -> int:
        primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}
        prime_indices = []
        for i, num in enumerate(nums):
            if num in primes:
                prime_indices.append(i)
        if len(prime_indices) == 1:
            return 0
        return prime_indices[-1] - prime_indices[0]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'maximumPrimeDifference', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 65.66795629228119, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
kth-distinct-string-in-an-array,"```python
from typing import List

class Solution:
    def kthDistinct(self, arr: List[str], k: int) -> str:
        count = {}
        for s in arr:
            count[s] = count.get(s, 0) + 1
        distinct = []
        for s in arr:
            if count[s] == 1:
                distinct.append(s)
        return distinct[k-1] if k <= len(distinct) else """"
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'kthDistinct', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 64.58696869297872, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
sort-matrix-by-diagonals,"```python
from typing import List

class Solution:
    def sortMatrix(self, grid: List[List[int]]) -> List[List[int]]:
        n = len(grid)
        for d in range(n):
            diagonal = []
            i, j = d, 0
            while i < n and j < n:
                diagonal.append(grid[i][j])
                i += 1
                j += 1
            diagonal.sort(reverse=True)
            i, j = d, 0
            idx = 0
            while i < n and j < n:
                grid[i][j] = diagonal[idx]
                i += 1
                j += 1
                idx += 1
        
        for d in range(1, n):
            diagonal = []
            i, j = 0, d
            while i < n and j < n:
                diagonal.append(grid[i][j])
                i += 1
                j += 1
            diagonal.sort()
            i, j = 0, d
            idx = 0
            while i < n and j < n:
                grid[i][j] = diagonal[idx]
                i += 1
                j += 1
                idx += 1
        
        return grid
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 3}, {'name': 'sortMatrix', 'complexity': 11, 'lineno': 4}], 'maintainability_index': 47.4807355910235, 'raw_metrics': {'loc': 36, 'lloc': 36, 'sloc': 36, 'comments': 0}}"
latest-time-you-can-obtain-after-replacing-characters,"```python
class Solution:
    def findLatestTime(self, s: str) -> str:
        time = list(s)
        if time[0] == '?':
            if time[1] == '?':
                time[0] = '1'
                time[1] = '1'
            else:
                if int(time[1]) > 1:
                    time[0] = '0'
                else:
                    time[0] = '1'
        if time[1] == '?':
            if time[0] == '1':
                time[1] = '1'
            else:
                time[1] = '9'
        
        if time[3] == '?':
            time[3] = '5'
        if time[4] == '?':
            time[4] = '9'
        
        return ''.join(time)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 1}, {'name': 'findLatestTime', 'complexity': 8, 'lineno': 2}], 'maintainability_index': 56.36520813269541, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
minimum-cost-for-cutting-cake-ii,"```python
from typing import List

class Solution:
    def minimumCost(self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]) -> int:
        horizontalCut.sort(reverse=True)
        verticalCut.sort(reverse=True)
        
        h_pieces = 1
        v_pieces = 1
        total_cost = 0
        i = j = 0
        
        while i < len(horizontalCut) and j < len(verticalCut):
            if horizontalCut[i] > verticalCut[j]:
                total_cost += horizontalCut[i] * v_pieces
                h_pieces += 1
                i += 1
            else:
                total_cost += verticalCut[j] * h_pieces
                v_pieces += 1
                j += 1
        
        while i < len(horizontalCut):
            total_cost += horizontalCut[i] * v_pieces
            h_pieces += 1
            i += 1
        
        while j < len(verticalCut):
            total_cost += verticalCut[j] * h_pieces
            v_pieces += 1
            j += 1
        
        return total_cost
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'minimumCost', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 50.008410809893924, 'raw_metrics': {'loc': 28, 'lloc': 28, 'sloc': 28, 'comments': 0}}"
maximum-number-of-alloys,"```python
from typing import List

class Solution:
    def maxNumberOfAlloys(self, n: int, k: int, budget: int, composition: List[List[int]], stock: List[int], cost: List[int]) -> int:
        max_alloys = 0
        
        for machine in composition:
            left = 0
            right = budget + max(stock)  # Upper bound
            
            best = 0
            while left <= right:
                mid = (left + right) // 2
                total_cost = 0
                for i in range(n):
                    required = machine[i] * mid
                    needed = max(0, required - stock[i])
                    total_cost += needed * cost[i]
                    if total_cost > budget:
                        break
                
                if total_cost <= budget:
                    best = mid
                    left = mid + 1
                else:
                    right = mid - 1
            
            if best > max_alloys:
                max_alloys = best
        
        return max_alloys
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'maxNumberOfAlloys', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 63.88523144492797, 'raw_metrics': {'loc': 26, 'lloc': 26, 'sloc': 26, 'comments': 1}}"
largest-3-same-digit-number-in-string,"```python
class Solution:
    def largestGoodInteger(self, num: str) -> str:
        max_good = """"
        for i in range(len(num) - 2):
            substring = num[i:i+3]
            if len(set(substring)) == 1:
                if substring > max_good:
                    max_good = substring
        return max_good
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 1}, {'name': 'largestGoodInteger', 'complexity': 4, 'lineno': 2}], 'maintainability_index': 66.07457148659327, 'raw_metrics': {'loc': 9, 'lloc': 10, 'sloc': 9, 'comments': 0}}"
car-fleet-ii,"```python
class Solution:
    def getCollisionTimes(self, cars: List[List[int]]) -> List[float]:
        n = len(cars)
        res = [-1.0] * n
        stack = []
        
        for i in range(n-1, -1, -1):
            position, speed = cars[i]
            while stack:
                j = stack[-1]
                next_pos, next_speed = cars[j]
                if speed <= next_speed:
                    stack.pop()
                else:
                    collision_time = (next_pos - position) / (speed - next_speed)
                    if res[j] != -1 and collision_time >= res[j]:
                        stack.pop()
                    else:
                        res[i] = collision_time
                        break
            stack.append(i)
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 2}, {'name': 'getCollisionTimes', 'complexity': 6, 'lineno': 3}], 'maintainability_index': 54.20466697665955, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
count-common-words-with-one-occurrence,"```python
from typing import List
from collections import defaultdict

class Solution:
    def countWords(self, words1: List[str], words2: List[str]) -> int:
        count1 = defaultdict(int)
        count2 = defaultdict(int)
        
        for word in words1:
            count1[word] += 1
        
        for word in words2:
            count2[word] += 1
        
        result = 0
        for word in count1:
            if count1[word] == 1 and count2.get(word, 0) == 1:
                result += 1
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 4}, {'name': 'countWords', 'complexity': 6, 'lineno': 5}], 'maintainability_index': 60.22829659674131, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
minimum-time-to-repair-cars,"```python
import bisect
from typing import List

class Solution:
    def repairCars(self, ranks: List[int], cars: int) -> int:
        left = 0
        right = min(ranks) * cars * cars
        
        def can_repair(t):
            total = 0
            for r in ranks:
                total += int((t // r) ** 0.5)
                if total >= cars:
                    return True
            return total >= cars
        
        while left < right:
            mid = (left + right) // 2
            if can_repair(mid):
                right = mid
            else:
                left = mid + 1
        return left
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 4}, {'name': 'repairCars', 'complexity': 3, 'lineno': 5}], 'maintainability_index': 55.44022592684743, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
minimum-cost-to-make-all-characters-equal,"```python
class Solution:
    def minimumCost(self, s: str) -> int:
        n = len(s)
        res = 0
        for i in range(1, n):
            if s[i] != s[i-1]:
                res += min(i, n - i)
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'minimumCost', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 68.5547933003363, 'raw_metrics': {'loc': 8, 'lloc': 8, 'sloc': 8, 'comments': 0}}"
robot-collisions,"```python
from typing import List

class Solution:
    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:
        robots = sorted(zip(positions, healths, directions, range(len(positions))), key=lambda x: x[0])
        stack = []
        
        for pos, health, direction, idx in robots:
            if direction == 'R':
                stack.append((pos, health, direction, idx))
                continue
            while stack and stack[-1][2] == 'R':
                prev_pos, prev_health, prev_dir, prev_idx = stack.pop()
                if prev_health > health:
                    new_health = prev_health - 1
                    if new_health > 0:
                        stack.append((prev_pos, new_health, prev_dir, prev_idx))
                    health = 0
                    break
                elif prev_health < health:
                    health -= 1
                else:
                    health = 0
                    break
            if health > 0:
                stack.append((pos, health, direction, idx))
        
        stack.sort(key=lambda x: x[3])
        return [robot[1] for robot in stack]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 3}, {'name': 'survivedRobotsHealths', 'complexity': 10, 'lineno': 4}], 'maintainability_index': 52.16440851489242, 'raw_metrics': {'loc': 27, 'lloc': 29, 'sloc': 27, 'comments': 0}}"
generate-binary-strings-without-adjacent-zeros,"```python
from typing import List

class Solution:
    def validStrings(self, n: int) -> List[str]:
        def backtrack(current, last_char):
            if len(current) == n:
                result.append(current)
                return
            backtrack(current + '1', '1')
            if last_char != '0':
                backtrack(current + '0', '0')
        
        result = []
        backtrack("""", """")
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 3}, {'name': 'validStrings', 'complexity': 1, 'lineno': 4}], 'maintainability_index': 63.66460552736375, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
design-spreadsheet,"```python
class Spreadsheet:

    def __init__(self, rows: int):
        self.rows = rows
        self.cells = {}

    def setCell(self, cell: str, value: int) -> None:
        self.cells[cell] = value

    def resetCell(self, cell: str) -> None:
        self.cells[cell] = 0

    def getValue(self, formula: str) -> int:
        if not formula.startswith('='):
            return 0  # though per problem statement, formula always starts with '='
        expr = formula[1:]
        parts = expr.split('+')
        total = 0
        for part in parts:
            if part[0].isalpha():
                total += self.cells.get(part, 0)
            else:
                total += int(part)
        return total
```","{'cyclomatic_complexity': [{'name': 'Spreadsheet', 'complexity': 3, 'lineno': 1}, {'name': '__init__', 'complexity': 1, 'lineno': 2}, {'name': 'setCell', 'complexity': 1, 'lineno': 5}, {'name': 'resetCell', 'complexity': 1, 'lineno': 7}, {'name': 'getValue', 'complexity': 4, 'lineno': 9}], 'maintainability_index': 73.93781115783048, 'raw_metrics': {'loc': 20, 'lloc': 21, 'sloc': 20, 'comments': 1}}"
allocate-mailboxes,"```python
class Solution:
    def minDistance(self, houses: List[int], k: int) -> int:
        houses.sort()
        n = len(houses)
        
        cost = [[0] * n for _ in range(n)]
        for i in range(n):
            for j in range(i, n):
                median = houses[(i + j) // 2]
                total = 0
                for m in range(i, j + 1):
                    total += abs(houses[m] - median)
                cost[i][j] = total
        
        dp = [[float('inf')] * k for _ in range(n)]
        for i in range(n):
            dp[i][0] = cost[0][i]
        
        for l in range(1, k):
            for i in range(n):
                for j in range(i):
                    if dp[j][l-1] + cost[j+1][i] < dp[i][l]:
                        dp[i][l] = dp[j][l-1] + cost[j+1][i]
        
        return dp[n-1][k-1]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 2}, {'name': 'minDistance', 'complexity': 11, 'lineno': 3}], 'maintainability_index': 52.660837717682405, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
remove-nodes-from-linked-list,"```python
class Solution:
    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:
        stack = []
        current = head
        while current:
            while stack and stack[-1].val < current.val:
                stack.pop()
            stack.append(current)
            current = current.next
        
        dummy = ListNode()
        prev = dummy
        for node in stack:
            prev.next = node
            prev = node
        prev.next = None
        return dummy.next
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'removeNodes', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 62.88958222662132, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
count-number-of-distinct-integers-after-reverse-operations,"```python
class Solution:
    def countDistinctIntegers(self, nums: List[int]) -> int:
        distinct = set(nums)
        for num in nums:
            reversed_num = int(str(num)[::-1])
            distinct.add(reversed_num)
        return len(distinct)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 2}, {'name': 'countDistinctIntegers', 'complexity': 2, 'lineno': 3}], 'maintainability_index': 76.67286345511201, 'raw_metrics': {'loc': 8, 'lloc': 9, 'sloc': 8, 'comments': 0}}"
find-longest-awesome-substring,"```python
class Solution:
    def longestAwesome(self, s: str) -> int:
        mask = 0
        mask_dict = {0: -1}
        max_len = 1
        
        for i, ch in enumerate(s):
            digit = ord(ch) - ord('0')
            mask ^= 1 << digit
            
            if mask in mask_dict:
                max_len = max(max_len, i - mask_dict[mask])
            else:
                mask_dict[mask] = i
            
            for d in range(10):
                temp_mask = mask ^ (1 << d)
                if temp_mask in mask_dict:
                    max_len = max(max_len, i - mask_dict[temp_mask])
        
        return max_len
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 1}, {'name': 'longestAwesome', 'complexity': 5, 'lineno': 2}], 'maintainability_index': 57.22863704336789, 'raw_metrics': {'loc': 17, 'lloc': 18, 'sloc': 17, 'comments': 0}}"
find-the-score-of-all-prefixes-of-an-array,"```python
from typing import List

class Solution:
    def findPrefixScore(self, nums: List[int]) -> List[int]:
        max_so_far = 0
        total = 0
        ans = []
        for num in nums:
            max_so_far = max(max_so_far, num)
            total += num + max_so_far
            ans.append(total)
        return ans
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 3}, {'name': 'findPrefixScore', 'complexity': 2, 'lineno': 4}], 'maintainability_index': 68.04496717586133, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
partition-string-into-minimum-beautiful-substrings,"```python
class Solution:
    def minimumBeautifulSubstrings(self, s: str) -> int:
        power_of_5 = {1, 5, 25, 125, 625, 3125, 15625}
        n = len(s)
        dp = [float('inf')] * (n + 1)
        dp[0] = 0
        
        for i in range(1, n + 1):
            for j in range(i):
                if s[j] == '0':
                    continue
                substring = s[j:i]
                num = int(substring, 2)
                if num in power_of_5:
                    if dp[j] + 1 < dp[i]:
                        dp[i] = dp[j] + 1
        
        return dp[n] if dp[n] != float('inf') else -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 1}, {'name': 'minimumBeautifulSubstrings', 'complexity': 7, 'lineno': 2}], 'maintainability_index': 57.34312821213044, 'raw_metrics': {'loc': 16, 'lloc': 17, 'sloc': 16, 'comments': 0}}"
maximum-elegance-of-a-k-length-subsequence,"```python
class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        items.sort(reverse=True)
        res = 0
        total_profit = 0
        category_set = set()
        duplicate = []
        
        for i in range(k):
            profit, category = items[i]
            total_profit += profit
            if category in category_set:
                duplicate.append(profit)
            else:
                category_set.add(category)
        res = total_profit + len(category_set) ** 2
        
        for i in range(k, len(items)):
            if not duplicate:
                break
            profit, category = items[i]
            if category not in category_set:
                replaced_profit = duplicate.pop()
                total_profit = total_profit - replaced_profit + profit
                category_set.add(category)
                res = max(res, total_profit + len(category_set) ** 2)
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 2}, {'name': 'findMaximumElegance', 'complexity': 6, 'lineno': 3}], 'maintainability_index': 53.61042567609879, 'raw_metrics': {'loc': 26, 'lloc': 26, 'sloc': 26, 'comments': 0}}"
report-spam-message,"```python
class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned_set = set(bannedWords)
        count = 0
        for word in message:
            if word in banned_set:
                count += 1
                if count >= 2:
                    return True
        return False
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'reportSpam', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 66.58815489908999, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
minimum-operations-to-make-all-array-elements-equal,"```python
import bisect

class Solution:
    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:
        nums.sort()
        n = len(nums)
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i+1] = prefix[i] + nums[i]
        
        res = []
        for q in queries:
            idx = bisect.bisect_left(nums, q)
            left_sum = q * idx - prefix[idx]
            right_sum = (prefix[n] - prefix[idx]) - q * (n - idx)
            res.append(left_sum + right_sum)
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'minOperations', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 58.06255386694344, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
maximum-beauty-of-an-array-after-applying-operation,"```python
from typing import List

class Solution:
    def maximumBeauty(self, nums: List[int], k: int) -> int:
        nums.sort()
        left = 0
        max_len = 0
        for right in range(len(nums)):
            while nums[right] - nums[left] > 2 * k:
                left += 1
            max_len = max(max_len, right - left + 1)
        return max_len
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'maximumBeauty', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 63.065800399244104, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
maximum-star-sum-of-a-graph,"```python
from typing import List

class Solution:
    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:
        from collections import defaultdict
        
        if not edges:
            return max(vals)
        
        graph = defaultdict(list)
        for a, b in edges:
            if vals[b] > 0:
                graph[a].append(vals[b])
            if vals[a] > 0:
                graph[b].append(vals[a])
        
        max_sum = -float('inf')
        for node in range(len(vals)):
            neighbors = sorted(graph.get(node, []), reverse=True)
            current_sum = vals[node] + sum(neighbors[:k])
            if current_sum > max_sum:
                max_sum = current_sum
        
        return max_sum
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'maxStarSum', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 57.67095119620985, 'raw_metrics': {'loc': 20, 'lloc': 21, 'sloc': 20, 'comments': 0}}"
design-neighbor-sum-service,"```python
from typing import List

class NeighborSum:

    def __init__(self, grid: List[List[int]]):
        self.grid = grid
        self.n = len(grid)
        self.pos = {}
        for i in range(self.n):
            for j in range(self.n):
                self.pos[grid[i][j]] = (i, j)

    def adjacentSum(self, value: int) -> int:
        i, j = self.pos[value]
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        total = 0
        for di, dj in directions:
            ni, nj = i + di, j + dj
            if 0 <= ni < self.n and 0 <= nj < self.n:
                total += self.grid[ni][nj]
        return total

    def diagonalSum(self, value: int) -> int:
        i, j = self.pos[value]
        directions = [(-1, -1), (-1, 1), (1, -1), (1, 1)]
        total = 0
        for di, dj in directions:
            ni, nj = i + di, j + dj
            if 0 <= ni < self.n and 0 <= nj < self.n:
                total += self.grid[ni][nj]
        return total
```","{'cyclomatic_complexity': [{'name': 'NeighborSum', 'complexity': 5, 'lineno': 3}, {'name': '__init__', 'complexity': 3, 'lineno': 4}, {'name': 'adjacentSum', 'complexity': 4, 'lineno': 11}, {'name': 'diagonalSum', 'complexity': 4, 'lineno': 20}], 'maintainability_index': 49.71066454229902, 'raw_metrics': {'loc': 28, 'lloc': 28, 'sloc': 28, 'comments': 0}}"
count-pairs-that-form-a-complete-day-i,"```python
from typing import List

class Solution:
    def countCompleteDayPairs(self, hours: List[int]) -> int:
        count = 0
        n = len(hours)
        for i in range(n):
            for j in range(i + 1, n):
                if (hours[i] + hours[j]) % 24 == 0:
                    count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'countCompleteDayPairs', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 64.49306775579564, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
longest-substring-of-one-repeating-character,"```python
from typing import List

class Solution:
    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:
        s = list(s)
        n = len(s)
        k = len(queryCharacters)
        res = []
        
        class Node:
            __slots__ = ['left', 'right', 'l', 'r', 'max_len', 'left_char', 'right_char', 'left_len', 'right_len']
            def __init__(self, l, r):
                self.l = l
                self.r = r
                self.left = None
                self.right = None
                self.max_len = 0
                self.left_char = ''
                self.right_char = ''
                self.left_len = 0
                self.right_len = 0
        
        def build(l, r):
            node = Node(l, r)
            if l == r:
                node.max_len = 1
                node.left_char = s[l]
                node.right_char = s[l]
                node.left_len = 1
                node.right_len = 1
            else:
                mid = (l + r) // 2
                node.left = build(l, mid)
                node.right = build(mid+1, r)
                node = merge(node, node.left, node.right)
            return node
        
        def merge(parent, left, right):
            parent.max_len = max(left.max_len, right.max_len)
            parent.left_char = left.left_char
            parent.right_char = right.right_char
            
            if left.right_char == right.left_char:
                parent.max_len = max(parent.max_len, left.right_len + right.left_len)
            
            parent.left_len = left.left_len
            if left.left_len == (left.r - left.l + 1) and left.right_char == right.left_char:
                parent.left_len += right.left_len
            
            parent.right_len = right.right_len
            if right.right_len == (right.r - right.l + 1) and left.right_char == right.left_char:
                parent.right_len += left.right_len
            
            return parent
        
        def update(node, idx, char):
            if node.l == node.r:
                node.left_char = char
                node.right_char = char
                return
            if idx <= node.left.r:
                update(node.left, idx, char)
            else:
                update(node.right, idx, char)
            merge(node, node.left, node.right)
        
        root = build(0, n-1)
        
        for i in range(k):
            idx = queryIndices[i]
            char = queryCharacters[i]
            if s[idx] != char:
                s[idx] = char
                update(root, idx, char)
            res.append(root.max_len)
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'longestRepeating', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 42.058225678436436, 'raw_metrics': {'loc': 66, 'lloc': 66, 'sloc': 66, 'comments': 0}}"
count-ways-to-build-good-strings,"```python
class Solution:
    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:
        MOD = 10**9 + 7
        dp = [0] * (high + 1)
        dp[0] = 1
        for i in range(1, high + 1):
            if i >= zero:
                dp[i] += dp[i - zero]
            if i >= one:
                dp[i] += dp[i - one]
            dp[i] %= MOD
        total = 0
        for i in range(low, high + 1):
            total += dp[i]
            total %= MOD
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 1}, {'name': 'countGoodStrings', 'complexity': 5, 'lineno': 2}], 'maintainability_index': 56.681042837001485, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
determine-if-string-halves-are-alike,"```python
class Solution:
    def halvesAreAlike(self, s: str) -> bool:
        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}
        half = len(s) // 2
        a = s[:half]
        b = s[half:]
        count_a = sum(1 for char in a if char in vowels)
        count_b = sum(1 for char in b if char in vowels)
        return count_a == count_b
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 1}, {'name': 'halvesAreAlike', 'complexity': 5, 'lineno': 2}], 'maintainability_index': 65.41128700130152, 'raw_metrics': {'loc': 9, 'lloc': 11, 'sloc': 9, 'comments': 0}}"
find-all-people-with-secret,"```python
from collections import defaultdict, deque

class Solution:
    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:
        known = set([0, firstPerson])
        
        time_map = defaultdict(list)
        for x, y, time in meetings:
            time_map[time].append((x, y))
        
        for time in sorted(time_map.keys()):
            graph = defaultdict(list)
            current_meetings = time_map[time]
            participants = set()
            
            for x, y in current_meetings:
                graph[x].append(y)
                graph[y].append(x)
                participants.add(x)
                participants.add(y)
            
            queue = deque()
            for person in participants:
                if person in known:
                    queue.append(person)
            
            while queue:
                current = queue.popleft()
                for neighbor in graph[current]:
                    if neighbor not in known:
                        known.add(neighbor)
                        queue.append(neighbor)
        
        return list(known)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 3}, {'name': 'findAllPeople', 'complexity': 9, 'lineno': 4}], 'maintainability_index': 59.07641434646209, 'raw_metrics': {'loc': 28, 'lloc': 28, 'sloc': 28, 'comments': 0}}"
gcd-sort-of-an-array,"```python
import math
from collections import defaultdict

class Solution:
    def gcdSort(self, nums: List[int]) -> bool:
        parent = {}
        rank = defaultdict(int)
        
        def find(u):
            while parent[u] != u:
                parent[u] = parent[parent[u]]
                u = parent[u]
            return u
        
        def union(u, v):
            u_root = find(u)
            v_root = find(v)
            if u_root == v_root:
                return
            if rank[u_root] > rank[v_root]:
                parent[v_root] = u_root
            else:
                parent[u_root] = v_root
                if rank[u_root] == rank[v_root]:
                    rank[v_root] += 1
        
        max_num = max(nums) if nums else 0
        sieve = list(range(max_num + 1))
        for i in range(2, int(math.sqrt(max_num)) + 1):
            if sieve[i] == i:
                for j in range(i*i, max_num + 1, i):
                    if sieve[j] == j:
                        sieve[j] = i
        
        for num in nums:
            if num == 1:
                continue
            factors = []
            x = num
            while x > 1:
                p = sieve[x]
                factors.append(p)
                while x % p == 0:
                    x = x // p
            if not factors:
                continue
            parent.setdefault(factors[0], factors[0])
            for p in factors[1:]:
                parent.setdefault(p, p)
                union(factors[0], p)
        
        sorted_nums = sorted(nums)
        for a, b in zip(nums, sorted_nums):
            if a == b:
                continue
            if a == 1 or b == 1:
                return False
            a_factors = []
            x = a
            while x > 1:
                p = sieve[x]
                a_factors.append(p)
                while x % p == 0:
                    x = x // p
            b_factors = []
            x = b
            while x > 1:
                p = sieve[x]
                b_factors.append(p)
                while x % p == 0:
                    x = x // p
            if not a_factors or not b_factors:
                return False
            a_root = find(a_factors[0])
            b_root = find(b_factors[0])
            if a_root != b_root:
                return False
        return True
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 24, 'lineno': 4}, {'name': 'gcdSort', 'complexity': 23, 'lineno': 5}], 'maintainability_index': 37.084066722098605, 'raw_metrics': {'loc': 73, 'lloc': 73, 'sloc': 73, 'comments': 0}}"
remove-trailing-zeros-from-a-string,"```python
class Solution:
    def removeTrailingZeros(self, num: str) -> str:
        return num.rstrip('0') or num
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 1}, {'name': 'removeTrailingZeros', 'complexity': 2, 'lineno': 2}], 'maintainability_index': 84.44724042799471, 'raw_metrics': {'loc': 3, 'lloc': 3, 'sloc': 3, 'comments': 0}}"
maximum-square-area-by-removing-fences-from-a-field,"```python
from typing import List

class Solution:
    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:
        hFences = [1] + hFences + [m]
        vFences = [1] + vFences + [n]
        
        h_set = set()
        for i in range(len(hFences)):
            for j in range(i + 1, len(hFences)):
                h_set.add(abs(hFences[j] - hFences[i]))
        
        v_set = set()
        for i in range(len(vFences)):
            for j in range(i + 1, len(vFences)):
                v_set.add(abs(vFences[j] - vFences[i]))
        
        common = h_set & v_set
        if not common:
            return -1
        max_side = max(common)
        return (max_side * max_side) % (10**9 + 7)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'maximizeSquareArea', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 54.832029702479424, 'raw_metrics': {'loc': 19, 'lloc': 19, 'sloc': 19, 'comments': 0}}"
shortest-string-that-contains-three-strings,"```python
class Solution:
    def minimumString(self, a: str, b: str, c: str) -> str:
        def merge(s1, s2):
            if s2 in s1:
                return s1
            max_overlap = 0
            len_s1 = len(s1)
            len_s2 = len(s2)
            for overlap in range(min(len_s1, len_s2), -1, -1):
                if s1.endswith(s2[:overlap]):
                    max_overlap = overlap
                    break
            return s1 + s2[max_overlap:]
        
        candidates = []
        strings = [a, b, c]
        from itertools import permutations
        for perm in permutations(strings):
            s12 = merge(perm[0], perm[1])
            s123 = merge(s12, perm[2])
            candidates.append(s123)
        
        min_len = min(len(s) for s in candidates)
        min_candidates = [s for s in candidates if len(s) == min_len]
        return min(min_candidates)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 1}, {'name': 'minimumString', 'complexity': 5, 'lineno': 2}], 'maintainability_index': 57.634476834648694, 'raw_metrics': {'loc': 23, 'lloc': 24, 'sloc': 23, 'comments': 0}}"
number-of-adjacent-elements-with-the-same-color,"```python
from typing import List

class Solution:
    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:
        colors = [0] * n
        res = []
        count = 0
        for idx, color in queries:
            left = idx - 1
            right = idx + 1
            if left >= 0 and colors[left] == colors[idx] and colors[idx] != 0:
                count -= 1
            if right < n and colors[right] == colors[idx] and colors[idx] != 0:
                count -= 1
            colors[idx] = color
            if left >= 0 and colors[left] == colors[idx]:
                count += 1
            if right < n and colors[right] == colors[idx]:
                count += 1
            res.append(count)
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 13, 'lineno': 3}, {'name': 'colorTheArray', 'complexity': 12, 'lineno': 4}], 'maintainability_index': 51.718748631238036, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
finding-3-digit-even-numbers,"```python
from typing import List

class Solution:
    def findEvenNumbers(self, digits: List[int]) -> List[int]:
        from collections import defaultdict
        
        freq = defaultdict(int)
        for d in digits:
            freq[d] += 1
        
        result = set()
        
        for i in range(100, 1000, 2):
            a, b, c = map(int, str(i))
            temp_freq = defaultdict(int)
            temp_freq[a] += 1
            temp_freq[b] += 1
            temp_freq[c] += 1
            
            valid = True
            for d in temp_freq:
                if temp_freq[d] > freq[d]:
                    valid = False
                    break
            if valid:
                result.add(i)
        
        return sorted(result)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'findEvenNumbers', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 57.61043943080297, 'raw_metrics': {'loc': 23, 'lloc': 23, 'sloc': 23, 'comments': 0}}"
sum-of-distances,"```python
from typing import List
from collections import defaultdict

class Solution:
    def distance(self, nums: List[int]) -> List[int]:
        num_indices = defaultdict(list)
        for idx, num in enumerate(nums):
            num_indices[num].append(idx)
        
        res = [0] * len(nums)
        for indices in num_indices.values():
            n = len(indices)
            if n == 1:
                continue
            prefix = [0] * (n + 1)
            for i in range(n):
                prefix[i+1] = prefix[i] + indices[i]
            for i in range(n):
                left_sum = indices[i] * i - prefix[i]
                right_sum = (prefix[n] - prefix[i+1]) - indices[i] * (n - 1 - i)
                res[indices[i]] = left_sum + right_sum
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 4}, {'name': 'distance', 'complexity': 6, 'lineno': 5}], 'maintainability_index': 53.970325766337744, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
right-triangles,"```python
from typing import List

class Solution:
    def numberOfRightTriangles(self, grid: List[List[int]]) -> int:
        rows = len(grid)
        cols = len(grid[0]) if rows > 0 else 0
        
        row_counts = [0] * rows
        col_counts = [0] * cols
        
        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == 1:
                    row_counts[i] += 1
                    col_counts[j] += 1
        
        count = 0
        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == 1:
                    count += (row_counts[i] - 1) * (col_counts[j] - 1)
        
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 3}, {'name': 'numberOfRightTriangles', 'complexity': 8, 'lineno': 4}], 'maintainability_index': 55.76198418143941, 'raw_metrics': {'loc': 19, 'lloc': 19, 'sloc': 19, 'comments': 0}}"
smallest-subarrays-with-maximum-bitwise-or,"```python
class Solution:
    def smallestSubarrays(self, nums: List[int]) -> List[int]:
        n = len(nums)
        answer = [1] * n
        bits = [0] * 32
        left = n - 1
        
        for i in range(n - 1, -1, -1):
            num = nums[i]
            for j in range(32):
                if num & (1 << j):
                    bits[j] = i
            max_or_pos = max(bits)
            answer[i] = max_or_pos - i + 1 if max_or_pos != 0 else 1
        
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'smallestSubarrays', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 58.69673154051576, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
find-valid-pair-of-adjacent-digits-in-string,"```python
class Solution:
    def findValidPair(self, s: str) -> str:
        from collections import defaultdict
        
        count = defaultdict(int)
        for ch in s:
            count[ch] += 1
        
        for i in range(len(s) - 1):
            first = s[i]
            second = s[i+1]
            if first != second:
                if int(first) == count[first] and int(second) == count[second]:
                    return first + second
        return """"
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 1}, {'name': 'findValidPair', 'complexity': 6, 'lineno': 2}], 'maintainability_index': 60.813294371614184, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
first-completely-painted-row-or-column,"```python
from typing import List

class Solution:
    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:
        m = len(mat)
        n = len(mat[0]) if m > 0 else 0
        
        value_to_pos = {}
        for r in range(m):
            for c in range(n):
                value_to_pos[mat[r][c]] = (r, c)
        
        row_counts = [0] * m
        col_counts = [0] * n
        
        for i in range(len(arr)):
            val = arr[i]
            r, c = value_to_pos[val]
            row_counts[r] += 1
            if row_counts[r] == n:
                return i
            col_counts[c] += 1
            if col_counts[c] == m:
                return i
        
        return -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'firstCompleteIndex', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 55.96157011835777, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
minimum-score-of-a-path-between-two-cities,"```python
from typing import List
from collections import deque

class Solution:
    def minScore(self, n: int, roads: List[List[int]]) -> int:
        graph = [[] for _ in range(n + 1)]
        for a, b, d in roads:
            graph[a].append((b, d))
            graph[b].append((a, d))
        
        visited = [False] * (n + 1)
        queue = deque()
        queue.append(1)
        visited[1] = True
        min_score = float('inf')
        
        while queue:
            node = queue.popleft()
            for neighbor, d in graph[node]:
                min_score = min(min_score, d)
                if not visited[neighbor]:
                    visited[neighbor] = True
                    queue.append(neighbor)
        
        return min_score
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 4}, {'name': 'minScore', 'complexity': 6, 'lineno': 5}], 'maintainability_index': 59.142264874836, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
minimum-operations-to-make-columns-strictly-increasing,"```python
from typing import List

class Solution:
    def minimumOperations(self, grid: List[List[int]]) -> int:
        if not grid or not grid[0]:
            return 0
        
        m, n = len(grid), len(grid[0])
        operations = 0
        
        for j in range(n):
            for i in range(1, m):
                if grid[i][j] <= grid[i-1][j]:
                    diff = grid[i-1][j] - grid[i][j] + 1
                    operations += diff
                    grid[i][j] += diff
        
        return operations
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'minimumOperations', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 58.871743242510895, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
check-if-digits-are-equal-in-string-after-operations-i,"```python
class Solution:
    def hasSameDigits(self, s: str) -> bool:
        while len(s) > 2:
            new_s = []
            for i in range(len(s) - 1):
                new_digit = (int(s[i]) + int(s[i+1])) % 10
                new_s.append(str(new_digit))
            s = ''.join(new_s)
        return s[0] == s[1]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'hasSameDigits', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 65.6411099580525, 'raw_metrics': {'loc': 9, 'lloc': 9, 'sloc': 9, 'comments': 0}}"
number-of-ways-to-reconstruct-a-tree,"```python
from collections import defaultdict

class Solution:
    def checkWays(self, pairs: List[List[int]]) -> int:
        adj = defaultdict(set)
        nodes = set()
        for x, y in pairs:
            adj[x].add(y)
            adj[y].add(x)
            nodes.add(x)
            nodes.add(y)
        
        root = -1
        for node in nodes:
            if len(adj[node]) == len(nodes) - 1:
                root = node
                break
        if root == -1:
            return 0
        
        res = 1
        for node in nodes:
            if node == root:
                continue
            parent = -1
            parent_degree = float('inf')
            for neighbor in adj[node]:
                if len(adj[neighbor]) < parent_degree and len(adj[neighbor]) >= len(adj[node]):
                    parent = neighbor
                    parent_degree = len(adj[neighbor])
            if parent == -1:
                return 0
            for neighbor in adj[node]:
                if neighbor != parent and neighbor not in adj[parent]:
                    return 0
            if parent_degree == len(adj[node]):
                res = 2
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 16, 'lineno': 3}, {'name': 'checkWays', 'complexity': 15, 'lineno': 4}], 'maintainability_index': 47.61663309560416, 'raw_metrics': {'loc': 36, 'lloc': 36, 'sloc': 36, 'comments': 0}}"
building-boxes,"```python
class Solution:
    def minimumBoxes(self, n: int) -> int:
        if n == 0:
            return 0
        
        k = 0
        total = 0
        while True:
            next_total = (k + 1) * (k + 2) * (k + 3) // 6
            if next_total > n:
                break
            k += 1
            total = next_total
        
        remaining = n - total
        if remaining == 0:
            return k * (k + 1) // 2
        
        m = int((2 * remaining) ** 0.5)
        while m * (m + 1) // 2 < remaining:
            m += 1
        
        return k * (k + 1) // 2 + m
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 1}, {'name': 'minimumBoxes', 'complexity': 6, 'lineno': 2}], 'maintainability_index': 53.087659803332244, 'raw_metrics': {'loc': 19, 'lloc': 19, 'sloc': 19, 'comments': 0}}"
taking-maximum-energy-from-the-mystic-dungeon,"```python
from typing import List

class Solution:
    def maximumEnergy(self, energy: List[int], k: int) -> int:
        n = len(energy)
        max_energy = -float('inf')
        
        for i in range(n - 1, n - k - 1, -1):
            current_sum = 0
            for j in range(i, -1, -k):
                current_sum += energy[j]
                if current_sum > max_energy:
                    max_energy = current_sum
        
        return max_energy
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'maximumEnergy', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 61.61062035892816, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
minimum-total-cost-to-make-arrays-unequal,"```python
from collections import defaultdict

class Solution:
    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        swap_indices = []
        freq = defaultdict(int)
        total_cost = 0
        max_freq_val = -1
        max_freq = 0
        
        for i in range(n):
            if nums1[i] == nums2[i]:
                swap_indices.append(i)
                val = nums1[i]
                freq[val] += 1
                if freq[val] > max_freq:
                    max_freq = freq[val]
                    max_freq_val = val
        
        if not swap_indices:
            return 0
        
        required = 2 * max_freq - len(swap_indices)
        if required <= 0:
            return sum(swap_indices)
        
        extra_needed = required
        for i in range(n):
            if nums1[i] != nums2[i] and nums1[i] != max_freq_val and nums2[i] != max_freq_val:
                swap_indices.append(i)
                extra_needed -= 1
                if extra_needed == 0:
                    break
        
        if extra_needed > 0:
            return -1
        
        return sum(swap_indices)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 13, 'lineno': 3}, {'name': 'minimumTotalCost', 'complexity': 12, 'lineno': 4}], 'maintainability_index': 48.617789746486615, 'raw_metrics': {'loc': 33, 'lloc': 33, 'sloc': 33, 'comments': 0}}"
maximize-win-from-two-segments,"```python
from typing import List

class Solution:
    def maximizeWin(self, prizePositions: List[int], k: int) -> int:
        n = len(prizePositions)
        if n == 0:
            return 0
        
        left = 0
        dp = [0] * (n + 1)
        res = 0
        
        for right in range(n):
            while prizePositions[right] - prizePositions[left] > k:
                left += 1
            current_prizes = right - left + 1
            dp[right + 1] = max(dp[right], current_prizes)
            res = max(res, current_prizes + dp[left])
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'maximizeWin', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 57.74519011526702, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
naming-a-company,"```python
from collections import defaultdict
from typing import List

class Solution:
    def distinctNames(self, ideas: List[str]) -> int:
        initial_groups = defaultdict(set)
        for idea in ideas:
            initial = idea[0]
            suffix = idea[1:]
            initial_groups[initial].add(suffix)
        
        initials = list(initial_groups.keys())
        res = 0
        n = len(initials)
        
        for i in range(n):
            set1 = initial_groups[initials[i]]
            for j in range(i + 1, n):
                set2 = initial_groups[initials[j]]
                common = len(set1 & set2)
                res += 2 * (len(set1) - common) * (len(set2) - common)
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 4}, {'name': 'distinctNames', 'complexity': 4, 'lineno': 5}], 'maintainability_index': 56.94503667652937, 'raw_metrics': {'loc': 20, 'lloc': 21, 'sloc': 20, 'comments': 0}}"
hash-divided-string,"```python
class Solution:
    def stringHash(self, s: str, k: int) -> str:
        result = []
        n = len(s)
        for i in range(0, n, k):
            substring = s[i:i+k]
            total = sum(ord(c) - ord('a') for c in substring)
            hashed_char = chr(ord('a') + (total % 26))
            result.append(hashed_char)
        return ''.join(result)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'stringHash', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 65.414526095638, 'raw_metrics': {'loc': 10, 'lloc': 11, 'sloc': 10, 'comments': 0}}"
paths-in-matrix-whose-sum-is-divisible-by-k,"```python
class Solution:
    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:
        m, n = len(grid), len(grid[0])
        MOD = 10**9 + 7
        
        dp = [[[0] * k for _ in range(n)] for __ in range(m)]
        dp[0][0][grid[0][0] % k] = 1
        
        for i in range(m):
            for j in range(n):
                if i == 0 and j == 0:
                    continue
                current_val = grid[i][j]
                for rem in range(k):
                    new_rem = (rem + current_val) % k
                    if i > 0:
                        dp[i][j][new_rem] += dp[i-1][j][rem]
                    if j > 0:
                        dp[i][j][new_rem] += dp[i][j-1][rem]
                    dp[i][j][new_rem] %= MOD
        
        return dp[m-1][n-1][0]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 2}, {'name': 'numberOfPaths', 'complexity': 10, 'lineno': 3}], 'maintainability_index': 53.11540525241743, 'raw_metrics': {'loc': 20, 'lloc': 20, 'sloc': 20, 'comments': 0}}"
minimum-time-to-finish-the-race,"```python
class Solution:
    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:
        max_consecutive_laps = 0
        min_time_no_change = [float('inf')] * (numLaps + 1)
        
        for f, r in tires:
            total = 0
            time = f
            for lap in range(1, numLaps + 1):
                total += time
                if total >= (1 << 20):  # Prevent overflow and early termination
                    break
                if total < min_time_no_change[lap]:
                    min_time_no_change[lap] = total
                time *= r
        
        dp = [float('inf')] * (numLaps + 1)
        dp[0] = 0
        
        for lap in range(1, numLaps + 1):
            for prev_laps in range(max(0, lap - 20), lap):
                current_time = dp[prev_laps] + changeTime + min_time_no_change[lap - prev_laps]
                if current_time < dp[lap]:
                    dp[lap] = current_time
        
        return dp[numLaps] - changeTime  # Subtract the initial changeTime which is not needed
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 2}, {'name': 'minimumFinishTime', 'complexity': 8, 'lineno': 3}], 'maintainability_index': 69.16202908756576, 'raw_metrics': {'loc': 23, 'lloc': 23, 'sloc': 23, 'comments': 2}}"
design-a-text-editor,"```python
class TextEditor:

    def __init__(self):
        self.left = []
        self.right = []

    def addText(self, text: str) -> None:
        for c in text:
            self.left.append(c)

    def deleteText(self, k: int) -> int:
        deleted = 0
        while k > 0 and self.left:
            self.left.pop()
            deleted += 1
            k -= 1
        return deleted

    def cursorLeft(self, k: int) -> str:
        while k > 0 and self.left:
            self.right.append(self.left.pop())
            k -= 1
        return ''.join(self.left[-10:])

    def cursorRight(self, k: int) -> str:
        while k > 0 and self.right:
            self.left.append(self.right.pop())
            k -= 1
        return ''.join(self.left[-10:])
```","{'cyclomatic_complexity': [{'name': 'TextEditor', 'complexity': 3, 'lineno': 1}, {'name': '__init__', 'complexity': 1, 'lineno': 2}, {'name': 'addText', 'complexity': 2, 'lineno': 5}, {'name': 'deleteText', 'complexity': 3, 'lineno': 8}, {'name': 'cursorLeft', 'complexity': 3, 'lineno': 15}, {'name': 'cursorRight', 'complexity': 3, 'lineno': 20}], 'maintainability_index': 52.07216536625173, 'raw_metrics': {'loc': 24, 'lloc': 26, 'sloc': 24, 'comments': 0}}"
number-of-ways-to-reorder-array-to-get-same-bst,"```python
import math
from typing import List

class Solution:
    def numOfWays(self, nums: List[int]) -> int:
        mod = 10**9 + 7
        
        def dfs(nums):
            if len(nums) <= 2:
                return 1
            root = nums[0]
            left = [x for x in nums if x < root]
            right = [x for x in nums if x > root]
            m = len(left)
            n = len(right)
            left_ways = dfs(left)
            right_ways = dfs(right)
            return math.comb(m + n, m) * left_ways * right_ways % mod
        
        return (dfs(nums) - 1) % mod
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 4}, {'name': 'numOfWays', 'complexity': 1, 'lineno': 5}], 'maintainability_index': 56.94115420777981, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
number-of-ways-to-divide-a-long-corridor,"```python
class Solution:
    def numberOfWays(self, corridor: str) -> int:
        MOD = 10**9 + 7
        seats = []
        for i, c in enumerate(corridor):
            if c == 'S':
                seats.append(i)
        if len(seats) % 2 != 0 or len(seats) == 0:
            return 0
        if len(seats) == 2:
            return 1
        res = 1
        for i in range(1, len(seats) // 2):
            res *= (seats[2*i] - seats[2*i - 1])
            res %= MOD
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 1}, {'name': 'numberOfWays', 'complexity': 7, 'lineno': 2}], 'maintainability_index': 56.18733368903657, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
find-longest-special-substring-that-occurs-thrice-ii,"```python
class Solution:
    def maximumLength(self, s: str) -> int:
        from collections import defaultdict

        char_length_counts = defaultdict(list)
        
        n = len(s)
        if n < 3:
            return -1
        
        current_char = s[0]
        current_length = 1
        
        for i in range(1, n):
            if s[i] == current_char:
                current_length += 1
            else:
                for l in range(1, current_length + 1):
                    char_length_counts[current_char].append(l)
                current_char = s[i]
                current_length = 1
        
        for l in range(1, current_length + 1):
            char_length_counts[current_char].append(l)
        
        max_len = -1
        
        for char in char_length_counts:
            lengths = char_length_counts[char]
            if len(lengths) < 3:
                continue
            lengths.sort(reverse=True)
            candidate = lengths[2]
            if candidate > max_len:
                max_len = candidate
        
        return max_len
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 1}, {'name': 'maximumLength', 'complexity': 9, 'lineno': 2}], 'maintainability_index': 52.900346675577495, 'raw_metrics': {'loc': 29, 'lloc': 29, 'sloc': 29, 'comments': 0}}"
palindrome-partitioning-iv,"```python
class Solution:
    def checkPartitioning(self, s: str) -> bool:
        n = len(s)
        dp = [[False] * n for _ in range(n)]
        
        for i in range(n-1, -1, -1):
            for j in range(i, n):
                if s[i] == s[j]:
                    if j - i <= 2 or dp[i+1][j-1]:
                        dp[i][j] = True
        
        for i in range(1, n-1):
            for j in range(i, n-1):
                if dp[0][i-1] and dp[i][j] and dp[j+1][n-1]:
                    return True
        return False
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 13, 'lineno': 1}, {'name': 'checkPartitioning', 'complexity': 12, 'lineno': 2}], 'maintainability_index': 56.99555139005542, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
subarrays-distinct-element-sum-of-squares-i,"```python
class Solution:
    def sumCounts(self, nums: List[int]) -> int:
        total = 0
        n = len(nums)
        for i in range(n):
            distinct = set()
            for j in range(i, n):
                distinct.add(nums[j])
                total += len(distinct) ** 2
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'sumCounts', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 68.40845037051814, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
maximize-palindrome-length-from-subsequences,"```python
class Solution:
    def longestPalindrome(self, word1: str, word2: str) -> int:
        s = word1 + word2
        n = len(s)
        m1 = len(word1)
        dp = [[0] * n for _ in range(n)]
        max_len = 0
        
        for i in range(n-1, -1, -1):
            dp[i][i] = 1
            for j in range(i+1, n):
                if s[i] == s[j]:
                    dp[i][j] = 2 + dp[i+1][j-1] if i+1 <= j-1 else 2
                    if i < m1 and j >= m1:
                        max_len = max(max_len, dp[i][j])
                else:
                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])
        
        return max_len
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 1}, {'name': 'longestPalindrome', 'complexity': 8, 'lineno': 2}], 'maintainability_index': 55.263533326332485, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
minimum-degree-of-a-connected-trio-in-a-graph,"```python
class Solution:
    def minTrioDegree(self, n: int, edges: List[List[int]]) -> int:
        graph = [set() for _ in range(n + 1)]
        degree = [0] * (n + 1)
        
        for u, v in edges:
            graph[u].add(v)
            graph[v].add(u)
            degree[u] += 1
            degree[v] += 1
        
        min_degree = float('inf')
        
        for u in range(1, n + 1):
            neighbors = graph[u]
            for v in neighbors:
                if v <= u:
                    continue
                common_neighbors = neighbors & graph[v]
                for w in common_neighbors:
                    if w <= v:
                        continue
                    trio_degree = degree[u] + degree[v] + degree[w] - 6
                    if trio_degree < min_degree:
                        min_degree = trio_degree
                        if min_degree == 0:
                            return 0
        
        return min_degree if min_degree != float('inf') else -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 2}, {'name': 'minTrioDegree', 'complexity': 11, 'lineno': 3}], 'maintainability_index': 50.974700676308196, 'raw_metrics': {'loc': 26, 'lloc': 26, 'sloc': 26, 'comments': 0}}"
find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows,"```python
import heapq

class Solution:
    def kthSmallest(self, mat: List[List[int]], k: int) -> int:
        m = len(mat)
        n = len(mat[0]) if m > 0 else 0
        
        min_heap = []
        initial_sum = sum(row[0] for row in mat)
        indices = tuple([0] * m)
        heapq.heappush(min_heap, (initial_sum, indices))
        
        visited = set()
        visited.add(indices)
        
        count = 0
        while min_heap and count < k:
            current_sum, current_indices = heapq.heappop(min_heap)
            count += 1
            if count == k:
                return current_sum
            
            for i in range(m):
                if current_indices[i] + 1 < n:
                    new_indices = list(current_indices)
                    new_indices[i] += 1
                    new_indices_tuple = tuple(new_indices)
                    if new_indices_tuple not in visited:
                        new_sum = current_sum - mat[i][current_indices[i]] + mat[i][new_indices[i]]
                        heapq.heappush(min_heap, (new_sum, new_indices_tuple))
                        visited.add(new_indices_tuple)
        
        return -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 3}, {'name': 'kthSmallest', 'complexity': 9, 'lineno': 4}], 'maintainability_index': 51.28370708355488, 'raw_metrics': {'loc': 28, 'lloc': 28, 'sloc': 28, 'comments': 0}}"
find-common-elements-between-two-arrays,"```python
class Solution:
    def findIntersectionValues(self, nums1: List[int], nums2: List[int]) -> List[int]:
        set1 = set(nums1)
        set2 = set(nums2)
        answer1 = sum(1 for num in nums1 if num in set2)
        answer2 = sum(1 for num in nums2 if num in set1)
        return [answer1, answer2]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'findIntersectionValues', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 71.93656868180646, 'raw_metrics': {'loc': 8, 'lloc': 8, 'sloc': 8, 'comments': 0}}"
sum-of-matrix-after-queries,"```python
class Solution:
    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:
        row_seen = set()
        col_seen = set()
        total = 0
        row_sum = 0
        col_sum = 0
        for type_i, index_i, val_i in reversed(queries):
            if type_i == 0:  # row operation
                if index_i not in row_seen:
                    row_seen.add(index_i)
                    cnt = n - len(col_seen)
                    total += cnt * val_i
            else:  # column operation
                if index_i not in col_seen:
                    col_seen.add(index_i)
                    cnt = n - len(row_seen)
                    total += cnt * val_i
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'matrixSumQueries', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 74.26522954813797, 'raw_metrics': {'loc': 20, 'lloc': 20, 'sloc': 20, 'comments': 2}}"
find-a-value-of-a-mysterious-function-closest-to-target,"```python
class Solution:
    def closestToTarget(self, arr: List[int], target: int) -> int:
        result = float('inf')
        current_ands = set()
        
        for num in arr:
            next_ands = set()
            next_ands.add(num)
            for val in current_ands:
                next_ands.add(val & num)
            for val in next_ands:
                result = min(result, abs(val - target))
            current_ands = next_ands
        
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'closestToTarget', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 66.31558646638672, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
neither-minimum-nor-maximum,"```python
from typing import List

class Solution:
    def findNonMinOrMax(self, nums: List[int]) -> int:
        if len(nums) <= 2:
            return -1
        min_val = min(nums)
        max_val = max(nums)
        for num in nums:
            if num != min_val and num != max_val:
                return num
        return -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'findNonMinOrMax', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 63.337989032317644, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
minimum-processing-time,"```python
from typing import List

class Solution:
    def minProcessingTime(self, processorTime: List[int], tasks: List[int]) -> int:
        processorTime.sort()
        tasks.sort(reverse=True)
        max_time = 0
        for i in range(len(processorTime)):
            start_time = processorTime[i]
            current_max = start_time + tasks[4*i]
            if current_max > max_time:
                max_time = current_max
            current_max = start_time + tasks[4*i + 1]
            if current_max > max_time:
                max_time = current_max
            current_max = start_time + tasks[4*i + 2]
            if current_max > max_time:
                max_time = current_max
            current_max = start_time + tasks[4*i + 3]
            if current_max > max_time:
                max_time = current_max
        return max_time
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'minProcessingTime', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 53.85695757122587, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
sum-of-digit-differences-of-all-pairs,"```python
from typing import List

class Solution:
    def sumDigitDifferences(self, nums: List[int]) -> int:
        digit_counts = []
        num_strs = [str(num) for num in nums]
        length = len(num_strs[0])
        
        for i in range(length):
            freq = {}
            for num in num_strs:
                d = num[i]
                freq[d] = freq.get(d, 0) + 1
            digit_counts.append(freq)
        
        total = 0
        n = len(nums)
        for i in range(length):
            freq = digit_counts[i]
            s = 0
            for count in freq.values():
                s += count * (n - count)
            total += s // 2
        
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'sumDigitDifferences', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 56.91995243559548, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
longest-path-with-different-adjacent-characters,"```python
from typing import List

class Solution:
    def longestPath(self, parent: List[int], s: str) -> int:
        n = len(parent)
        children = [[] for _ in range(n)]
        for i in range(1, n):
            children[parent[i]].append(i)
        
        res = 1
        
        def dfs(node):
            nonlocal res
            max1 = max2 = 0
            for child in children[node]:
                path_len = dfs(child)
                if s[child] != s[node]:
                    if path_len > max1:
                        max2 = max1
                        max1 = path_len
                    elif path_len > max2:
                        max2 = path_len
            res = max(res, max1 + max2 + 1)
            return max1 + 1
        
        dfs(0)
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'longestPath', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 56.913894096484924, 'raw_metrics': {'loc': 24, 'lloc': 24, 'sloc': 24, 'comments': 0}}"
maximum-number-of-events-that-can-be-attended-ii,"```python
import bisect
from typing import List

class Solution:
    def maxValue(self, events: List[List[int]], k: int) -> int:
        events.sort()
        n = len(events)
        starts = [event[0] for event in events]
        
        dp = [[-1] * (k + 1) for _ in range(n)]
        
        def dfs(cur_index, count):
            if count == 0 or cur_index == n:
                return 0
            if dp[cur_index][count] != -1:
                return dp[cur_index][count]
            
            max_val = dfs(cur_index + 1, count)
            
            next_index = bisect.bisect_right(starts, events[cur_index][1])
            current_value = events[cur_index][2]
            max_val = max(max_val, current_value + dfs(next_index, count - 1))
            
            dp[cur_index][count] = max_val
            return max_val
        
        return dfs(0, k)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 4}, {'name': 'maxValue', 'complexity': 3, 'lineno': 5}], 'maintainability_index': 55.630346310650324, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
count-vowel-strings-in-ranges,"```python
class Solution:
    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:
        vowels = {'a', 'e', 'i', 'o', 'u'}
        prefix = [0] * (len(words) + 1)
        for i in range(len(words)):
            word = words[i]
            if word and word[0] in vowels and word[-1] in vowels:
                prefix[i+1] = prefix[i] + 1
            else:
                prefix[i+1] = prefix[i]
        
        ans = []
        for l, r in queries:
            ans.append(prefix[r+1] - prefix[l])
        return ans
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 2}, {'name': 'vowelStrings', 'complexity': 6, 'lineno': 3}], 'maintainability_index': 58.27046266368533, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
find-occurrences-of-an-element-in-an-array,"```python
from typing import List

class Solution:
    def occurrencesOfElement(self, nums: List[int], queries: List[int], x: int) -> List[int]:
        indices = [i for i, num in enumerate(nums) if num == x]
        answer = []
        for q in queries:
            if q <= len(indices):
                answer.append(indices[q-1])
            else:
                answer.append(-1)
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'occurrencesOfElement', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 64.85156469318109, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
maximum-genetic-difference-query,"```python
class Solution:
    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:
        from collections import defaultdict, deque

        tree = defaultdict(list)
        root = -1
        for i, p in enumerate(parents):
            if p == -1:
                root = i
            else:
                tree[p].append(i)
        
        query_map = defaultdict(list)
        for idx, (node, val) in enumerate(queries):
            query_map[node].append((val, idx))
        
        ans = [0] * len(queries)
        
        class TrieNode:
            __slots__ = ['children', 'count']
            def __init__(self):
                self.children = [None, None]
                self.count = 0
        
        root_trie = TrieNode()
        
        def insert(num):
            node = root_trie
            for i in range(17, -1, -1):
                bit = (num >> i) & 1
                if not node.children[bit]:
                    node.children[bit] = TrieNode()
                node = node.children[bit]
                node.count += 1
        
        def remove(num):
            node = root_trie
            for i in range(17, -1, -1):
                bit = (num >> i) & 1
                node = node.children[bit]
                node.count -= 1
        
        def query(num):
            res = 0
            node = root_trie
            for i in range(17, -1, -1):
                bit = (num >> i) & 1
                toggled_bit = 1 - bit
                if node.children[toggled_bit] and node.children[toggled_bit].count > 0:
                    res |= (1 << i)
                    node = node.children[toggled_bit]
                else:
                    node = node.children[bit]
            return res
        
        stack = [(root, True)]
        
        while stack:
            node, is_entering = stack.pop()
            if is_entering:
                insert(node)
                stack.append((node, False))
                for child in reversed(tree[node]):
                    stack.append((child, True))
            else:
                if node in query_map:
                    for val, idx in query_map[node]:
                        ans[idx] = query(val)
                remove(node)
        
        return ans
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 2}, {'name': 'maxGeneticDifference', 'complexity': 9, 'lineno': 3}], 'maintainability_index': 41.84547806327636, 'raw_metrics': {'loc': 61, 'lloc': 61, 'sloc': 61, 'comments': 0}}"
stone-game-iv,"```python
class Solution:
    def winnerSquareGame(self, n: int) -> bool:
        dp = [False] * (n + 1)
        for i in range(1, n + 1):
            j = 1
            while j * j <= i:
                if not dp[i - j * j]:
                    dp[i] = True
                    break
                j += 1
        return dp[n]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 1}, {'name': 'winnerSquareGame', 'complexity': 4, 'lineno': 2}], 'maintainability_index': 62.6373883820396, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
separate-squares-ii,"```python
class Solution:
    def separateSquares(self, squares: List[List[int]]) -> float:
        events = []
        for x, y, l in squares:
            top = y + l
            events.append((y, 1, x, x + l))
            events.append((top, -1, x, x + l))
        
        events.sort()
        
        active_intervals = []
        total_area = 0
        prev_y = None
        
        for y, typ, x1, x2 in events:
            if prev_y is not None and y != prev_y and active_intervals:
                delta_y = y - prev_y
                merged = []
                for interval in sorted(active_intervals):
                    if not merged:
                        merged.append(interval)
                    else:
                        last_x1, last_x2 = merged[-1]
                        if interval[0] <= last_x2:
                            merged[-1] = (last_x1, max(last_x2, interval[1]))
                        else:
                            merged.append(interval)
                current_width = 0
                for (start, end) in merged:
                    current_width += end - start
                total_area += current_width * delta_y
            
            if typ == 1:
                active_intervals.append((x1, x2))
            else:
                active_intervals.remove((x1, x2))
            
            prev_y = y
        
        target = total_area / 2
        
        events = []
        for x, y, l in squares:
            top = y + l
            events.append((y, 1, x, x + l))
            events.append((top, -1, x, x + l))
        
        events.sort()
        
        active_intervals = []
        current_area = 0
        prev_y = None
        result = 0.0
        
        for y, typ, x1, x2 in events:
            if prev_y is not None and y != prev_y and active_intervals:
                delta_y = y - prev_y
                merged = []
                for interval in sorted(active_intervals):
                    if not merged:
                        merged.append(interval)
                    else:
                        last_x1, last_x2 = merged[-1]
                        if interval[0] <= last_x2:
                            merged[-1] = (last_x1, max(last_x2, interval[1]))
                        else:
                            merged.append(interval)
                current_width = 0
                for (start, end) in merged:
                    current_width += end - start
                if current_area + current_width * delta_y >= target:
                    remaining = target - current_area
                    result = prev_y + remaining / current_width
                    return result
                current_area += current_width * delta_y
            
            if typ == 1:
                active_intervals.append((x1, x2))
            else:
                active_intervals.remove((x1, x2))
            
            prev_y = y
        
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 23, 'lineno': 2}, {'name': 'separateSquares', 'complexity': 22, 'lineno': 3}], 'maintainability_index': 36.747667864337345, 'raw_metrics': {'loc': 72, 'lloc': 72, 'sloc': 72, 'comments': 0}}"
check-if-matrix-is-x-matrix,"```python
from typing import List

class Solution:
    def checkXMatrix(self, grid: List[List[int]]) -> bool:
        n = len(grid)
        for i in range(n):
            for j in range(n):
                if i == j or i + j == n - 1:
                    if grid[i][j] == 0:
                        return False
                else:
                    if grid[i][j] != 0:
                        return False
        return True
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'checkXMatrix', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 60.44855199195766, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
delete-nodes-from-linked-list-present-in-array,"```python
class Solution:
    def modifiedList(self, nums: List[int], head: Optional[ListNode]) -> Optional[ListNode]:
        nums_set = set(nums)
        dummy = ListNode(0)
        dummy.next = head
        prev = dummy
        current = head
        
        while current:
            if current.val in nums_set:
                prev.next = current.next
            else:
                prev = current
            current = current.next
        
        return dummy.next
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'modifiedList', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 69.06543096516874, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
max-pair-sum-in-an-array,"```python
from typing import List

class Solution:
    def maxSum(self, nums: List[int]) -> int:
        max_digits = {}
        
        for num in nums:
            max_d = max(str(num))
            max_d = int(max_d)
            if max_d not in max_digits:
                max_digits[max_d] = []
            max_digits[max_d].append(num)
        
        max_sum = -1
        for key in max_digits:
            numbers = max_digits[key]
            if len(numbers) >= 2:
                numbers.sort(reverse=True)
                current_sum = numbers[0] + numbers[1]
                if current_sum > max_sum:
                    max_sum = current_sum
        
        return max_sum
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'maxSum', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 58.587121991087166, 'raw_metrics': {'loc': 20, 'lloc': 20, 'sloc': 20, 'comments': 0}}"
length-of-the-longest-alphabetical-continuous-substring,"```python
class Solution:
    def longestContinuousSubstring(self, s: str) -> int:
        max_len = 1
        current_len = 1
        for i in range(1, len(s)):
            if ord(s[i]) - ord(s[i-1]) == 1:
                current_len += 1
                max_len = max(max_len, current_len)
            else:
                current_len = 1
        return max_len
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'longestContinuousSubstring', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 65.68029284925473, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
optimal-partition-of-string,"```python
class Solution:
    def partitionString(self, s: str) -> int:
        count = 1
        seen = set()
        for char in s:
            if char in seen:
                count += 1
                seen = set()
            seen.add(char)
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'partitionString', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 69.3113889160328, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
number-of-ways-to-rearrange-sticks-with-k-sticks-visible,"```python
class Solution:
    def rearrangeSticks(self, n: int, k: int) -> int:
        MOD = 10**9 + 7
        dp = [[0] * (k + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, k + 1):
                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j] * (i - 1)) % MOD
        return dp[n][k]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 1}, {'name': 'rearrangeSticks', 'complexity': 4, 'lineno': 2}], 'maintainability_index': 62.59939706300232, 'raw_metrics': {'loc': 9, 'lloc': 9, 'sloc': 9, 'comments': 0}}"
redistribute-characters-to-make-all-strings-equal,"```python
from typing import List
from collections import defaultdict

class Solution:
    def makeEqual(self, words: List[str]) -> bool:
        char_count = defaultdict(int)
        total_words = len(words)
        
        for word in words:
            for char in word:
                char_count[char] += 1
        
        for count in char_count.values():
            if count % total_words != 0:
                return False
        
        return True
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 4}, {'name': 'makeEqual', 'complexity': 5, 'lineno': 5}], 'maintainability_index': 64.00141650791889, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
minimum-operations-to-form-subsequence-with-target-sum,"```python
from typing import List

class Solution:
    def minOperations(self, nums: List[int], target: int) -> int:
        total = sum(nums)
        if total < target:
            return -1
        
        freq = [0] * 32
        for num in nums:
            power = num.bit_length() - 1
            freq[power] += 1
        
        operations = 0
        for i in range(31):
            if (target >> i) & 1:
                if freq[i] > 0:
                    freq[i] -= 1
                else:
                    j = i + 1
                    while j < 31 and freq[j] == 0:
                        j += 1
                    if j == 31:
                        return -1
                    freq[j] -= 1
                    operations += j - i
                    for k in range(i, j):
                        freq[k] += 1
            freq[i + 1] += freq[i] // 2
        
        return operations
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 3}, {'name': 'minOperations', 'complexity': 10, 'lineno': 4}], 'maintainability_index': 49.170188753404965, 'raw_metrics': {'loc': 28, 'lloc': 28, 'sloc': 28, 'comments': 0}}"
number-of-subarrays-that-match-a-pattern-i,"```python
from typing import List

class Solution:
    def countMatchingSubarrays(self, nums: List[int], pattern: List[int]) -> int:
        count = 0
        n = len(nums)
        m = len(pattern)
        for i in range(n - m):
            match = True
            for k in range(m):
                if pattern[k] == 1:
                    if not (nums[i + k + 1] > nums[i + k]):
                        match = False
                        break
                elif pattern[k] == 0:
                    if not (nums[i + k + 1] == nums[i + k]):
                        match = False
                        break
                elif pattern[k] == -1:
                    if not (nums[i + k + 1] < nums[i + k]):
                        match = False
                        break
            if match:
                count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 3}, {'name': 'countMatchingSubarrays', 'complexity': 10, 'lineno': 4}], 'maintainability_index': 50.78929036851037, 'raw_metrics': {'loc': 25, 'lloc': 25, 'sloc': 25, 'comments': 0}}"
points-that-intersect-with-cars,"```python
class Solution:
    def numberOfPoints(self, nums: List[List[int]]) -> int:
        covered = set()
        for start, end in nums:
            covered.update(range(start, end + 1))
        return len(covered)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 2}, {'name': 'numberOfPoints', 'complexity': 2, 'lineno': 3}], 'maintainability_index': 76.42020806643173, 'raw_metrics': {'loc': 7, 'lloc': 7, 'sloc': 7, 'comments': 0}}"
count-the-number-of-beautiful-subarrays,"```python
from typing import List
from collections import defaultdict

class Solution:
    def beautifulSubarrays(self, nums: List[int]) -> int:
        prefix_xor = 0
        xor_counts = defaultdict(int)
        xor_counts[0] = 1
        result = 0
        
        for num in nums:
            prefix_xor ^= num
            result += xor_counts[prefix_xor]
            xor_counts[prefix_xor] += 1
        
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 4}, {'name': 'beautifulSubarrays', 'complexity': 2, 'lineno': 5}], 'maintainability_index': 64.57246757719902, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
cherry-pickup-ii,"```python
class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        rows = len(grid)
        cols = len(grid[0])
        
        dp = [[[ -1 for _ in range(cols) ] for __ in range(cols)] for ___ in range(rows)]
        
        dp[0][0][cols-1] = grid[0][0] + grid[0][cols-1]
        
        for i in range(1, rows):
            for j1 in range(cols):
                for j2 in range(cols):
                    max_prev = -1
                    for dj1 in [-1, 0, 1]:
                        prev_j1 = j1 + dj1
                        if prev_j1 < 0 or prev_j1 >= cols:
                            continue
                        for dj2 in [-1, 0, 1]:
                            prev_j2 = j2 + dj2
                            if prev_j2 < 0 or prev_j2 >= cols:
                                continue
                            if dp[i-1][prev_j1][prev_j2] > max_prev:
                                max_prev = dp[i-1][prev_j1][prev_j2]
                    if max_prev == -1:
                        continue
                    if j1 == j2:
                        current = grid[i][j1]
                    else:
                        current = grid[i][j1] + grid[i][j2]
                    dp[i][j1][j2] = max_prev + current
        
        max_cherries = 0
        for j1 in range(cols):
            for j2 in range(cols):
                if dp[rows-1][j1][j2] > max_cherries:
                    max_cherries = dp[rows-1][j1][j2]
        return max_cherries
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 20, 'lineno': 2}, {'name': 'cherryPickup', 'complexity': 19, 'lineno': 3}], 'maintainability_index': 45.93422639787637, 'raw_metrics': {'loc': 34, 'lloc': 34, 'sloc': 34, 'comments': 0}}"
make-string-a-subsequence-using-cyclic-increments,"```python
class Solution:
    def canMakeSubsequence(self, str1: str, str2: str) -> bool:
        m, n = len(str1), len(str2)
        if n > m:
            return False
        
        i = j = 0
        while i < m and j < n:
            c1 = str1[i]
            c2 = str2[j]
            if c1 == c2 or (ord(c2) - ord(c1)) % 26 == 1:
                j += 1
            i += 1
        
        return j == n
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 1}, {'name': 'canMakeSubsequence', 'complexity': 6, 'lineno': 2}], 'maintainability_index': 59.23102684725884, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
find-the-k-or-of-an-array,"```python
from typing import List

class Solution:
    def findKOr(self, nums: List[int], k: int) -> int:
        result = 0
        for i in range(32):
            mask = 1 << i
            count = 0
            for num in nums:
                if num & mask:
                    count += 1
                    if count >= k:
                        break
            if count >= k:
                result |= mask
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'findKOr', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 60.11990636615855, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
the-number-of-good-subsets,"```python
class Solution:
    def numberOfGoodSubsets(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
        count = [0] * 31
        for num in nums:
            count[num] += 1
        
        mask = [0] * 31
        for num in range(2, 31):
            tmp = num
            m = 0
            for i, p in enumerate(primes):
                if tmp % p == 0:
                    tmp //= p
                    m |= (1 << i)
                    if tmp % p == 0:
                        mask[num] = -1
                        break
            if mask[num] != -1:
                mask[num] = m
        
        dp = [0] * (1 << len(primes))
        dp[0] = 1
        
        for num in range(2, 31):
            if mask[num] == -1 or count[num] == 0:
                continue
            current_mask = mask[num]
            for prev_mask in range((1 << len(primes)) - 1, -1, -1):
                if (prev_mask & current_mask) == 0:
                    new_mask = prev_mask | current_mask
                    dp[new_mask] = (dp[new_mask] + dp[prev_mask] * count[num]) % MOD
        
        total = 0
        for m in range(1, 1 << len(primes)):
            total = (total + dp[m]) % MOD
        
        if count[1] > 0:
            total = (total * pow(2, count[1], MOD)) % MOD
        
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 15, 'lineno': 2}, {'name': 'numberOfGoodSubsets', 'complexity': 14, 'lineno': 3}], 'maintainability_index': 44.20398508679706, 'raw_metrics': {'loc': 37, 'lloc': 37, 'sloc': 37, 'comments': 0}}"
minimum-replacements-to-sort-the-array,"```python
class Solution:
    def minimumReplacement(self, nums: List[int]) -> int:
        operations = 0
        n = len(nums)
        prev = nums[-1]
        
        for i in range(n - 2, -1, -1):
            if nums[i] > prev:
                parts = (nums[i] + prev - 1) // prev
                operations += parts - 1
                prev = nums[i] // parts
            else:
                prev = nums[i]
        
        return operations
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'minimumReplacement', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 59.836162432594215, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
minimum-operations-to-make-the-array-increasing,"```python
from typing import List

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        operations = 0
        for i in range(1, len(nums)):
            if nums[i] <= nums[i-1]:
                operations += nums[i-1] - nums[i] + 1
                nums[i] = nums[i-1] + 1
        return operations
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'minOperations', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 64.0048496888727, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
minimum-number-of-operations-to-make-array-continuous,"```python
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        unique_nums = sorted(list(set(nums)))
        m = len(unique_nums)
        res = float('inf')
        
        left = 0
        for right in range(m):
            while unique_nums[right] - unique_nums[left] >= n:
                left += 1
            res = min(res, n - (right - left + 1))
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'minOperations', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 62.49052490967176, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
number-of-beautiful-pairs,"```python
import math
from typing import List

class Solution:
    def countBeautifulPairs(self, nums: List[int]) -> int:
        count = 0
        n = len(nums)
        for i in range(n):
            first_digit = int(str(nums[i])[0])
            for j in range(i + 1, n):
                last_digit = nums[j] % 10
                if math.gcd(first_digit, last_digit) == 1:
                    count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 4}, {'name': 'countBeautifulPairs', 'complexity': 4, 'lineno': 5}], 'maintainability_index': 63.261096755433925, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
longest-cycle-in-a-graph,"```python
class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        n = len(edges)
        visited = [False] * n
        max_cycle = -1
        
        for i in range(n):
            if not visited[i]:
                cycle = {}
                current = i
                pos = 0
                while current != -1:
                    if current in cycle:
                        max_cycle = max(max_cycle, pos - cycle[current])
                        break
                    if visited[current]:
                        break
                    visited[current] = True
                    cycle[current] = pos
                    pos += 1
                    current = edges[current]
        return max_cycle if max_cycle != 0 else -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 2}, {'name': 'longestCycle', 'complexity': 7, 'lineno': 3}], 'maintainability_index': 55.39060841864924, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
maximum-number-of-balls-in-a-box,"```python
class Solution:
    def countBalls(self, lowLimit: int, highLimit: int) -> int:
        box_counts = {}
        max_count = 0
        for num in range(lowLimit, highLimit + 1):
            digit_sum = 0
            n = num
            while n > 0:
                digit_sum += n % 10
                n = n // 10
            if digit_sum in box_counts:
                box_counts[digit_sum] += 1
            else:
                box_counts[digit_sum] = 1
            if box_counts[digit_sum] > max_count:
                max_count = box_counts[digit_sum]
        return max_count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 1}, {'name': 'countBalls', 'complexity': 5, 'lineno': 2}], 'maintainability_index': 58.47212469629039, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
maximum-number-of-points-from-grid-queries,"```python
import heapq
from typing import List

class Solution:
    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:
        m, n = len(grid), len(grid[0])
        k = len(queries)
        queries_sorted = sorted((val, i) for i, val in enumerate(queries))
        answer = [0] * k
        
        heap = []
        heapq.heappush(heap, (grid[0][0], 0, 0))
        visited = [[False for _ in range(n)] for _ in range(m)]
        visited[0][0] = True
        count = 0
        
        for val, idx in queries_sorted:
            while heap and heap[0][0] < val:
                v, i, j = heapq.heappop(heap)
                count += 1
                for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                    ni, nj = i + di, j + dj
                    if 0 <= ni < m and 0 <= nj < n and not visited[ni][nj]:
                        visited[ni][nj] = True
                        heapq.heappush(heap, (grid[ni][nj], ni, nj))
            answer[idx] = count
        
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 4}, {'name': 'maxPoints', 'complexity': 11, 'lineno': 5}], 'maintainability_index': 52.05497023357018, 'raw_metrics': {'loc': 25, 'lloc': 25, 'sloc': 25, 'comments': 0}}"
count-pairs-with-xor-in-a-range,"```python
class Solution:
    def countPairs(self, nums: List[int], low: int, high: int) -> int:
        class TrieNode:
            __slots__ = ['children', 'count']
            def __init__(self):
                self.children = [None, None]
                self.count = 0
        
        root = TrieNode()
        
        def insert(num):
            node = root
            for i in range(15, -1, -1):
                bit = (num >> i) & 1
                if not node.children[bit]:
                    node.children[bit] = TrieNode()
                node = node.children[bit]
                node.count += 1
        
        def query(num, limit):
            node = root
            res = 0
            for i in range(15, -1, -1):
                if not node:
                    break
                num_bit = (num >> i) & 1
                limit_bit = (limit >> i) & 1
                if limit_bit:
                    if node.children[num_bit]:
                        res += node.children[num_bit].count
                    node = node.children[1 - num_bit]
                else:
                    node = node.children[num_bit]
            return res
        
        res = 0
        for num in nums:
            res += query(num, high + 1) - query(num, low)
            insert(num)
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 2}, {'name': 'countPairs', 'complexity': 2, 'lineno': 3}], 'maintainability_index': 48.84100587794714, 'raw_metrics': {'loc': 37, 'lloc': 37, 'sloc': 37, 'comments': 0}}"
apply-operations-to-maximize-score,"```python
import heapq

class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
        MOD = 10**9 + 7
        
        def compute_prime_score(x):
            if x == 1:
                return 0
            factors = set()
            if x % 2 == 0:
                factors.add(2)
                while x % 2 == 0:
                    x //= 2
            i = 3
            while i * i <= x:
                if x % i == 0:
                    factors.add(i)
                    while x % i == 0:
                        x //= i
                i += 2
            if x > 1:
                factors.add(x)
            return len(factors)
        
        n = len(nums)
        prime_scores = [compute_prime_score(num) for num in nums]
        
        next_greater = [n] * n
        stack = []
        for i in range(n):
            while stack and prime_scores[stack[-1]] < prime_scores[i]:
                next_greater[stack.pop()] = i
            stack.append(i)
        
        prev_greater = [-1] * n
        stack = []
        for i in range(n-1, -1, -1):
            while stack and prime_scores[stack[-1]] <= prime_scores[i]:
                prev_greater[stack.pop()] = i
            stack.append(i)
        
        max_heap = []
        for i in range(n):
            left = prev_greater[i] + 1
            right = next_greater[i] - 1
            count = (i - left + 1) * (right - i + 1)
            heapq.heappush(max_heap, (-nums[i], count))
        
        res = 1
        remaining_k = k
        while remaining_k > 0 and max_heap:
            num, cnt = heapq.heappop(max_heap)
            num = -num
            use = min(remaining_k, cnt)
            res = (res * pow(num, use, MOD)) % MOD
            remaining_k -= use
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 3}, {'name': 'maximumScore', 'complexity': 11, 'lineno': 4}], 'maintainability_index': 40.98168236783593, 'raw_metrics': {'loc': 52, 'lloc': 52, 'sloc': 52, 'comments': 0}}"
number-of-pairs-satisfying-inequality,"```python
import bisect

class Solution:
    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:
        n = len(nums1)
        arr = [nums1[i] - nums2[i] for i in range(n)]
        sorted_list = []
        res = 0
        
        for num in arr:
            target = num + diff
            count = bisect.bisect_right(sorted_list, target)
            res += count
            bisect.insort(sorted_list, num)
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'numberOfPairs', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 64.43796465322242, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
ways-to-express-an-integer-as-sum-of-powers,"```python
class Solution:
    def numberOfWays(self, n: int, x: int) -> int:
        MOD = 10**9 + 7
        max_num = 1
        while max_num ** x <= n:
            max_num += 1
        max_num -= 1
        
        dp = [0] * (n + 1)
        dp[0] = 1
        
        for num in range(1, max_num + 1):
            power = num ** x
            for i in range(n, power - 1, -1):
                dp[i] = (dp[i] + dp[i - power]) % MOD
        return dp[n]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 1}, {'name': 'numberOfWays', 'complexity': 4, 'lineno': 2}], 'maintainability_index': 58.14891851591843, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
find-the-value-of-the-partition,"```python
class Solution:
    def findValueOfPartition(self, nums: List[int]) -> int:
        nums.sort()
        min_diff = float('inf')
        for i in range(1, len(nums)):
            diff = nums[i] - nums[i-1]
            if diff < min_diff:
                min_diff = diff
        return min_diff
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'findValueOfPartition', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 67.62559636858127, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
distribute-candies-among-children-i,"```python
class Solution:
    def distributeCandies(self, n: int, limit: int) -> int:
        count = 0
        for a in range(0, min(n, limit) + 1):
            for b in range(0, min(n - a, limit) + 1):
                c = n - a - b
                if c >= 0 and c <= limit:
                    count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 1}, {'name': 'distributeCandies', 'complexity': 5, 'lineno': 2}], 'maintainability_index': 64.01259665610372, 'raw_metrics': {'loc': 9, 'lloc': 9, 'sloc': 9, 'comments': 0}}"
max-dot-product-of-two-subsequences,"```python
from typing import List

class Solution:
    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:
        m, n = len(nums1), len(nums2)
        dp = [[-float('inf')] * (n + 1) for _ in range(m + 1)]
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                product = nums1[i-1] * nums2[j-1]
                dp[i][j] = max(
                    product,
                    dp[i-1][j-1] + product,
                    dp[i-1][j],
                    dp[i][j-1]
                )
        
        return dp[m][n]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'maxDotProduct', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 61.102217050281034, 'raw_metrics': {'loc': 16, 'lloc': 11, 'sloc': 16, 'comments': 0}}"
find-the-prefix-common-array-of-two-arrays,"```python
from typing import List

class Solution:
    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:
        n = len(A)
        C = []
        set_a = set()
        set_b = set()
        common = set()
        
        for i in range(n):
            set_a.add(A[i])
            set_b.add(B[i])
            if A[i] in set_b:
                common.add(A[i])
            if B[i] in set_a:
                common.add(B[i])
            C.append(len(common))
        
        return C
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'findThePrefixCommonArray', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 63.93471293530445, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
minimum-cost-to-split-an-array,"```python
from typing import List

class Solution:
    def minCost(self, nums: List[int], k: int) -> int:
        n = len(nums)
        dp = [float('inf')] * (n + 1)
        dp[0] = 0
        
        for i in range(1, n + 1):
            freq = {}
            trimmed_length = 0
            for j in range(i - 1, -1, -1):
                num = nums[j]
                if num in freq:
                    if freq[num] == 1:
                        trimmed_length += 2
                    else:
                        trimmed_length += 1
                freq[num] = freq.get(num, 0) + 1
                current_cost = dp[j] + k + trimmed_length
                if current_cost < dp[i]:
                    dp[i] = current_cost
        
        return dp[n]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'minCost', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 53.967590944120076, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
smallest-k-length-subsequence-with-occurrences-of-a-letter,"```python
class Solution:
    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:
        stack = []
        n = len(s)
        total_letter = s.count(letter)
        remaining_letter = total_letter
        needed = repetition
        
        for i, ch in enumerate(s):
            while stack and stack[-1] > ch and (len(stack) + (n - i)) > k:
                if stack[-1] == letter:
                    if remaining_letter <= needed:
                        break
                    needed += 1
                stack.pop()
            
            if len(stack) < k:
                if ch == letter:
                    stack.append(ch)
                    needed -= 1
                else:
                    if (k - len(stack)) > needed:
                        stack.append(ch)
            remaining_letter -= (ch == letter)
        
        return ''.join(stack)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 1}, {'name': 'smallestSubsequence', 'complexity': 10, 'lineno': 2}], 'maintainability_index': 52.14485939565408, 'raw_metrics': {'loc': 23, 'lloc': 23, 'sloc': 23, 'comments': 0}}"
closest-subsequence-sum,"```python
class Solution:
    def minAbsDifference(self, nums: List[int], goal: int) -> int:
        n = len(nums)
        half = n // 2
        
        def generate_sums(arr):
            sums = {0}
            for num in arr:
                new_sums = set()
                for s in sums:
                    new_sums.add(s + num)
                sums.update(new_sums)
            return sorted(sums)
        
        left_sums = generate_sums(nums[:half])
        right_sums = generate_sums(nums[half:])
        
        min_diff = float('inf')
        
        for s in left_sums:
            remaining = goal - s
            idx = bisect.bisect_left(right_sums, remaining)
            if idx < len(right_sums):
                min_diff = min(min_diff, abs(remaining - right_sums[idx]))
            if idx > 0:
                min_diff = min(min_diff, abs(remaining - right_sums[idx-1]))
            if min_diff == 0:
                return 0
        return min_diff
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'minAbsDifference', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 53.15127883217356, 'raw_metrics': {'loc': 26, 'lloc': 28, 'sloc': 26, 'comments': 0}}"
minimum-white-tiles-after-covering-with-carpets,"```python
class Solution:
    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:
        n = len(floor)
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i+1] = prefix[i] + (1 if floor[i] == '1' else 0)
        
        dp = [[0] * (numCarpets + 1) for _ in range(n + 1)]
        
        for i in range(1, n + 1):
            for k in range(numCarpets + 1):
                if k == 0:
                    dp[i][k] = prefix[i]
                else:
                    if i <= carpetLen:
                        dp[i][k] = 0
                    else:
                        dp[i][k] = min(dp[i-1][k] + (1 if floor[i-1] == '1' else 0), dp[i-carpetLen][k-1])
        
        return dp[n][numCarpets]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 1}, {'name': 'minimumWhiteTiles', 'complexity': 9, 'lineno': 2}], 'maintainability_index': 55.09407497333193, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
find-polygon-with-the-largest-perimeter,"```python
class Solution:
    def largestPerimeter(self, nums: List[int]) -> int:
        nums.sort()
        total = sum(nums)
        for i in range(len(nums) - 1, 1, -1):
            if total - nums[i] > nums[i]:
                return total
            total -= nums[i]
        return -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'largestPerimeter', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 65.56597908510854, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
take-gifts-from-the-richest-pile,"```python
import heapq
from math import isqrt
from typing import List

class Solution:
    def pickGifts(self, gifts: List[int], k: int) -> int:
        max_heap = []
        for num in gifts:
            heapq.heappush(max_heap, -num)
        
        for _ in range(k):
            if not max_heap:
                break
            current = -heapq.heappop(max_heap)
            new_val = isqrt(current)
            heapq.heappush(max_heap, -new_val)
        
        return sum(-num for num in max_heap)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 5}, {'name': 'pickGifts', 'complexity': 5, 'lineno': 6}], 'maintainability_index': 63.036329245059655, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
minimum-cost-walk-in-weighted-graph,"```python
from typing import List

class Solution:
    def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -> List[int]:
        parent = list(range(n))
        and_cost = [ (1 << 31) - 1 ] * n  # Initialize with all bits set (for AND operation)

        def find(u):
            while parent[u] != u:
                parent[u] = parent[parent[u]]
                u = parent[u]
            return u

        for u, v, w in edges:
            root_u = find(u)
            root_v = find(v)
            if root_u != root_v:
                parent[root_v] = root_u
                and_cost[root_u] &= and_cost[root_v]
            and_cost[root_u] &= w

        res = []
        for s, t in query:
            if s == t:
                res.append(0)
                continue
            root_s = find(s)
            root_t = find(t)
            if root_s != root_t:
                res.append(-1)
            else:
                res.append(and_cost[root_s])
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'minimumCost', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 62.76586750883663, 'raw_metrics': {'loc': 30, 'lloc': 30, 'sloc': 30, 'comments': 1}}"
partition-string-into-substrings-with-values-at-most-k,"```python
class Solution:
    def minimumPartition(self, s: str, k: int) -> int:
        n = len(s)
        res = 0
        current = 0
        for c in s:
            digit = int(c)
            if digit > k:
                return -1
            if current * 10 + digit > k:
                res += 1
                current = digit
            else:
                current = current * 10 + digit
        return res + 1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 1}, {'name': 'minimumPartition', 'complexity': 4, 'lineno': 2}], 'maintainability_index': 59.7856936472033, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
apply-operations-to-make-all-array-elements-equal-to-zero,"```python
from typing import List

class Solution:
    def checkArray(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        diff = [0] * (n + 1)
        current = 0
        
        for i in range(n):
            current += diff[i]
            adjusted = nums[i] - current
            
            if adjusted < 0:
                return False
            
            if adjusted > 0:
                if i + k > n:
                    return False
                current += adjusted
                if i + k < n:
                    diff[i + k] -= adjusted
        
        return True
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'checkArray', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 55.62463487315205, 'raw_metrics': {'loc': 19, 'lloc': 19, 'sloc': 19, 'comments': 0}}"
find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree,"```python
class Solution:
    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        parent = list(range(n))
        
        def find(u):
            while parent[u] != u:
                parent[u] = parent[parent[u]]
                u = parent[u]
            return u
        
        def union(u, v):
            u_root = find(u)
            v_root = find(v)
            if u_root == v_root:
                return False
            parent[v_root] = u_root
            return True
        
        edges_with_index = [(u, v, w, i) for i, (u, v, w) in enumerate(edges)]
        edges_with_index.sort(key=lambda x: x[2])
        
        original_mst_weight = 0
        parent = list(range(n))
        for u, v, w, _ in edges_with_index:
            if union(u, v):
                original_mst_weight += w
        
        critical = []
        pseudo_critical = []
        
        for i in range(len(edges_with_index)):
            parent = list(range(n))
            mst_weight = 0
            for j in range(len(edges_with_index)):
                if i == j:
                    continue
                u, v, w, _ = edges_with_index[j]
                if union(u, v):
                    mst_weight += w
            if mst_weight != original_mst_weight:
                critical.append(edges_with_index[i][3])
                continue
            
            parent = list(range(n))
            u, v, w, _ = edges_with_index[i]
            union(u, v)
            mst_weight = w
            for j in range(len(edges_with_index)):
                if i == j:
                    continue
                u, v, w, _ = edges_with_index[j]
                if union(u, v):
                    mst_weight += w
            if mst_weight == original_mst_weight:
                pseudo_critical.append(edges_with_index[i][3])
        
        pseudo_critical = [edge for edge in pseudo_critical if edge not in critical]
        
        return [critical, pseudo_critical]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 16, 'lineno': 2}, {'name': 'findCriticalAndPseudoCriticalEdges', 'complexity': 15, 'lineno': 3}], 'maintainability_index': 45.9282853473484, 'raw_metrics': {'loc': 51, 'lloc': 52, 'sloc': 51, 'comments': 0}}"
minimum-cost-to-convert-string-i,"```python
import heapq
from typing import List

class Solution:
    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:
        graph = {}
        nodes = set()
        for o, c, co in zip(original, changed, cost):
            if o not in graph:
                graph[o] = {}
            if c not in graph[o] or graph[o][c] > co:
                graph[o][c] = co
            nodes.add(o)
            nodes.add(c)
        
        dist = {}
        for node in nodes:
            dist[node] = {}
            heap = []
            heapq.heappush(heap, (0, node))
            while heap:
                current_dist, u = heapq.heappop(heap)
                if u in dist[node] and current_dist >= dist[node][u]:
                    continue
                dist[node][u] = current_dist
                if u in graph:
                    for v in graph[u]:
                        new_dist = current_dist + graph[u][v]
                        if v not in dist[node] or new_dist < dist[node].get(v, float('inf')):
                            heapq.heappush(heap, (new_dist, v))
        
        total_cost = 0
        for s_char, t_char in zip(source, target):
            if s_char == t_char:
                continue
            if s_char not in dist or t_char not in dist[s_char]:
                return -1
            total_cost += dist[s_char][t_char]
        
        return total_cost
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 18, 'lineno': 4}, {'name': 'minimumCost', 'complexity': 17, 'lineno': 5}], 'maintainability_index': 46.212904341905876, 'raw_metrics': {'loc': 37, 'lloc': 37, 'sloc': 37, 'comments': 0}}"
count-pairs-of-nodes,"```python
from collections import defaultdict
from bisect import bisect_right

class Solution:
    def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:
        degree = [0] * (n + 1)
        edge_count = defaultdict(int)
        
        for u, v in edges:
            if u > v:
                u, v = v, u
            degree[u] += 1
            degree[v] += 1
            edge_count[(u, v)] += 1
        
        sorted_degree = sorted(degree[1:])
        res = []
        
        for q in queries:
            total = 0
            left, right = 1, n
            while left < right:
                if sorted_degree[left - 1] + sorted_degree[right - 1] > q:
                    total += right - left
                    right -= 1
                else:
                    left += 1
            
            for (u, v), cnt in edge_count.items():
                if degree[u] + degree[v] > q and degree[u] + degree[v] - cnt <= q:
                    total -= 1
            
            res.append(total)
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 4}, {'name': 'countPairs', 'complexity': 9, 'lineno': 5}], 'maintainability_index': 48.745699225215766, 'raw_metrics': {'loc': 29, 'lloc': 30, 'sloc': 29, 'comments': 0}}"
find-beautiful-indices-in-the-given-array-i,"```python
class Solution:
    def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:
        len_a = len(a)
        len_b = len(b)
        a_indices = []
        b_indices = []
        
        for i in range(len(s) - len_a + 1):
            if s[i:i+len_a] == a:
                a_indices.append(i)
        
        for j in range(len(s) - len_b + 1):
            if s[j:j+len_b] == b:
                b_indices.append(j)
        
        beautiful = []
        if not b_indices:
            return beautiful
        
        for i in a_indices:
            left = i - k
            right = i + k
            
            low = 0
            high = len(b_indices) - 1
            found = False
            while low <= high:
                mid = (low + high) // 2
                j = b_indices[mid]
                if left <= j <= right:
                    found = True
                    break
                elif j < left:
                    low = mid + 1
                else:
                    high = mid - 1
            if found:
                beautiful.append(i)
        
        return beautiful
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 2}, {'name': 'beautifulIndices', 'complexity': 11, 'lineno': 3}], 'maintainability_index': 47.51913880137863, 'raw_metrics': {'loc': 35, 'lloc': 35, 'sloc': 35, 'comments': 0}}"
maximize-score-after-n-operations,"```python
from typing import List
import math
from functools import lru_cache

class Solution:
    def maxScore(self, nums: List[int]) -> int:
        n = len(nums)
        
        @lru_cache(maxsize=None)
        def dfs(mask, step):
            if mask == (1 << n) - 1:
                return 0
            max_score = 0
            for i in range(n):
                if not (mask & (1 << i)):
                    for j in range(i + 1, n):
                        if not (mask & (1 << j)):
                            current_gcd = math.gcd(nums[i], nums[j])
                            current_score = step * current_gcd
                            new_mask = mask | (1 << i) | (1 << j)
                            remaining_score = dfs(new_mask, step + 1)
                            total_score = current_score + remaining_score
                            if total_score > max_score:
                                max_score = total_score
            return max_score
        
        return dfs(0, 1)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 5}, {'name': 'maxScore', 'complexity': 1, 'lineno': 6}], 'maintainability_index': 52.41433048206932, 'raw_metrics': {'loc': 25, 'lloc': 25, 'sloc': 25, 'comments': 0}}"
minimum-cost-to-change-the-final-value-of-expression,"```python
class Solution:
    def minOperationsToFlip(self, expression: str) -> int:
        stack = []
        ops = []
        
        for ch in expression:
            if ch in ('0', '1'):
                val = int(ch)
                stack.append((val, 1))
            elif ch == '(':
                ops.append(ch)
            elif ch == ')':
                while ops[-1] != '(':
                    op = ops.pop()
                    b_val, b_cost = stack.pop()
                    a_val, a_cost = stack.pop()
                    new_val, new_cost = self.combine(a_val, a_cost, b_val, b_cost, op)
                    stack.append((new_val, new_cost))
                ops.pop()  # Remove '('
            else:
                while ops and ops[-1] != '(':
                    op = ops.pop()
                    b_val, b_cost = stack.pop()
                    a_val, a_cost = stack.pop()
                    new_val, new_cost = self.combine(a_val, a_cost, b_val, b_cost, op)
                    stack.append((new_val, new_cost))
                ops.append(ch)
        
        while ops:
            op = ops.pop()
            b_val, b_cost = stack.pop()
            a_val, a_cost = stack.pop()
            new_val, new_cost = self.combine(a_val, a_cost, b_val, b_cost, op)
            stack.append((new_val, new_cost))
        
        final_val, final_cost = stack[-1]
        return final_cost if final_val == 1 else final_cost
    
    def combine(self, a_val, a_cost, b_val, b_cost, op):
        if op == '&':
            if a_val == 1 and b_val == 1:
                new_val = 1
                new_cost = min(a_cost, b_cost, 1 + min(a_cost, b_cost))
            elif a_val == 1 and b_val == 0:
                new_val = 0
                new_cost = 1
            elif a_val == 0 and b_val == 1:
                new_val = 0
                new_cost = 1
            else:  # 0 & 0
                new_val = 0
                new_cost = min(a_cost + b_cost, 1 + min(a_cost, b_cost))
        else:  # '|'
            if a_val == 1 and b_val == 1:
                new_val = 1
                new_cost = min(a_cost + b_cost, 1 + min(a_cost, b_cost))
            elif a_val == 1 and b_val == 0:
                new_val = 1
                new_cost = 1
            elif a_val == 0 and b_val == 1:
                new_val = 1
                new_cost = 1
            else:  # 0 | 0
                new_val = 0
                new_cost = min(a_cost, b_cost, 1 + min(a_cost, b_cost))
        return (new_val, new_cost)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 13, 'lineno': 1}, {'name': 'minOperationsToFlip', 'complexity': 10, 'lineno': 2}, {'name': 'combine', 'complexity': 14, 'lineno': 35}], 'maintainability_index': 53.07851561250711, 'raw_metrics': {'loc': 62, 'lloc': 62, 'sloc': 62, 'comments': 4}}"
count-subarrays-with-median-k,"```python
from typing import List
from collections import defaultdict

class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        pos = nums.index(k)
        count = defaultdict(int)
        count[0] = 1
        res = 0
        balance = 0
        
        for i in range(pos + 1, len(nums)):
            balance += 1 if nums[i] > k else -1
            count[balance] += 1
        
        res += count[0] + count[1]
        balance = 0
        
        for i in range(pos - 1, -1, -1):
            balance += 1 if nums[i] < k else -1
            res += count[balance] + count[balance + 1]
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 4}, {'name': 'countSubarrays', 'complexity': 5, 'lineno': 5}], 'maintainability_index': 55.29067027690768, 'raw_metrics': {'loc': 19, 'lloc': 19, 'sloc': 19, 'comments': 0}}"
rearranging-fruits,"```python
from collections import defaultdict
from typing import List

class Solution:
    def minCost(self, basket1: List[int], basket2: List[int]) -> int:
        count = defaultdict(int)
        for num in basket1:
            count[num] += 1
        for num in basket2:
            count[num] -= 1
        
        swaps = []
        for num in count:
            if count[num] % 2 != 0:
                return -1
            swaps.extend([num] * (abs(count[num]) // 2))
        
        min_val = min(min(basket1), min(basket2))
        swaps.sort()
        res = 0
        for i in range(len(swaps) // 2):
            res += min(swaps[i], 2 * min_val)
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 4}, {'name': 'minCost', 'complexity': 6, 'lineno': 5}], 'maintainability_index': 55.47575551189139, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
maximum-matching-of-players-with-trainers,"```python
class Solution:
    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:
        players.sort()
        trainers.sort()
        i = j = count = 0
        while i < len(players) and j < len(trainers):
            if players[i] <= trainers[j]:
                count += 1
                i += 1
                j += 1
            else:
                j += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'matchPlayersAndTrainers', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 60.596099937284535, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
sort-the-people,"```python
class Solution:
    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:
        people = list(zip(names, heights))
        people.sort(key=lambda x: -x[1])
        return [name for name, height in people]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 2}, {'name': 'sortPeople', 'complexity': 2, 'lineno': 3}], 'maintainability_index': 79.05373698619428, 'raw_metrics': {'loc': 6, 'lloc': 7, 'sloc': 6, 'comments': 0}}"
distinct-prime-factors-of-product-of-array,"```python
class Solution:
    def distinctPrimeFactors(self, nums: List[int]) -> int:
        def get_prime_factors(x):
            factors = set()
            if x == 1:
                return factors
            while x % 2 == 0:
                factors.add(2)
                x = x // 2
            i = 3
            while i * i <= x:
                while x % i == 0:
                    factors.add(i)
                    x = x // i
                i += 2
            if x > 1:
                factors.add(x)
            return factors
        
        prime_factors = set()
        for num in nums:
            factors = get_prime_factors(num)
            prime_factors.update(factors)
        return len(prime_factors)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 2}, {'name': 'distinctPrimeFactors', 'complexity': 2, 'lineno': 3}], 'maintainability_index': 54.7119480692197, 'raw_metrics': {'loc': 24, 'lloc': 24, 'sloc': 24, 'comments': 0}}"
sum-of-values-at-indices-with-k-set-bits,"```python
class Solution:
    def sumIndicesWithKSetBits(self, nums: List[int], k: int) -> int:
        total = 0
        for i in range(len(nums)):
            if bin(i).count('1') == k:
                total += nums[i]
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'sumIndicesWithKSetBits', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 71.42538045479901, 'raw_metrics': {'loc': 8, 'lloc': 8, 'sloc': 8, 'comments': 0}}"
unique-3-digit-even-numbers,"```python
from typing import List

class Solution:
    def totalNumbers(self, digits: List[int]) -> int:
        from collections import defaultdict
        
        count = defaultdict(int)
        for d in digits:
            count[d] += 1
        
        res = 0
        
        for first in range(1, 10):
            if count[first] == 0:
                continue
            count[first] -= 1
            
            for second in range(0, 10):
                if count[second] == 0:
                    continue
                count[second] -= 1
                
                for third in range(0, 10, 2):
                    if count[third] > 0:
                        res += 1
                
                count[second] += 1
            
            count[first] += 1
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 3}, {'name': 'totalNumbers', 'complexity': 8, 'lineno': 4}], 'maintainability_index': 54.91835354874467, 'raw_metrics': {'loc': 23, 'lloc': 23, 'sloc': 23, 'comments': 0}}"
most-frequent-ids,"```python
from collections import defaultdict
import heapq

class Solution:
    def mostFrequentIDs(self, nums: List[int], freq: List[int]) -> List[int]:
        freq_map = defaultdict(int)
        max_heap = []
        ans = []
        
        for num, f in zip(nums, freq):
            if f > 0:
                freq_map[num] += f
                heapq.heappush(max_heap, (-freq_map[num], num))
            else:
                freq_map[num] += f
                if freq_map[num] <= 0:
                    del freq_map[num]
                heapq.heappush(max_heap, (-freq_map[num], num) if num in freq_map else (0, num))
            
            while max_heap:
                current_neg_f, current_num = max_heap[0]
                current_f = -current_neg_f
                if current_num in freq_map and freq_map[current_num] == current_f:
                    ans.append(current_f)
                    break
                else:
                    heapq.heappop(max_heap)
            else:
                ans.append(0)
        
        return ans
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 4}, {'name': 'mostFrequentIDs', 'complexity': 9, 'lineno': 5}], 'maintainability_index': 52.1976314012706, 'raw_metrics': {'loc': 28, 'lloc': 28, 'sloc': 28, 'comments': 0}}"
minimum-operations-to-make-median-of-array-equal-to-k,"```python
class Solution:
    def minOperationsToMakeMedianK(self, nums: List[int], k: int) -> int:
        nums.sort()
        n = len(nums)
        median_pos = n // 2
        operations = 0
        
        if nums[median_pos] == k:
            return 0
        elif nums[median_pos] < k:
            operations += k - nums[median_pos]
            for i in range(median_pos + 1, n):
                if nums[i] < k:
                    operations += k - nums[i]
                else:
                    break
        else:
            operations += nums[median_pos] - k
            for i in range(median_pos - 1, -1, -1):
                if nums[i] > k:
                    operations += nums[i] - k
                else:
                    break
        return operations
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 2}, {'name': 'minOperationsToMakeMedianK', 'complexity': 7, 'lineno': 3}], 'maintainability_index': 52.31182917926941, 'raw_metrics': {'loc': 24, 'lloc': 24, 'sloc': 24, 'comments': 0}}"
number-of-distinct-roll-sequences,"```python
import math

class Solution:
    def distinctSequences(self, n: int) -> int:
        if n == 1:
            return 6
        MOD = 10**9 + 7
        
        gcd_pairs = [[False]*7 for _ in range(7)]
        for a in range(1, 7):
            for b in range(1, 7):
                gcd_pairs[a][b] = (math.gcd(a, b) == 1)
        
        dp = [[[0]*7 for _ in range(7)] for __ in range(n+1)]
        
        for a in range(1, 7):
            for b in range(1, 7):
                if a != b and gcd_pairs[a][b]:
                    dp[2][a][b] = 1
        
        for i in range(3, n+1):
            for a in range(1, 7):
                for b in range(1, 7):
                    if a == b or not gcd_pairs[a][b]:
                        continue
                    total = 0
                    for c in range(1, 7):
                        if c == a or not gcd_pairs[b][c]:
                            continue
                        total += dp[i-1][b][c]
                    dp[i][a][b] = total % MOD
        
        result = 0
        for a in range(1, 7):
            for b in range(1, 7):
                result = (result + dp[n][a][b]) % MOD
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 22, 'lineno': 2}, {'name': 'distinctSequences', 'complexity': 21, 'lineno': 3}], 'maintainability_index': 46.98853424412411, 'raw_metrics': {'loc': 31, 'lloc': 31, 'sloc': 31, 'comments': 0}}"
relocate-marbles,"```python
from typing import List

class Solution:
    def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:
        marble_positions = set(nums)
        for from_pos, to_pos in zip(moveFrom, moveTo):
            if from_pos in marble_positions:
                marble_positions.remove(from_pos)
                marble_positions.add(to_pos)
        return sorted(marble_positions)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'relocateMarbles', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 72.9066793577724, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
number-of-subarrays-with-gcd-equal-to-k,"```python
import math
from typing import List

class Solution:
    def subarrayGCD(self, nums: List[int], k: int) -> int:
        count = 0
        n = len(nums)
        for i in range(n):
            current_gcd = 0
            for j in range(i, n):
                current_gcd = math.gcd(current_gcd, nums[j])
                if current_gcd == k:
                    count += 1
                elif current_gcd < k:
                    break
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 4}, {'name': 'subarrayGCD', 'complexity': 5, 'lineno': 5}], 'maintainability_index': 63.105750114348254, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
house-robber-iv,"```python
class Solution:
    def minCapability(self, nums: List[int], k: int) -> int:
        left = min(nums)
        right = max(nums)
        
        def can_rob(mid):
            count = 0
            i = 0
            n = len(nums)
            while i < n:
                if nums[i] <= mid:
                    count += 1
                    i += 2
                else:
                    i += 1
                if count >= k:
                    return True
            return count >= k
        
        while left < right:
            mid = (left + right) // 2
            if can_rob(mid):
                right = mid
            else:
                left = mid + 1
        return left
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'minCapability', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 53.93621635846197, 'raw_metrics': {'loc': 25, 'lloc': 25, 'sloc': 25, 'comments': 0}}"
count-all-possible-routes,"```python
class Solution:
    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:
        MOD = 10**9 + 7
        n = len(locations)
        dp = [[0] * n for _ in range(fuel + 1)]
        dp[0][start] = 1
        
        for f in range(fuel + 1):
            for i in range(n):
                if dp[f][i] == 0:
                    continue
                for j in range(n):
                    if i == j:
                        continue
                    cost = abs(locations[i] - locations[j])
                    if f + cost <= fuel:
                        dp[f + cost][j] = (dp[f + cost][j] + dp[f][i]) % MOD
        
        total = 0
        for f in range(fuel + 1):
            total = (total + dp[f][finish]) % MOD
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 2}, {'name': 'countRoutes', 'complexity': 9, 'lineno': 3}], 'maintainability_index': 52.98948622380493, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
stamping-the-grid,"```python
class Solution:
    def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:
        m, n = len(grid), len(grid[0])
        
        prefix = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(m):
            row_sum = 0
            for j in range(n):
                row_sum += grid[i][j]
                prefix[i+1][j+1] = prefix[i][j+1] + row_sum
        
        diff = [[0] * (n + 2) for _ in range(m + 2)]
        for i in range(m - stampHeight + 1):
            for j in range(n - stampWidth + 1):
                x1, y1 = i, j
                x2, y2 = i + stampHeight - 1, j + stampWidth - 1
                total = prefix[x2+1][y2+1] - prefix[x1][y2+1] - prefix[x2+1][y1] + prefix[x1][y1]
                if total == 0:
                    diff[x1+1][y1+1] += 1
                    diff[x1+1][y2+2] -= 1
                    diff[x2+2][y1+1] -= 1
                    diff[x2+2][y2+2] += 1
        
        stamp = [[0] * (n + 1) for _ in range(m + 1)]
        possible = True
        for i in range(1, m + 1):
            row_sum = 0
            for j in range(1, n + 1):
                row_sum += diff[i][j]
                stamp[i][j] = stamp[i-1][j] + row_sum
                if grid[i-1][j-1] == 0 and stamp[i][j] == 0:
                    possible = False
                    break
            if not possible:
                break
        
        return possible
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 15, 'lineno': 2}, {'name': 'possibleToStamp', 'complexity': 14, 'lineno': 3}], 'maintainability_index': 43.91725967920082, 'raw_metrics': {'loc': 34, 'lloc': 34, 'sloc': 34, 'comments': 0}}"
number-of-flowers-in-full-bloom,"```python
import bisect
from typing import List

class Solution:
    def fullBloomFlowers(self, flowers: List[List[int]], people: List[int]) -> List[int]:
        starts = []
        ends = []
        for start, end in flowers:
            starts.append(start)
            ends.append(end + 1)
        
        starts.sort()
        ends.sort()
        
        res = []
        for person in people:
            i = bisect.bisect_right(starts, person)
            j = bisect.bisect_right(ends, person)
            res.append(i - j)
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 4}, {'name': 'fullBloomFlowers', 'complexity': 3, 'lineno': 5}], 'maintainability_index': 63.74288366959167, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
number-of-ways-of-cutting-a-pizza,"```python
class Solution:
    def ways(self, pizza: List[str], k: int) -> int:
        rows = len(pizza)
        cols = len(pizza[0])
        mod = 10**9 + 7
        
        prefix = [[0] * (cols + 1) for _ in range(rows + 1)]
        for i in range(rows - 1, -1, -1):
            for j in range(cols - 1, -1, -1):
                prefix[i][j] = prefix[i + 1][j] + prefix[i][j + 1] - prefix[i + 1][j + 1] + (1 if pizza[i][j] == 'A' else 0)
        
        dp = [[[0] * cols for _ in range(rows)] for __ in range(k + 1)]
        
        for i in range(rows):
            for j in range(cols):
                if prefix[i][j] > 0:
                    dp[1][i][j] = 1
        
        for m in range(2, k + 1):
            for i in range(rows):
                for j in range(cols):
                    total = 0
                    for x in range(i + 1, rows):
                        if prefix[i][j] - prefix[x][j] > 0:
                            total += dp[m - 1][x][j]
                            total %= mod
                    for y in range(j + 1, cols):
                        if prefix[i][j] - prefix[i][y] > 0:
                            total += dp[m - 1][i][y]
                            total %= mod
                    dp[m][i][j] = total
        
        return dp[k][0][0] % mod
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 18, 'lineno': 2}, {'name': 'ways', 'complexity': 17, 'lineno': 3}], 'maintainability_index': 46.4119705517664, 'raw_metrics': {'loc': 29, 'lloc': 29, 'sloc': 29, 'comments': 0}}"
minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits,"```python
import bisect

class Solution:
    def minInteger(self, num: str, k: int) -> str:
        num = list(num)
        n = len(num)
        pos = [[] for _ in range(10)]
        for idx, ch in enumerate(num):
            pos[int(ch)].append(idx)
        
        res = []
        bit = [0] * (n + 2)
        
        def update(i, delta):
            while i <= n:
                bit[i] += delta
                i += i & -i
        
        def query(i):
            res = 0
            while i > 0:
                res += bit[i]
                i -= i & -i
            return res
        
        for i in range(n):
            if k <= 0:
                break
            for d in range(10):
                if not pos[d]:
                    continue
                original_pos = pos[d][0]
                cost = original_pos - query(original_pos + 1)
                if cost <= k:
                    k -= cost
                    res.append(str(d))
                    update(original_pos + 1, 1)
                    pos[d].pop(0)
                    break
        
        remaining_indices = []
        for d in range(10):
            for p in pos[d]:
                remaining_indices.append((p, str(d)))
        remaining_indices.sort()
        res.extend([ch for _, ch in remaining_indices])
        
        return ''.join(res)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 2}, {'name': 'minInteger', 'complexity': 11, 'lineno': 3}], 'maintainability_index': 46.20830041008678, 'raw_metrics': {'loc': 41, 'lloc': 41, 'sloc': 41, 'comments': 0}}"
number-of-rectangles-that-can-form-the-largest-square,"```python
from typing import List

class Solution:
    def countGoodRectangles(self, rectangles: List[List[int]]) -> int:
        max_len = 0
        count = 0
        for rect in rectangles:
            current = min(rect)
            if current > max_len:
                max_len = current
                count = 1
            elif current == max_len:
                count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'countGoodRectangles', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 64.50528728424139, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
number-of-different-subsequences-gcds,"```python
import math
from typing import List

class Solution:
    def countDifferentSubsequenceGCDs(self, nums: List[int]) -> int:
        max_num = max(nums) if nums else 0
        present = [False] * (max_num + 1)
        for num in nums:
            present[num] = True
        
        res = 0
        for x in range(1, max_num + 1):
            current_gcd = 0
            for multiple in range(x, max_num + 1, x):
                if present[multiple]:
                    current_gcd = math.gcd(current_gcd, multiple)
                    if current_gcd == x:
                        res += 1
                        break
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 4}, {'name': 'countDifferentSubsequenceGCDs', 'complexity': 7, 'lineno': 5}], 'maintainability_index': 58.58907572756116, 'raw_metrics': {'loc': 19, 'lloc': 19, 'sloc': 19, 'comments': 0}}"
minimum-cost-to-cut-a-stick,"```python
from typing import List

class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:
        cuts = sorted(cuts)
        cuts = [0] + cuts + [n]
        m = len(cuts)
        dp = [[0] * m for _ in range(m)]
        
        for length in range(2, m):
            for i in range(m - length):
                j = i + length
                dp[i][j] = float('inf')
                for k in range(i + 1, j):
                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + cuts[j] - cuts[i])
        
        return dp[0][m - 1]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'minCost', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 58.85280145936119, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
number-of-ways-to-wear-different-hats-to-each-other,"```python
class Solution:
    def numberWays(self, hats: List[List[int]]) -> int:
        MOD = 10**9 + 7
        n = len(hats)
        hat_to_people = [[] for _ in range(41)]
        for person in range(n):
            for hat in hats[person]:
                hat_to_people[hat].append(person)
        
        dp = [0] * (1 << n)
        dp[0] = 1
        
        for hat in range(1, 41):
            for mask in range((1 << n) - 1, -1, -1):
                for person in hat_to_people[hat]:
                    if not (mask & (1 << person)):
                        new_mask = mask | (1 << person)
                        dp[new_mask] = (dp[new_mask] + dp[mask]) % MOD
        return dp[(1 << n) - 1] % MOD
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 2}, {'name': 'numberWays', 'complexity': 8, 'lineno': 3}], 'maintainability_index': 54.613540253358465, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
count-pairs-of-points-with-distance-k,"```python
from collections import defaultdict

class Solution:
    def countPairs(self, coordinates: List[List[int]], k: int) -> int:
        freq = defaultdict(int)
        res = 0
        for x, y in coordinates:
            for a in range(k + 1):
                b = k - a
                x_target = x ^ a
                y_target = y ^ b
                res += freq.get((x_target, y_target), 0)
            freq[(x, y)] += 1
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'countPairs', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 61.78844938400493, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
minimum-money-required-before-transactions,"```python
from typing import List

class Solution:
    def minimumMoney(self, transactions: List[List[int]]) -> int:
        total_loss = 0
        max_cashback = 0
        max_cost = 0
        
        for cost, cashback in transactions:
            if cost > cashback:
                total_loss += cost - cashback
                max_cashback = max(max_cashback, cashback)
            else:
                max_cost = max(max_cost, cost)
        
        return total_loss + max(max_cashback, max_cost)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'minimumMoney', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 63.56314197676087, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
get-the-maximum-score,"```python
class Solution:
    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:
        MOD = 10**9 + 7
        i, j = 0, 0
        m, n = len(nums1), len(nums2)
        sum1, sum2 = 0, 0
        max_sum = 0
        
        while i < m or j < n:
            if i < m and (j >= n or nums1[i] < nums2[j]):
                sum1 += nums1[i]
                i += 1
            elif j < n and (i >= m or nums2[j] < nums1[i]):
                sum2 += nums2[j]
                j += 1
            else:
                max_sum += max(sum1, sum2) + nums1[i]
                sum1, sum2 = 0, 0
                i += 1
                j += 1
        
        max_sum += max(sum1, sum2)
        return max_sum % MOD
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 2}, {'name': 'maxSum', 'complexity': 9, 'lineno': 3}], 'maintainability_index': 51.158262353902316, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
maximum-xor-with-an-element-from-array,"```python
class Solution:
    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        nums.sort()
        sorted_queries = sorted([(x, m, i) for i, (x, m) in enumerate(queries)], key=lambda q: q[1])
        
        trie = {}
        res = [-1] * len(queries)
        ptr = 0
        
        for x, m, idx in sorted_queries:
            while ptr < len(nums) and nums[ptr] <= m:
                num = nums[ptr]
                node = trie
                for i in range(30, -1, -1):
                    bit = (num >> i) & 1
                    if bit not in node:
                        node[bit] = {}
                    node = node[bit]
                ptr += 1
            
            if not trie:
                continue
            
            node = trie
            max_xor = 0
            for i in range(30, -1, -1):
                bit = (x >> i) & 1
                toggled_bit = 1 - bit
                if toggled_bit in node:
                    max_xor += (1 << i)
                    node = node[toggled_bit]
                else:
                    node = node.get(bit, {})
            res[idx] = max_xor
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 2}, {'name': 'maximizeXor', 'complexity': 10, 'lineno': 3}], 'maintainability_index': 48.34433754107066, 'raw_metrics': {'loc': 32, 'lloc': 33, 'sloc': 32, 'comments': 0}}"
minimum-operations-to-maximize-last-elements-in-arrays,"```python
from typing import List

class Solution:
    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        case1_possible = True
        case1_swaps = 0
        max1 = nums1[-1]
        max2 = nums2[-1]
        
        for i in range(n - 1):
            if nums1[i] > max1 or nums2[i] > max2:
                if nums2[i] > max1 or nums1[i] > max2:
                    case1_possible = False
                    break
                case1_swaps += 1
        
        case2_possible = True
        case2_swaps = 1
        max1_swapped = nums2[-1]
        max2_swapped = nums1[-1]
        
        for i in range(n - 1):
            if nums1[i] > max1_swapped or nums2[i] > max2_swapped:
                if nums2[i] > max1_swapped or nums1[i] > max2_swapped:
                    case2_possible = False
                    break
                case2_swaps += 1
        
        if case1_possible and case2_possible:
            return min(case1_swaps, case2_swaps)
        elif case1_possible:
            return case1_swaps
        elif case2_possible:
            return case2_swaps
        else:
            return -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 16, 'lineno': 3}, {'name': 'minOperations', 'complexity': 15, 'lineno': 4}], 'maintainability_index': 47.32804459993243, 'raw_metrics': {'loc': 33, 'lloc': 33, 'sloc': 33, 'comments': 0}}"
maximum-path-quality-of-a-graph,"```python
from typing import List
from collections import defaultdict

class Solution:
    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:
        graph = defaultdict(list)
        for u, v, time in edges:
            graph[u].append((v, time))
            graph[v].append((u, time))
        
        max_quality = 0
        visited = {0: 1}
        
        def dfs(node, current_time, current_quality):
            nonlocal max_quality
            if node == 0:
                max_quality = max(max_quality, current_quality)
            
            for neighbor, time in graph[node]:
                if current_time + time <= maxTime:
                    if neighbor not in visited:
                        visited[neighbor] = 1
                        dfs(neighbor, current_time + time, current_quality + values[neighbor])
                        del visited[neighbor]
                    else:
                        dfs(neighbor, current_time + time, current_quality)
        
        dfs(0, 0, values[0])
        return max_quality
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 4}, {'name': 'maximalPathQuality', 'complexity': 2, 'lineno': 5}], 'maintainability_index': 55.406584186095465, 'raw_metrics': {'loc': 25, 'lloc': 26, 'sloc': 25, 'comments': 0}}"
check-if-there-is-a-valid-parentheses-string-path,"```python
class Solution:
    def hasValidPath(self, grid: List[List[str]]) -> bool:
        m, n = len(grid), len(grid[0])
        max_len = m + n - 1
        if max_len % 2 != 0:
            return False
        
        from functools import lru_cache
        
        @lru_cache(maxsize=None)
        def dfs(i, j, balance):
            if balance < 0 or balance > (m + n - 1 - i - j):
                return False
            if i == m - 1 and j == n - 1:
                return balance == 1 and grid[i][j] == ')'
            res = False
            if i + 1 < m:
                if grid[i][j] == '(':
                    res = res or dfs(i + 1, j, balance + 1)
                else:
                    res = res or dfs(i + 1, j, balance - 1)
            if j + 1 < n:
                if grid[i][j] == '(':
                    res = res or dfs(i + 1, j, balance + 1) if i + 1 < m else False
                    res = res or dfs(i, j + 1, balance + 1)
                else:
                    res = res or dfs(i + 1, j, balance - 1) if i + 1 < m else False
                    res = res or dfs(i, j + 1, balance - 1)
            return res
        
        return dfs(0, 0, 0)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 2}, {'name': 'hasValidPath', 'complexity': 2, 'lineno': 3}], 'maintainability_index': 47.35405314864317, 'raw_metrics': {'loc': 29, 'lloc': 29, 'sloc': 29, 'comments': 0}}"
shortest-uncommon-substring-in-an-array,"```python
from typing import List

class Solution:
    def shortestSubstrings(self, arr: List[str]) -> List[str]:
        answer = []
        n = len(arr)
        
        for i in range(n):
            s = arr[i]
            min_sub = """"
            found = False
            
            for length in range(1, len(s) + 1):
                candidates = []
                for start in range(len(s) - length + 1):
                    substring = s[start:start+length]
                    unique = True
                    for j in range(n):
                        if j != i and substring in arr[j]:
                            unique = False
                            break
                    if unique:
                        candidates.append(substring)
                if candidates:
                    candidates.sort()
                    min_sub = candidates[0]
                    found = True
                    break
            answer.append(min_sub if found else """")
        
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 3}, {'name': 'shortestSubstrings', 'complexity': 10, 'lineno': 4}], 'maintainability_index': 53.08016594280924, 'raw_metrics': {'loc': 28, 'lloc': 29, 'sloc': 28, 'comments': 0}}"
next-greater-element-iv,"```python
class Solution:
    def secondGreaterElement(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = [-1] * n
        s1 = []
        s2 = []
        temp = []
        
        for i in range(n):
            while s2 and nums[s2[-1]] < nums[i]:
                res[s2.pop()] = nums[i]
            while s1 and nums[s1[-1]] < nums[i]:
                temp.append(s1.pop())
            while temp:
                s2.append(temp.pop())
            s1.append(i)
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 2}, {'name': 'secondGreaterElement', 'complexity': 7, 'lineno': 3}], 'maintainability_index': 58.68080100570502, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
maximum-total-reward-using-operations-i,"```python
class Solution:
    def maxTotalReward(self, rewardValues: List[int]) -> int:
        rewardValues = sorted(set(rewardValues))
        max_reward = 0
        dp = {0}
        
        for num in rewardValues:
            new_dp = set()
            for x in dp:
                if num > x:
                    new_x = x + num
                    new_dp.add(new_x)
                    if new_x > max_reward:
                        max_reward = new_x
            dp.update(new_dp)
        
        return max_reward
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'maxTotalReward', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 63.35672379559808, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
count-the-number-of-consistent-strings,"```python
class Solution:
    def countConsistentStrings(self, allowed: str, words: List[str]) -> int:
        allowed_set = set(allowed)
        count = 0
        for word in words:
            consistent = True
            for c in word:
                if c not in allowed_set:
                    consistent = False
                    break
            if consistent:
                count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'countConsistentStrings', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 65.85475135272073, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
fancy-sequence,"```python
MOD = 10**9 + 7

class Fancy:

    def __init__(self):
        self.sequence = []
        self.add = 0
        self.mul = 1

    def append(self, val: int) -> None:
        adjusted_val = (val - self.add) * pow(self.mul, -1, MOD) % MOD
        self.sequence.append(adjusted_val)

    def addAll(self, inc: int) -> None:
        self.add = (self.add + inc) % MOD

    def multAll(self, m: int) -> None:
        self.add = (self.add * m) % MOD
        self.mul = (self.mul * m) % MOD

    def getIndex(self, idx: int) -> int:
        if idx >= len(self.sequence):
            return -1
        return (self.sequence[idx] * self.mul + self.add) % MOD
```","{'cyclomatic_complexity': [{'name': 'Fancy', 'complexity': 2, 'lineno': 2}, {'name': '__init__', 'complexity': 1, 'lineno': 3}, {'name': 'append', 'complexity': 1, 'lineno': 7}, {'name': 'addAll', 'complexity': 1, 'lineno': 10}, {'name': 'multAll', 'complexity': 1, 'lineno': 12}, {'name': 'getIndex', 'complexity': 2, 'lineno': 15}], 'maintainability_index': 54.82224697995303, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
number-of-subarrays-with-lcm-equal-to-k,"```python
import math
from typing import List

class Solution:
    def subarrayLCM(self, nums: List[int], k: int) -> int:
        count = 0
        n = len(nums)
        for i in range(n):
            current_lcm = 1
            for j in range(i, n):
                current_lcm = math.lcm(current_lcm, nums[j])
                if current_lcm == k:
                    count += 1
                elif current_lcm > k:
                    break
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 4}, {'name': 'subarrayLCM', 'complexity': 5, 'lineno': 5}], 'maintainability_index': 63.105750114348254, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
delete-greatest-value-in-each-row,"```python
class Solution:
    def deleteGreatestValue(self, grid: List[List[int]]) -> int:
        answer = 0
        for row in grid:
            row.sort()
        for j in range(len(grid[0])):
            current_max = 0
            for i in range(len(grid)):
                if grid[i][j] > current_max:
                    current_max = grid[i][j]
            answer += current_max
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'deleteGreatestValue', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 66.88315906807695, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
minimum-number-of-operations-to-make-arrays-similar,"```python
class Solution:
    def makeSimilar(self, nums: List[int], target: List[int]) -> int:
        nums_odd = sorted([x for x in nums if x % 2 == 1])
        nums_even = sorted([x for x in nums if x % 2 == 0])
        target_odd = sorted([x for x in target if x % 2 == 1])
        target_even = sorted([x for x in target if x % 2 == 0])
        
        res = 0
        for a, b in zip(nums_odd, target_odd):
            if a > b:
                res += (a - b) // 2
        for a, b in zip(nums_even, target_even):
            if a > b:
                res += (a - b) // 2
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 14, 'lineno': 2}, {'name': 'makeSimilar', 'complexity': 13, 'lineno': 3}], 'maintainability_index': 56.18952351918515, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
sorting-the-sentence,"```python
class Solution:
    def sortSentence(self, s: str) -> str:
        words = s.split()
        words.sort(key=lambda x: int(x[-1]))
        original = [word[:-1] for word in words]
        return ' '.join(original)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 1}, {'name': 'sortSentence', 'complexity': 2, 'lineno': 2}], 'maintainability_index': 75.68088675261008, 'raw_metrics': {'loc': 6, 'lloc': 8, 'sloc': 6, 'comments': 0}}"
delete-duplicate-folders-in-system,"```python
class Solution:
    def deleteDuplicateFolder(self, paths: List[List[str]]) -> List[List[str]]:
        root = {}
        root[""#""] = {}  # dummy root
        
        for path in paths:
            node = root[""#""]
            for folder in path:
                if folder not in node:
                    node[folder] = {}
                node = node[folder]
        
        subtree_counts = defaultdict(int)
        subtree_serialization = {}
        
        def serialize(node):
            if not node:
                return ""#""
            keys = []
            for folder in sorted(node.keys()):
                serialized_child = serialize(node[folder])
                keys.append(f""{folder}:{serialized_child}"")
            key = ""("" + "","".join(keys) + "")""
            subtree_counts[key] += 1
            subtree_serialization[id(node)] = key
            return key
        
        serialize(root[""#""])
        
        to_delete = set()
        
        def mark_deletions(node):
            key = subtree_serialization.get(id(node), """")
            if key and subtree_counts[key] > 1 and key != ""()"":
                to_delete.add(id(node))
                return
            for folder in node:
                mark_deletions(node[folder])
        
        mark_deletions(root[""#""])
        
        result = []
        
        def collect_paths(node, current_path):
            for folder in node:
                if id(node[folder]) not in to_delete:
                    new_path = current_path + [folder]
                    result.append(new_path.copy())
                    collect_paths(node[folder], new_path)
        
        collect_paths(root[""#""], [])
        
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'deleteDuplicateFolder', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 57.76919979875608, 'raw_metrics': {'loc': 43, 'lloc': 43, 'sloc': 43, 'comments': 1}}"
count-ways-to-make-array-with-product,"```python
import math
from math import comb
from collections import defaultdict

MOD = 10**9 + 7

class Solution:
    def waysToFillArray(self, queries: List[List[int]]) -> List[int]:
        max_k = max(q[1] for q in queries) if queries else 0
        spf = list(range(max_k + 1))
        for i in range(2, int(math.isqrt(max_k)) + 1):
            if spf[i] == i:
                for j in range(i*i, max_k + 1, i):
                    if spf[j] == j:
                        spf[j] = i
        
        def factorize(x):
            factors = defaultdict(int)
            if x == 1:
                return factors
            while x > 1:
                p = spf[x]
                while x % p == 0:
                    factors[p] += 1
                    x = x // p
            return factors
        
        factorizations = {}
        for q in queries:
            k = q[1]
            if k not in factorizations:
                factorizations[k] = factorize(k)
        
        res = []
        for n, k in queries:
            if k == 1:
                res.append(1)
                continue
            factors = factorizations[k]
            total = 1
            for cnt in factors.values():
                total = total * comb(n + cnt - 1, cnt) % MOD
            res.append(total)
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 13, 'lineno': 6}, {'name': 'waysToFillArray', 'complexity': 12, 'lineno': 7}], 'maintainability_index': 45.881718426486024, 'raw_metrics': {'loc': 40, 'lloc': 40, 'sloc': 40, 'comments': 0}}"
alternating-groups-i,"```python
from typing import List

class Solution:
    def numberOfAlternatingGroups(self, colors: List[int]) -> int:
        n = len(colors)
        count = 0
        for i in range(n):
            left = colors[i]
            middle = colors[(i + 1) % n]
            right = colors[(i + 2) % n]
            if middle != left and middle != right:
                count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'numberOfAlternatingGroups', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 61.148075914321836, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
minimum-number-of-operations-to-make-array-xor-equal-to-k,"```python
from typing import List

class Solution:
    def minOperations(self, nums: List[int], k: int) -> int:
        xor = 0
        for num in nums:
            xor ^= num
        diff = xor ^ k
        return bin(diff).count('1')
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 3}, {'name': 'minOperations', 'complexity': 2, 'lineno': 4}], 'maintainability_index': 71.22423816857055, 'raw_metrics': {'loc': 9, 'lloc': 9, 'sloc': 9, 'comments': 0}}"
minimum-array-length-after-pair-removals,"```python
from typing import List

class Solution:
    def minLengthAfterRemovals(self, nums: List[int]) -> int:
        n = len(nums)
        left = 0
        right = (n + 1) // 2
        count = 0
        
        while right < n:
            if nums[left] < nums[right]:
                count += 1
                left += 1
            right += 1
        
        return n - 2 * count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'minLengthAfterRemovals', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 60.29395446002247, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
largest-odd-number-in-string,"```python
class Solution:
    def largestOddNumber(self, num: str) -> str:
        for i in range(len(num) - 1, -1, -1):
            if int(num[i]) % 2 != 0:
                return num[:i+1]
        return """"
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'largestOddNumber', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 68.71327751879107, 'raw_metrics': {'loc': 6, 'lloc': 7, 'sloc': 6, 'comments': 0}}"
maximum-number-of-fish-in-a-grid,"```python
from typing import List

class Solution:
    def findMaxFish(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        max_fish = 0
        
        def dfs(r, c):
            if r < 0 or r >= m or c < 0 or c >= n or grid[r][c] == 0:
                return 0
            fish = grid[r][c]
            grid[r][c] = 0  # Mark as visited
            fish += dfs(r + 1, c)
            fish += dfs(r - 1, c)
            fish += dfs(r, c + 1)
            fish += dfs(r, c - 1)
            return fish
        
        for i in range(m):
            for j in range(n):
                if grid[i][j] > 0:
                    current_fish = dfs(i, j)
                    if current_fish > max_fish:
                        max_fish = current_fish
        return max_fish
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'findMaxFish', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 65.00103889996275, 'raw_metrics': {'loc': 23, 'lloc': 23, 'sloc': 23, 'comments': 1}}"
minimum-element-after-replacement-with-digit-sum,"```python
from typing import List

class Solution:
    def minElement(self, nums: List[int]) -> int:
        min_val = float('inf')
        for num in nums:
            digit_sum = 0
            n = num
            while n > 0:
                digit_sum += n % 10
                n = n // 10
            if digit_sum < min_val:
                min_val = digit_sum
        return min_val
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'minElement', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 62.31676481653419, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
minimum-deletions-to-make-string-k-special,"```python
class Solution:
    def minimumDeletions(self, word: str, k: int) -> int:
        from collections import defaultdict

        freq = defaultdict(int)
        for c in word:
            freq[c] += 1
        
        frequencies = sorted(freq.values())
        min_deletions = float('inf')
        
        for i in range(len(frequencies)):
            target_min = frequencies[i]
            deletions = 0
            for j in range(len(frequencies)):
                if frequencies[j] < target_min:
                    deletions += frequencies[j]
                elif frequencies[j] > target_min + k:
                    deletions += frequencies[j] - (target_min + k)
            min_deletions = min(min_deletions, deletions)
        
        return min_deletions
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 1}, {'name': 'minimumDeletions', 'complexity': 6, 'lineno': 2}], 'maintainability_index': 57.79612100961952, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
find-the-number-of-distinct-colors-among-the-balls,"```python
from typing import List

class Solution:
    def queryResults(self, limit: int, queries: List[List[int]]) -> List[int]:
        color_count = {}
        ball_colors = {}
        result = []
        distinct_colors = 0
        
        for x, y in queries:
            if x in ball_colors:
                old_color = ball_colors[x]
                color_count[old_color] -= 1
                if color_count[old_color] == 0:
                    distinct_colors -= 1
                    del color_count[old_color]
            
            ball_colors[x] = y
            if y in color_count:
                color_count[y] += 1
            else:
                color_count[y] = 1
                distinct_colors += 1
            
            result.append(distinct_colors)
        
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'queryResults', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 56.16457109714564, 'raw_metrics': {'loc': 23, 'lloc': 23, 'sloc': 23, 'comments': 0}}"
maximum-total-damage-with-spell-casting,"```python
from collections import defaultdict
from typing import List

class Solution:
    def maximumTotalDamage(self, power: List[int]) -> int:
        freq = defaultdict(int)
        for p in power:
            freq[p] += 1
        
        unique_powers = sorted(freq.keys())
        n = len(unique_powers)
        dp = [0] * (n + 2)
        
        for i in range(n - 1, -1, -1):
            current_power = unique_powers[i]
            total = current_power * freq[current_power]
            
            next_allowed = i + 1
            while next_allowed < n:
                if unique_powers[next_allowed] > current_power + 2:
                    break
                next_allowed += 1
            
            if next_allowed < n:
                total += dp[next_allowed]
            
            dp[i] = max(total, dp[i + 1])
        
        return dp[0]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 4}, {'name': 'maximumTotalDamage', 'complexity': 6, 'lineno': 5}], 'maintainability_index': 53.465207410186466, 'raw_metrics': {'loc': 23, 'lloc': 23, 'sloc': 23, 'comments': 0}}"
closest-room,"```python
import bisect

class Solution:
    def closestRoom(self, rooms: List[List[int]], queries: List[List[int]]) -> List[int]:
        rooms.sort(key=lambda x: -x[1])
        
        sorted_queries = []
        for idx, (preferred, minSize) in enumerate(queries):
            sorted_queries.append((minSize, preferred, idx))
        sorted_queries.sort(reverse=True, key=lambda x: x[0])
        
        room_ids = []
        res = [-1] * len(queries)
        ptr = 0
        n = len(rooms)
        
        for minSize, preferred, original_idx in sorted_queries:
            while ptr < n and rooms[ptr][1] >= minSize:
                bisect.insort(room_ids, rooms[ptr][0])
                ptr += 1
            
            if not room_ids:
                res[original_idx] = -1
                continue
            
            pos = bisect.bisect_left(room_ids, preferred)
            candidates = []
            if pos > 0:
                candidates.append(room_ids[pos - 1])
            if pos < len(room_ids):
                candidates.append(room_ids[pos])
            
            min_diff = float('inf')
            best_id = -1
            for id in candidates:
                current_diff = abs(id - preferred)
                if current_diff < min_diff:
                    min_diff = current_diff
                    best_id = id
                elif current_diff == min_diff and id < best_id:
                    best_id = id
            res[original_idx] = best_id
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 13, 'lineno': 3}, {'name': 'closestRoom', 'complexity': 12, 'lineno': 4}], 'maintainability_index': 46.84304912661806, 'raw_metrics': {'loc': 37, 'lloc': 39, 'sloc': 37, 'comments': 0}}"
frequency-tracker,"```python
class FrequencyTracker:

    def __init__(self):
        self.number_counts = {}
        self.frequency_counts = {}

    def add(self, number: int) -> None:
        if number in self.number_counts:
            old_freq = self.number_counts[number]
            self.frequency_counts[old_freq] -= 1
            if self.frequency_counts[old_freq] == 0:
                del self.frequency_counts[old_freq]
            new_freq = old_freq + 1
            self.number_counts[number] = new_freq
            self.frequency_counts[new_freq] = self.frequency_counts.get(new_freq, 0) + 1
        else:
            self.number_counts[number] = 1
            self.frequency_counts[1] = self.frequency_counts.get(1, 0) + 1

    def deleteOne(self, number: int) -> None:
        if number in self.number_counts:
            old_freq = self.number_counts[number]
            self.frequency_counts[old_freq] -= 1
            if self.frequency_counts[old_freq] == 0:
                del self.frequency_counts[old_freq]
            new_freq = old_freq - 1
            if new_freq == 0:
                del self.number_counts[number]
            else:
                self.number_counts[number] = new_freq
                self.frequency_counts[new_freq] = self.frequency_counts.get(new_freq, 0) + 1

    def hasFrequency(self, frequency: int) -> bool:
        return frequency in self.frequency_counts


```","{'cyclomatic_complexity': [{'name': 'FrequencyTracker', 'complexity': 3, 'lineno': 1}, {'name': '__init__', 'complexity': 1, 'lineno': 2}, {'name': 'add', 'complexity': 3, 'lineno': 5}, {'name': 'deleteOne', 'complexity': 4, 'lineno': 17}, {'name': 'hasFrequency', 'complexity': 1, 'lineno': 29}], 'maintainability_index': 50.661763647286676, 'raw_metrics': {'loc': 30, 'lloc': 30, 'sloc': 30, 'comments': 0}}"
minimum-common-value,"```python
class Solution:
    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:
        i = j = 0
        len1, len2 = len(nums1), len(nums2)
        
        while i < len1 and j < len2:
            if nums1[i] == nums2[j]:
                return nums1[i]
            elif nums1[i] < nums2[j]:
                i += 1
            else:
                j += 1
        return -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'getCommon', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 61.14299404003982, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
design-task-manager,"```python
import heapq
from typing import List

class TaskManager:

    def __init__(self, tasks: List[List[int]]):
        self.task_map = {}  # Maps taskId to (priority, userId)
        self.priority_queue = []  # Max-heap based on (-priority, -taskId)
        for task in tasks:
            userId, taskId, priority = task
            self.add(userId, taskId, priority)

    def add(self, userId: int, taskId: int, priority: int) -> None:
        self.task_map[taskId] = (priority, userId)
        heapq.heappush(self.priority_queue, (-priority, -taskId))

    def edit(self, taskId: int, newPriority: int) -> None:
        old_priority, userId = self.task_map[taskId]
        self.task_map[taskId] = (newPriority, userId)
        heapq.heappush(self.priority_queue, (-newPriority, -taskId))

    def rmv(self, taskId: int) -> None:
        if taskId in self.task_map:
            del self.task_map[taskId]

    def execTop(self) -> int:
        while self.priority_queue:
            neg_priority, neg_taskId = self.priority_queue[0]
            taskId = -neg_taskId
            if taskId in self.task_map:
                current_priority, userId = self.task_map[taskId]
                if current_priority == -neg_priority:
                    heapq.heappop(self.priority_queue)
                    del self.task_map[taskId]
                    return userId
            heapq.heappop(self.priority_queue)
        return -1
```","{'cyclomatic_complexity': [{'name': 'TaskManager', 'complexity': 3, 'lineno': 4}, {'name': '__init__', 'complexity': 2, 'lineno': 5}, {'name': 'add', 'complexity': 1, 'lineno': 11}, {'name': 'edit', 'complexity': 1, 'lineno': 14}, {'name': 'rmv', 'complexity': 2, 'lineno': 18}, {'name': 'execTop', 'complexity': 4, 'lineno': 21}], 'maintainability_index': 66.415092009933, 'raw_metrics': {'loc': 32, 'lloc': 32, 'sloc': 32, 'comments': 2}}"
number-of-unique-good-subsequences,"```python
class Solution:
    def numberOfUniqueGoodSubsequences(self, binary: str) -> int:
        MOD = 10**9 + 7
        ends0 = 0  # number of unique subsequences ending with 0
        ends1 = 0   # number of unique subsequences ending with 1
        has0 = 0    # whether '0' has appeared in the binary string
        
        for c in binary:
            if c == '0':
                ends0 = (ends0 + ends1) % MOD
                has0 = 1
            else:
                ends1 = (ends0 + ends1 + 1) % MOD
        
        return (ends0 + ends1 + has0) % MOD
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'numberOfUniqueGoodSubsequences', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 84.61018422202717, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 3}}"
number-of-great-partitions,"```python
class Solution:
    def countPartitions(self, nums: List[int], k: int) -> int:
        MOD = 10**9 + 7
        total = sum(nums)
        if total < 2 * k:
            return 0
        
        dp = [0] * k
        dp[0] = 1
        for num in nums:
            for j in range(k - 1, num - 1, -1):
                dp[j] = (dp[j] + dp[j - num]) % MOD
        
        total_partitions = pow(2, len(nums), MOD)
        invalid_partitions = 2 * sum(dp) % MOD
        return (total_partitions - invalid_partitions) % MOD
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'countPartitions', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 57.39007961322589, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
count-alternating-subarrays,"```python
from typing import List

class Solution:
    def countAlternatingSubarrays(self, nums: List[int]) -> int:
        total = 0
        current = 1
        
        for i in range(1, len(nums)):
            if nums[i] != nums[i-1]:
                current += 1
            else:
                total += current * (current + 1) // 2
                current = 1
        total += current * (current + 1) // 2
        
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'countAlternatingSubarrays', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 59.485591858838454, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
maximum-or,"```python
from typing import List

class Solution:
    def maximumOr(self, nums: List[int], k: int) -> int:
        max_or = 0
        prefix = [0] * (len(nums) + 1)
        suffix = [0] * (len(nums) + 1)
        
        for i in range(len(nums)):
            prefix[i+1] = prefix[i] | nums[i]
        
        for i in range(len(nums)-1, -1, -1):
            suffix[i] = suffix[i+1] | nums[i]
        
        max_or = 0
        for i in range(len(nums)):
            current = nums[i] << k
            total = prefix[i] | current | suffix[i+1]
            if total > max_or:
                max_or = total
        
        return max_or
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'maximumOr', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 55.39314488490403, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
minimum-operations-to-make-a-subsequence,"```python
import bisect
from typing import List

class Solution:
    def minOperations(self, target: List[int], arr: List[int]) -> int:
        value_to_index = {v: i for i, v in enumerate(target)}
        indices = []
        for num in arr:
            if num in value_to_index:
                idx = value_to_index[num]
                pos = bisect.bisect_left(indices, idx)
                if pos == len(indices):
                    indices.append(idx)
                else:
                    indices[pos] = idx
        return len(target) - len(indices)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 4}, {'name': 'minOperations', 'complexity': 5, 'lineno': 5}], 'maintainability_index': 62.16204373953085, 'raw_metrics': {'loc': 16, 'lloc': 17, 'sloc': 16, 'comments': 0}}"
minimum-score-after-removals-on-a-tree,"```python
from typing import List

class Solution:
    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:
        n = len(nums)
        adj = [[] for _ in range(n)]
        for a, b in edges:
            adj[a].append(b)
            adj[b].append(a)
        
        xor = [0] * n
        parent = [0] * n
        in_time = [0] * n
        out_time = [0] * n
        time = 0
        
        stack = [(0, -1, False)]
        
        while stack:
            node, p, visited = stack.pop()
            if not visited:
                parent[node] = p
                in_time[node] = time
                time += 1
                stack.append((node, p, True))
                for neighbor in adj[node]:
                    if neighbor != p:
                        stack.append((neighbor, node, False))
            else:
                xor[node] = nums[node]
                for neighbor in adj[node]:
                    if neighbor != p:
                        xor[node] ^= xor[neighbor]
                out_time[node] = time - 1
        
        total_xor = xor[0]
        min_score = float('inf')
        
        for i in range(1, n):
            for j in range(i + 1, n):
                if in_time[i] < in_time[j] <= out_time[i]:
                    x = xor[j]
                    y = xor[i] ^ xor[j]
                    z = total_xor ^ xor[i]
                elif in_time[j] < in_time[i] <= out_time[j]:
                    x = xor[i]
                    y = xor[j] ^ xor[i]
                    z = total_xor ^ xor[j]
                else:
                    x = xor[i]
                    y = xor[j]
                    z = total_xor ^ x ^ y
                current_max = max(x, y, z)
                current_min = min(x, y, z)
                min_score = min(min_score, current_max - current_min)
        
        return min_score
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 14, 'lineno': 3}, {'name': 'minimumScore', 'complexity': 13, 'lineno': 4}], 'maintainability_index': 43.090096787353865, 'raw_metrics': {'loc': 51, 'lloc': 51, 'sloc': 51, 'comments': 0}}"
find-the-distinct-difference-array,"```python
class Solution:
    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        prefix = [0] * n
        suffix = [0] * n
        
        seen = set()
        for i in range(n):
            seen.add(nums[i])
            prefix[i] = len(seen)
        
        seen = set()
        for i in range(n-1, -1, -1):
            suffix[i] = len(seen)
            seen.add(nums[i])
        
        diff = []
        for i in range(n):
            diff.append(prefix[i] - suffix[i])
        
        return diff
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'distinctDifferenceArray', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 60.0054005478901, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
collect-coins-in-a-tree,"```python
from typing import List
from collections import deque

class Solution:
    def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:
        n = len(coins)
        if n == 1:
            return 0
        
        graph = [[] for _ in range(n)]
        degree = [0] * n
        for a, b in edges:
            graph[a].append(b)
            graph[b].append(a)
            degree[a] += 1
            degree[b] += 1
        
        q = deque()
        for i in range(n):
            if degree[i] == 1 and coins[i] == 0:
                q.append(i)
        
        remaining_nodes = n
        while q:
            u = q.popleft()
            remaining_nodes -= 1
            for v in graph[u]:
                if degree[v] > 0:
                    degree[v] -= 1
                    if degree[v] == 1 and coins[v] == 0:
                        q.append(v)
        
        q = deque()
        for i in range(n):
            if degree[i] == 1 and coins[i] == 1:
                q.append(i)
        
        for _ in range(2):
            sz = len(q)
            for __ in range(sz):
                u = q.popleft()
                remaining_nodes -= 1
                for v in graph[u]:
                    if degree[v] > 0:
                        degree[v] -= 1
                        if degree[v] == 1:
                            q.append(v)
        
        if remaining_nodes <= 1:
            return 0
        return 2 * (remaining_nodes - 1)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 22, 'lineno': 4}, {'name': 'collectTheCoins', 'complexity': 21, 'lineno': 5}], 'maintainability_index': 43.18109390347199, 'raw_metrics': {'loc': 45, 'lloc': 45, 'sloc': 45, 'comments': 0}}"
maximum-sum-of-an-hourglass,"```python
from typing import List

class Solution:
    def maxSum(self, grid: List[List[int]]) -> int:
        max_sum = 0
        m = len(grid)
        n = len(grid[0])
        
        for i in range(m - 2):
            for j in range(n - 2):
                current_sum = (
                    grid[i][j] + grid[i][j+1] + grid[i][j+2] +
                    grid[i+1][j+1] +
                    grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]
                )
                if current_sum > max_sum:
                    max_sum = current_sum
        
        return max_sum
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'maxSum', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 58.308037887269826, 'raw_metrics': {'loc': 17, 'lloc': 13, 'sloc': 17, 'comments': 0}}"
count-visited-nodes-in-a-directed-graph,"```python
class Solution:
    def countVisitedNodes(self, edges: List[int]) -> List[int]:
        n = len(edges)
        res = [0] * n
        visited = [False] * n
        
        for i in range(n):
            if not visited[i]:
                path = []
                current = i
                while True:
                    if visited[current]:
                        if current in path:
                            idx = path.index(current)
                            cycle_length = len(path) - idx
                            for node in path[idx:]:
                                res[node] = cycle_length
                            for j in range(idx):
                                res[path[j]] = cycle_length + idx - j
                        else:
                            for j in range(len(path)):
                                res[path[j]] = res[current] + len(path) - j
                        break
                    visited[current] = True
                    path.append(current)
                    current = edges[current]
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 2}, {'name': 'countVisitedNodes', 'complexity': 9, 'lineno': 3}], 'maintainability_index': 53.12508680027992, 'raw_metrics': {'loc': 27, 'lloc': 27, 'sloc': 27, 'comments': 0}}"
maximum-points-inside-the-square,"```python
class Solution:
    def maxPointsInsideSquare(self, points: List[List[int]], s: str) -> int:
        max_side = []
        for x, y in points:
            current_max = max(abs(x), abs(y))
            max_side.append(current_max)
        
        tagged_sides = list(zip(max_side, s))
        
        tagged_sides.sort()
        
        seen_tags = set()
        result = 0
        prev_side = -1
        temp_count = 0
        
        for side, tag in tagged_sides:
            if side != prev_side:
                if len(seen_tags) == temp_count:
                    result = temp_count
                else:
                    break
                prev_side = side
            
            if tag in seen_tags:
                break
            seen_tags.add(tag)
            temp_count += 1
        
        else:
            if len(seen_tags) == temp_count:
                result = temp_count
        
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 2}, {'name': 'maxPointsInsideSquare', 'complexity': 8, 'lineno': 3}], 'maintainability_index': 54.62668358968102, 'raw_metrics': {'loc': 28, 'lloc': 28, 'sloc': 28, 'comments': 0}}"
minimum-number-of-coins-to-be-added,"```python
class Solution:
    def minimumAddedCoins(self, coins: List[int], target: int) -> int:
        coins.sort()
        res = 0
        current_max = 0
        i = 0
        n = len(coins)
        
        while current_max < target:
            if i < n and coins[i] <= current_max + 1:
                current_max += coins[i]
                i += 1
            else:
                res += 1
                current_max += current_max + 1
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'minimumAddedCoins', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 58.5024009574555, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
separate-the-digits-in-an-array,"```python
class Solution:
    def separateDigits(self, nums: List[int]) -> List[int]:
        answer = []
        for num in nums:
            digits = []
            while num > 0:
                digits.append(num % 10)
                num = num // 10
            answer.extend(reversed(digits)) if digits else answer.append(0)
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'separateDigits', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 67.04095413533541, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
find-a-safe-walk-through-a-grid,"```python
from typing import List
import heapq

class Solution:
    def findSafeWalk(self, grid: List[List[int]], health: int) -> bool:
        m, n = len(grid), len(grid[0])
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        heap = []
        max_health = [[-1 for _ in range(n)] for _ in range(m)]
        
        initial_health = health - grid[0][0]
        if initial_health <= 0:
            return False
        
        heapq.heappush(heap, (-initial_health, 0, 0))
        max_health[0][0] = initial_health
        
        while heap:
            neg_health, x, y = heapq.heappop(heap)
            current_health = -neg_health
            
            if x == m - 1 and y == n - 1:
                return True
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < n:
                    new_health = current_health - grid[nx][ny]
                    if new_health > max_health[nx][ny] and new_health > 0:
                        max_health[nx][ny] = new_health
                        heapq.heappush(heap, (-new_health, nx, ny))
        
        return False
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 13, 'lineno': 4}, {'name': 'findSafeWalk', 'complexity': 12, 'lineno': 5}], 'maintainability_index': 49.43391734142859, 'raw_metrics': {'loc': 27, 'lloc': 27, 'sloc': 27, 'comments': 0}}"
find-the-minimum-area-to-cover-all-ones-i,"```python
from typing import List

class Solution:
    def minimumArea(self, grid: List[List[int]]) -> int:
        rows = len(grid)
        if rows == 0:
            return 0
        cols = len(grid[0])
        
        min_row = rows
        max_row = -1
        min_col = cols
        max_col = -1
        
        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == 1:
                    if i < min_row:
                        min_row = i
                    if i > max_row:
                        max_row = i
                    if j < min_col:
                        min_col = j
                    if j > max_col:
                        max_col = j
        
        if max_row == -1:  # no 1s found (though constraints say there's at least one)
            return 0
        
        height = max_row - min_row + 1
        width = max_col - min_col + 1
        
        return height * width
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 3}, {'name': 'minimumArea', 'complexity': 10, 'lineno': 4}], 'maintainability_index': 62.199437946018975, 'raw_metrics': {'loc': 28, 'lloc': 28, 'sloc': 28, 'comments': 1}}"
convert-1d-array-into-2d-array,"```python
from typing import List

class Solution:
    def construct2DArray(self, original: List[int], m: int, n: int) -> List[List[int]]:
        if len(original) != m * n:
            return []
        return [original[i*n : (i+1)*n] for i in range(m)]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'construct2DArray', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 67.87622811505331, 'raw_metrics': {'loc': 7, 'lloc': 8, 'sloc': 7, 'comments': 0}}"
maximum-multiplication-score,"```python
from typing import List

class Solution:
    def maxScore(self, a: List[int], b: List[int]) -> int:
        n = len(b)
        
        dp0 = [0] * n
        dp1 = [0] * n
        dp2 = [0] * n
        dp3 = [0] * n
        
        for i in range(n):
            dp0[i] = a[0] * b[i]
        
        max_dp0 = -float('inf')
        for i in range(1, n):
            if dp0[i-1] > max_dp0:
                max_dp0 = dp0[i-1]
            dp1[i] = max_dp0 + a[1] * b[i]
        
        max_dp1 = -float('inf')
        for i in range(2, n):
            if dp1[i-1] > max_dp1:
                max_dp1 = dp1[i-1]
            dp2[i] = max_dp1 + a[2] * b[i]
        
        max_dp2 = -float('inf')
        for i in range(3, n):
            if dp2[i-1] > max_dp2:
                max_dp2 = dp2[i-1]
            dp3[i] = max_dp2 + a[3] * b[i]
        
        if n < 4:
            return 0
        return max(dp3[3:])
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 3}, {'name': 'maxScore', 'complexity': 9, 'lineno': 4}], 'maintainability_index': 48.61052427470797, 'raw_metrics': {'loc': 29, 'lloc': 30, 'sloc': 29, 'comments': 0}}"
maximum-score-from-performing-multiplication-operations,"```python
from typing import List

class Solution:
    def maximumScore(self, nums: List[int], multipliers: List[int]) -> int:
        m = len(multipliers)
        n = len(nums)
        dp = [[0] * (m + 1) for _ in range(m + 1)]
        
        for i in range(m - 1, -1, -1):
            for left in range(i, -1, -1):
                right = n - 1 - (i - left)
                dp[i][left] = max(
                    multipliers[i] * nums[left] + dp[i + 1][left + 1],
                    multipliers[i] * nums[right] + dp[i + 1][left]
                )
        
        return dp[0][0]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'maximumScore', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 59.38990431438096, 'raw_metrics': {'loc': 15, 'lloc': 12, 'sloc': 15, 'comments': 0}}"
find-subarray-with-bitwise-or-closest-to-k,"```python
class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        min_diff = float('inf')
        current_or_sets = set()
        
        for num in nums:
            new_or_sets = {num}
            for val in current_or_sets:
                new_or = val | num
                new_or_sets.add(new_or)
            current_or_sets = new_or_sets
            
            for val in current_or_sets:
                diff = abs(val - k)
                if diff < min_diff:
                    min_diff = diff
                    if min_diff == 0:
                        return 0
        
        return min_diff
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 2}, {'name': 'minimumDifference', 'complexity': 6, 'lineno': 3}], 'maintainability_index': 60.46878774319913, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
maximum-score-of-a-node-sequence,"```python
from collections import defaultdict

class Solution:
    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:
        graph = defaultdict(list)
        for a, b in edges:
            graph[a].append((scores[b], b))
            graph[b].append((scores[a], a))
        
        for node in graph:
            graph[node].sort(reverse=True)
            graph[node] = graph[node][:3]
        
        max_score = -1
        
        for a, b in edges:
            for (score_c, c) in graph[a]:
                if c == b:
                    continue
                for (score_d, d) in graph[b]:
                    if d == a or d == c:
                        continue
                    current_sum = scores[a] + scores[b] + scores[c] + scores[d]
                    if current_sum > max_score:
                        max_score = current_sum
        
        return max_score
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 3}, {'name': 'maximumScore', 'complexity': 10, 'lineno': 4}], 'maintainability_index': 54.05390498346736, 'raw_metrics': {'loc': 23, 'lloc': 24, 'sloc': 23, 'comments': 0}}"
rearrange-array-to-maximize-prefix-score,"```python
class Solution:
    def maxScore(self, nums: List[int]) -> int:
        nums.sort(reverse=True)
        prefix_sum = 0
        score = 0
        for num in nums:
            prefix_sum += num
            if prefix_sum > 0:
                score += 1
            else:
                break
        return score
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'maxScore', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 65.34186573388484, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
find-the-number-of-good-pairs-i,"```python
from typing import List

class Solution:
    def numberOfPairs(self, nums1: List[int], nums2: List[int], k: int) -> int:
        count = 0
        for i in range(len(nums1)):
            for j in range(len(nums2)):
                if nums1[i] % (nums2[j] * k) == 0:
                    count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'numberOfPairs', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 66.07457148659327, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
prime-pairs-with-target-sum,"```python
class Solution:
    def findPrimePairs(self, n: int) -> List[List[int]]:
        if n < 2:
            return []
        
        sieve = [True] * (n + 1)
        sieve[0] = sieve[1] = False
        for i in range(2, int(n ** 0.5) + 1):
            if sieve[i]:
                sieve[i*i::i] = [False] * len(sieve[i*i::i])
        
        primes = [i for i, is_prime in enumerate(sieve) if is_prime]
        prime_set = set(primes)
        result = []
        
        for x in primes:
            y = n - x
            if y < x:
                break
            if y in prime_set:
                result.append([x, y])
        
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 2}, {'name': 'findPrimePairs', 'complexity': 9, 'lineno': 3}], 'maintainability_index': 54.780967745447576, 'raw_metrics': {'loc': 20, 'lloc': 21, 'sloc': 20, 'comments': 0}}"
count-number-of-possible-root-nodes,"```python
from collections import defaultdict
from typing import List

class Solution:
    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:
        tree = defaultdict(list)
        for u, v in edges:
            tree[u].append(v)
            tree[v].append(u)
        
        guess_set = set((u, v) for u, v in guesses)
        
        parent = {}
        stack = [(0, None)]
        correct = 0
        
        while stack:
            node, par = stack.pop()
            parent[node] = par
            if par is not None and (par, node) in guess_set:
                correct += 1
            for neighbor in tree[node]:
                if neighbor != par:
                    stack.append((neighbor, node))
        
        res = 0
        if correct >= k:
            res += 1
        
        stack = [(0, correct)]
        while stack:
            node, current_correct = stack.pop()
            for neighbor in tree[node]:
                if neighbor == parent[node]:
                    continue
                new_correct = current_correct
                if (node, neighbor) in guess_set:
                    new_correct -= 1
                if (neighbor, node) in guess_set:
                    new_correct += 1
                if new_correct >= k:
                    res += 1
                stack.append((neighbor, new_correct))
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 16, 'lineno': 4}, {'name': 'rootCount', 'complexity': 15, 'lineno': 5}], 'maintainability_index': 47.18483084085892, 'raw_metrics': {'loc': 39, 'lloc': 39, 'sloc': 39, 'comments': 0}}"
minimum-xor-sum-of-two-arrays,"```python
class Solution:
    def minimumXORSum(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        dp = [float('inf')] * (1 << n)
        dp[0] = 0
        
        for mask in range(1 << n):
            cnt = bin(mask).count('1')
            for j in range(n):
                if not (mask & (1 << j)):
                    next_mask = mask | (1 << j)
                    dp[next_mask] = min(dp[next_mask], dp[mask] + (nums1[cnt] ^ nums2[j]))
        
        return dp[(1 << n) - 1]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'minimumXORSum', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 59.67011674563298, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
checking-existence-of-edge-length-limited-paths,"```python
class Solution:
    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:
        parent = list(range(n))
        
        def find(u):
            while parent[u] != u:
                parent[u] = parent[parent[u]]
                u = parent[u]
            return u
        
        def union(u, v):
            u_root = find(u)
            v_root = find(v)
            if u_root != v_root:
                parent[v_root] = u_root
        
        edgeList.sort(key=lambda x: x[2])
        
        indexed_queries = [(i, p, q, limit) for i, (p, q, limit) in enumerate(queries)]
        indexed_queries.sort(key=lambda x: x[3])
        
        answer = [False] * len(queries)
        edge_idx = 0
        m = len(edgeList)
        
        for i, p, q, limit in indexed_queries:
            while edge_idx < m and edgeList[edge_idx][2] < limit:
                u, v, _ = edgeList[edge_idx]
                union(u, v)
                edge_idx += 1
            answer[i] = (find(p) == find(q))
        
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'distanceLimitedPathsExist', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 53.127877993446326, 'raw_metrics': {'loc': 27, 'lloc': 29, 'sloc': 27, 'comments': 0}}"
continuous-subarrays,"```python
from collections import deque

class Solution:
    def continuousSubarrays(self, nums: List[int]) -> int:
        min_deque = deque()
        max_deque = deque()
        left = 0
        res = 0
        
        for right, num in enumerate(nums):
            while min_deque and nums[min_deque[-1]] >= num:
                min_deque.pop()
            min_deque.append(right)
            
            while max_deque and nums[max_deque[-1]] <= num:
                max_deque.pop()
            max_deque.append(right)
            
            while nums[max_deque[0]] - nums[min_deque[0]] > 2:
                left += 1
                while min_deque[0] < left:
                    min_deque.popleft()
                while max_deque[0] < left:
                    max_deque.popleft()
            
            res += right - left + 1
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 3}, {'name': 'continuousSubarrays', 'complexity': 9, 'lineno': 4}], 'maintainability_index': 52.9912986835378, 'raw_metrics': {'loc': 23, 'lloc': 23, 'sloc': 23, 'comments': 0}}"
minimum-number-of-flips-to-make-binary-grid-palindromic-i,"```python
from typing import List

class Solution:
    def minFlips(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0]) if m > 0 else 0
        
        def calculate_row_flips():
            flips = 0
            for row in grid:
                left, right = 0, n - 1
                while left < right:
                    if row[left] != row[right]:
                        flips += 1
                    left += 1
                    right -= 1
            return flips
        
        def calculate_col_flips():
            flips = 0
            for j in range(n):
                top, bottom = 0, m - 1
                while top < bottom:
                    if grid[top][j] != grid[bottom][j]:
                        flips += 1
                    top += 1
                    bottom -= 1
            return flips
        
        if m == 0 or n == 0:
            return 0
        
        row_flips = calculate_row_flips()
        col_flips = calculate_col_flips()
        
        return min(row_flips, col_flips)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'minFlips', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 50.31657924642442, 'raw_metrics': {'loc': 31, 'lloc': 31, 'sloc': 31, 'comments': 0}}"
length-of-the-longest-subsequence-that-sums-to-target,"```python
from typing import List

class Solution:
    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:
        dp = [-1] * (target + 1)
        dp[0] = 0
        for num in nums:
            for t in range(target, num - 1, -1):
                if dp[t - num] != -1:
                    if dp[t] < dp[t - num] + 1:
                        dp[t] = dp[t - num] + 1
        return dp[target]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'lengthOfLongestSubsequence', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 60.412364872204236, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
difference-between-maximum-and-minimum-price-sum,"```python
from typing import List
import collections

class Solution:
    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:
        tree = collections.defaultdict(list)
        for u, v in edges:
            tree[u].append(v)
            tree[v].append(u)
        
        res = 0
        
        def dfs(node, parent):
            nonlocal res
            max1 = price[node]
            max2 = 0
            for neighbor in tree[node]:
                if neighbor == parent:
                    continue
                cmax1, cmax2 = dfs(neighbor, node)
                res = max(res, max1 + cmax2, max2 + cmax1)
                max1 = max(max1, cmax1 + price[node])
                max2 = max(max2, cmax2 + price[node])
            return (max1, max2)
        
        dfs(0, -1)
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 4}, {'name': 'maxOutput', 'complexity': 2, 'lineno': 5}], 'maintainability_index': 56.990484729091584, 'raw_metrics': {'loc': 24, 'lloc': 24, 'sloc': 24, 'comments': 0}}"
number-of-ways-to-paint-n-3-grid,"```python
class Solution:
    def numOfWays(self, n: int) -> int:
        MOD = 10**9 + 7
        aba = 6
        abc = 6
        
        for _ in range(2, n+1):
            new_aba = (aba * 3 + abc * 2) % MOD
            new_abc = (aba * 2 + abc * 2) % MOD
            aba, abc = new_aba, new_abc
        
        return (aba + abc) % MOD
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 1}, {'name': 'numOfWays', 'complexity': 2, 'lineno': 2}], 'maintainability_index': 62.09560823349506, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
restore-the-array,"```python
class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:
        n = len(s)
        mod = 10**9 + 7
        dp = [0] * (n + 1)
        dp[n] = 1  # empty string has one way
        
        for i in range(n - 1, -1, -1):
            if s[i] == '0':
                dp[i] = 0
                continue
            num = 0
            res = 0
            for j in range(i, n):
                num = num * 10 + int(s[j])
                if num > k:
                    break
                res += dp[j + 1]
                res %= mod
            dp[i] = res
        return dp[0]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 1}, {'name': 'numberOfArrays', 'complexity': 5, 'lineno': 2}], 'maintainability_index': 67.95652998984694, 'raw_metrics': {'loc': 20, 'lloc': 20, 'sloc': 20, 'comments': 1}}"
maximum-number-of-jumps-to-reach-the-last-index,"```python
from typing import List

class Solution:
    def maximumJumps(self, nums: List[int], target: int) -> int:
        n = len(nums)
        dp = [-1] * n
        dp[0] = 0
        
        for i in range(n):
            if dp[i] == -1:
                continue
            for j in range(i + 1, n):
                diff = nums[j] - nums[i]
                if -target <= diff <= target:
                    if dp[j] < dp[i] + 1:
                        dp[j] = dp[i] + 1
        
        return dp[-1] if dp[-1] != -1 else -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'maximumJumps', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 56.550285144135486, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
count-subarrays-with-fixed-bounds,"```python
from typing import List

class Solution:
    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:
        res = 0
        min_pos = -1
        max_pos = -1
        left_bound = -1
        
        for i, num in enumerate(nums):
            if num < minK or num > maxK:
                left_bound = i
                min_pos = -1
                max_pos = -1
                continue
            
            if num == minK:
                min_pos = i
            if num == maxK:
                max_pos = i
            
            if min_pos != -1 and max_pos != -1:
                res += min(min_pos, max_pos) - left_bound
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 3}, {'name': 'countSubarrays', 'complexity': 8, 'lineno': 4}], 'maintainability_index': 53.769658427408345, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
divide-array-into-arrays-with-max-difference,"```python
from typing import List

class Solution:
    def divideArray(self, nums: List[int], k: int) -> List[List[int]]:
        nums.sort()
        result = []
        n = len(nums)
        for i in range(0, n, 3):
            if i + 2 >= n:
                return []
            a, b, c = nums[i], nums[i+1], nums[i+2]
            if c - a > k:
                return []
            result.append([a, b, c])
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'divideArray', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 60.90392104875397, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
largest-local-values-in-a-matrix,"```python
from typing import List

class Solution:
    def largestLocal(self, grid: List[List[int]]) -> List[List[int]]:
        n = len(grid)
        max_local = []
        for i in range(n - 2):
            row = []
            for j in range(n - 2):
                max_val = max(
                    grid[i][j], grid[i][j+1], grid[i][j+2],
                    grid[i+1][j], grid[i+1][j+1], grid[i+1][j+2],
                    grid[i+2][j], grid[i+2][j+1], grid[i+2][j+2]
                )
                row.append(max_val)
            max_local.append(row)
        return max_local
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'largestLocal', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 60.657471457320405, 'raw_metrics': {'loc': 17, 'lloc': 13, 'sloc': 17, 'comments': 0}}"
widest-vertical-area-between-two-points-containing-no-points,"```python
class Solution:
    def maxWidthOfVerticalArea(self, points: List[List[int]]) -> int:
        x_coords = sorted([point[0] for point in points])
        max_width = 0
        for i in range(1, len(x_coords)):
            width = x_coords[i] - x_coords[i-1]
            if width > max_width:
                max_width = width
        return max_width
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'maxWidthOfVerticalArea', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 67.49109344460464, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
minimum-absolute-difference-between-elements-with-constraint,"```python
import bisect

class Solution:
    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:
        min_diff = float('inf')
        sorted_list = []
        
        for i in range(x, len(nums)):
            bisect.insort(sorted_list, nums[i - x])
            pos = bisect.bisect_left(sorted_list, nums[i])
            if pos > 0:
                min_diff = min(min_diff, abs(nums[i] - sorted_list[pos - 1]))
            if pos < len(sorted_list):
                min_diff = min(min_diff, abs(nums[i] - sorted_list[pos]))
            if min_diff == 0:
                return 0
        
        return min_diff
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'minAbsoluteDifference', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 59.52414537612974, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
count-of-integers,"```python
class Solution:
    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:
        MOD = 10**9 + 7
        
        def digit_dp(s):
            n = len(s)
            memo = {}
            
            def dfs(pos, tight, sum_so_far):
                if pos == n:
                    return 1 if min_sum <= sum_so_far <= max_sum else 0
                key = (pos, tight, sum_so_far)
                if key in memo:
                    return memo[key]
                
                limit = int(s[pos]) if tight else 9
                total = 0
                for d in range(0, limit + 1):
                    new_tight = tight and (d == limit)
                    new_sum = sum_so_far + d
                    if new_sum > max_sum:
                        continue
                    total += dfs(pos + 1, new_tight, new_sum)
                    total %= MOD
                
                memo[key] = total
                return total
            
            return dfs(0, True, 0)
        
        def is_valid(num_str):
            digit_sum = sum(int(c) for c in num_str)
            return min_sum <= digit_sum <= max_sum
        
        total = digit_dp(num2) - digit_dp(num1) + (1 if is_valid(num1) else 0)
        return total % MOD
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 1}, {'name': 'count', 'complexity': 2, 'lineno': 2}], 'maintainability_index': 50.46838722019803, 'raw_metrics': {'loc': 29, 'lloc': 29, 'sloc': 29, 'comments': 0}}"
disconnect-path-in-a-binary-matrix-by-at-most-one-flip,"```python
from typing import List

class Solution:
    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:
        m, n = len(grid), len(grid[0])
        
        def dfs(i, j):
            if i == m - 1 and j == n - 1:
                return True
            grid[i][j] = 0
            if i + 1 < m and grid[i + 1][j] == 1 and dfs(i + 1, j):
                return True
            if j + 1 < n and grid[i][j + 1] == 1 and dfs(i, j + 1):
                return True
            return False
        
        if not dfs(0, 0):
            return True
        grid[0][0] = 1
        return not dfs(0, 0)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 3}, {'name': 'isPossibleToCutPath', 'complexity': 2, 'lineno': 4}], 'maintainability_index': 55.17801820914435, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
find-if-path-exists-in-graph,"```python
from collections import deque
from typing import List

class Solution:
    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:
        if source == destination:
            return True
        
        graph = [[] for _ in range(n)]
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        visited = [False] * n
        queue = deque([source])
        visited[source] = True
        
        while queue:
            current = queue.popleft()
            for neighbor in graph[current]:
                if neighbor == destination:
                    return True
                if not visited[neighbor]:
                    visited[neighbor] = True
                    queue.append(neighbor)
        
        return False
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 4}, {'name': 'validPath', 'complexity': 8, 'lineno': 5}], 'maintainability_index': 58.28459476833512, 'raw_metrics': {'loc': 23, 'lloc': 23, 'sloc': 23, 'comments': 0}}"
kth-largest-sum-in-a-binary-tree,"```python
from collections import deque

class Solution:
    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:
        if not root:
            return -1
        
        queue = deque([root])
        level_sums = []
        
        while queue:
            level_size = len(queue)
            current_sum = 0
            for _ in range(level_size):
                node = queue.popleft()
                current_sum += node.val
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            level_sums.append(current_sum)
        
        if len(level_sums) < k:
            return -1
        
        level_sums.sort(reverse=True)
        return level_sums[k-1]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'kthLargestLevelSum', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 57.21016975320961, 'raw_metrics': {'loc': 23, 'lloc': 23, 'sloc': 23, 'comments': 0}}"
find-the-sum-of-encrypted-integers,"```python
from typing import List

class Solution:
    def sumOfEncryptedInt(self, nums: List[int]) -> int:
        total = 0
        for num in nums:
            s = str(num)
            max_digit = max(s)
            encrypted = int(max_digit * len(s))
            total += encrypted
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 3}, {'name': 'sumOfEncryptedInt', 'complexity': 2, 'lineno': 4}], 'maintainability_index': 68.54295329449474, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
properties-graph,"```python
from typing import List

class Solution:
    def numberOfComponents(self, properties: List[List[int]], k: int) -> int:
        n = len(properties)
        parent = [i for i in range(n)]
        
        def find(u):
            while parent[u] != u:
                parent[u] = parent[parent[u]]
                u = parent[u]
            return u
        
        def union(u, v):
            root_u = find(u)
            root_v = find(v)
            if root_u != root_v:
                parent[root_v] = root_u
        
        prop_sets = [set(prop) for prop in properties]
        
        for i in range(n):
            for j in range(i + 1, n):
                common = len(prop_sets[i] & prop_sets[j])
                if common >= k:
                    union(i, j)
        
        roots = set()
        for i in range(n):
            roots.add(find(i))
        
        return len(roots)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'numberOfComponents', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 55.75725999336465, 'raw_metrics': {'loc': 26, 'lloc': 26, 'sloc': 26, 'comments': 0}}"
count-number-of-special-subsequences,"```python
class Solution:
    def countSpecialSubsequences(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        a = b = c = 0
        for num in nums:
            if num == 0:
                a = (2 * a + 1) % MOD
            elif num == 1:
                b = (2 * b + a) % MOD
            elif num == 2:
                c = (2 * c + b) % MOD
        return c
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'countSpecialSubsequences', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 58.93776597327025, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
ant-on-the-boundary,"```python
from typing import List

class Solution:
    def returnToBoundaryCount(self, nums: List[int]) -> int:
        position = 0
        count = 0
        for num in nums:
            position += num
            if position == 0:
                count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'returnToBoundaryCount', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 66.9244833780622, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
maximum-points-tourist-can-earn,"```python
from typing import List

class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp_prev = [0] * n
        
        for day in range(k):
            dp_current = [0] * n
            for curr in range(n):
                max_stay = dp_prev[curr] + stayScore[day][curr]
                max_travel = 0
                for dest in range(n):
                    if dest != curr:
                        current_travel = dp_prev[dest] + travelScore[dest][curr]
                        if current_travel > max_travel:
                            max_travel = current_travel
                dp_current[curr] = max(max_stay, max_travel)
            dp_prev = dp_current
        
        return max(dp_prev)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'maxScore', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 58.74256546821647, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
find-the-maximum-sum-of-node-values,"```python
from typing import List

class Solution:
    def maximumValueSum(self, nums: List[int], k: int, edges: List[List[int]]) -> int:
        total_sum = sum(nums)
        xor_diff = []
        
        for num in nums:
            xor = num ^ k
            xor_diff.append(xor - num)
        
        xor_diff.sort(reverse=True)
        
        for i in range(0, len(xor_diff), 2):
            if i + 1 >= len(xor_diff):
                break
            pair_sum = xor_diff[i] + xor_diff[i + 1]
            if pair_sum > 0:
                total_sum += pair_sum
            else:
                break
        
        return total_sum
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'maximumValueSum', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 57.35263245838646, 'raw_metrics': {'loc': 19, 'lloc': 19, 'sloc': 19, 'comments': 0}}"
row-with-maximum-ones,"```python
from typing import List

class Solution:
    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:
        max_row = 0
        max_count = 0
        for i, row in enumerate(mat):
            current_count = sum(row)
            if current_count > max_count:
                max_count = current_count
                max_row = i
        return [max_row, max_count]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'rowAndMaximumOnes', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 71.17942250393493, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
find-the-longest-valid-obstacle-course-at-each-position,"```python
import bisect
from typing import List

class Solution:
    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:
        tails = []
        res = []
        for num in obstacles:
            idx = bisect.bisect_right(tails, num)
            if idx == len(tails):
                tails.append(num)
            else:
                tails[idx] = num
            res.append(idx + 1)
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 4}, {'name': 'longestObstacleCourseAtEachPosition', 'complexity': 3, 'lineno': 5}], 'maintainability_index': 65.79647271311852, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
count-integers-in-intervals,"```python
import bisect

class CountIntervals:

    def __init__(self):
        self.intervals = []
        self.total = 0

    def add(self, left: int, right: int) -> None:
        intervals = self.intervals
        i = bisect.bisect_left(intervals, (left, right))
        if i > 0 and intervals[i-1][1] >= left - 1:
            left_prev, right_prev = intervals[i-1]
            new_left = min(left_prev, left)
            new_right = max(right_prev, right)
            self.total -= right_prev - left_prev + 1
            intervals.pop(i-1)
            left, right = new_left, new_right
            i -= 1
        while i < len(intervals) and intervals[i][0] <= right + 1:
            next_left, next_right = intervals[i]
            new_right = max(right, next_right)
            self.total -= next_right - next_left + 1
            intervals.pop(i)
            right = new_right
        bisect.insort(intervals, (left, right))
        self.total += right - left + 1

    def count(self) -> int:
        return self.total
```","{'cyclomatic_complexity': [{'name': 'CountIntervals', 'complexity': 3, 'lineno': 2}, {'name': '__init__', 'complexity': 1, 'lineno': 3}, {'name': 'add', 'complexity': 5, 'lineno': 6}, {'name': 'count', 'complexity': 1, 'lineno': 25}], 'maintainability_index': 50.564595533426136, 'raw_metrics': {'loc': 26, 'lloc': 26, 'sloc': 26, 'comments': 0}}"
maximum-number-of-visible-points,"```python
import math
from bisect import bisect_right
from typing import List

class Solution:
    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:
        pos_x, pos_y = location
        angles = []
        same = 0
        
        for x, y in points:
            dx = x - pos_x
            dy = y - pos_y
            if dx == 0 and dy == 0:
                same += 1
                continue
            rad = math.atan2(dy, dx)
            deg = math.degrees(rad)
            angles.append(deg)
        
        angles.sort()
        angles += [deg + 360 for deg in angles]
        max_count = 0
        right = 0
        n = len(angles)
        if n == 0:
            return same
        
        for left in range(n // 2):
            while right < n and angles[right] - angles[left] <= angle + 1e-9:
                right += 1
            max_count = max(max_count, right - left)
        
        return max_count + same
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 5}, {'name': 'visiblePoints', 'complexity': 9, 'lineno': 6}], 'maintainability_index': 49.33103085639219, 'raw_metrics': {'loc': 30, 'lloc': 30, 'sloc': 30, 'comments': 0}}"
count-the-number-of-houses-at-a-certain-distance-i,"```python
from typing import List

class Solution:
    def countOfPairs(self, n: int, x: int, y: int) -> List[int]:
        x, y = min(x, y), max(x, y)
        res = [0] * n
        for i in range(1, n + 1):
            for j in range(i + 1, n + 1):
                d = min(j - i, abs(x - i) + 1 + abs(y - j))
                if d <= n:
                    res[d - 1] += 2
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'countOfPairs', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 60.60760624421585, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
minimum-operations-to-make-array-equal-ii,"```python
from typing import List

class Solution:
    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:
        if k == 0:
            return 0 if nums1 == nums2 else -1
        
        total_pos = 0
        total_neg = 0
        
        for a, b in zip(nums1, nums2):
            diff = b - a
            if diff % k != 0:
                return -1
            ops = diff // k
            if ops > 0:
                total_pos += ops
            elif ops < 0:
                total_neg += -ops
        
        if total_pos != total_neg:
            return -1
        
        return total_pos
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 3}, {'name': 'minOperations', 'complexity': 8, 'lineno': 4}], 'maintainability_index': 54.56985471767088, 'raw_metrics': {'loc': 20, 'lloc': 20, 'sloc': 20, 'comments': 0}}"
minimum-number-of-groups-to-create-a-valid-assignment,"```python
from collections import Counter
from typing import List

class Solution:
    def minGroupsForValidAssignment(self, balls: List[int]) -> int:
        freq = Counter(balls)
        counts = list(freq.values())
        
        min_k = min(counts)
        
        for k in range(min_k, 0, -1):
            total = 0
            for count in counts:
                groups = (count + k) // (k + 1)
                if groups * k > count:
                    total = 0
                    break
                total += groups
            if total > 0:
                return total
        
        return len(counts)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 4}, {'name': 'minGroupsForValidAssignment', 'complexity': 5, 'lineno': 5}], 'maintainability_index': 57.69792875146499, 'raw_metrics': {'loc': 19, 'lloc': 19, 'sloc': 19, 'comments': 0}}"
maximize-value-of-function-in-a-ball-passing-game,"```python
class Solution:
    def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:
        n = len(receiver)
        max_level = k.bit_length()
        parent = [[-1] * n for _ in range(max_level)]
        sum_path = [[0] * n for _ in range(max_level)]
        
        for i in range(n):
            parent[0][i] = receiver[i]
            sum_path[0][i] = i
        
        for level in range(1, max_level):
            for i in range(n):
                parent_prev = parent[level - 1][i]
                parent[level][i] = parent[level - 1][parent_prev]
                sum_path[level][i] = sum_path[level - 1][i] + sum_path[level - 1][parent_prev]
        
        max_score = 0
        for i in range(n):
            current = i
            total = 0
            remaining = k
            for level in range(max_level):
                if (remaining >> level) & 1:
                    total += sum_path[level][current]
                    current = parent[level][current]
            total += current
            if total > max_score:
                max_score = total
        return max_score
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 2}, {'name': 'getMaxFunctionValue', 'complexity': 10, 'lineno': 3}], 'maintainability_index': 51.43952659395445, 'raw_metrics': {'loc': 28, 'lloc': 28, 'sloc': 28, 'comments': 0}}"
earliest-possible-day-of-full-bloom,"```python
from typing import List

class Solution:
    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:
        indices = sorted(range(len(growTime)), key=lambda i: -growTime[i])
        current_plant_time = 0
        max_bloom_time = 0
        for i in indices:
            current_plant_time += plantTime[i]
            bloom_time = current_plant_time + growTime[i]
            if bloom_time > max_bloom_time:
                max_bloom_time = bloom_time
        return max_bloom_time
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'earliestFullBloom', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 63.66019567961292, 'raw_metrics': {'loc': 13, 'lloc': 14, 'sloc': 13, 'comments': 0}}"
lexicographically-smallest-palindrome,"```python
class Solution:
    def makeSmallestPalindrome(self, s: str) -> str:
        s = list(s)
        left, right = 0, len(s) - 1
        while left < right:
            if s[left] != s[right]:
                if s[left] < s[right]:
                    s[right] = s[left]
                else:
                    s[left] = s[right]
            left += 1
            right -= 1
        return ''.join(s)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 1}, {'name': 'makeSmallestPalindrome', 'complexity': 4, 'lineno': 2}], 'maintainability_index': 62.35602198569514, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
rearrange-k-substrings-to-form-target-string,"```python
class Solution:
    def isPossibleToRearrange(self, s: str, t: str, k: int) -> bool:
        n = len(s)
        if n % k != 0:
            return False
        
        substring_length = n // k
        s_substrings = [s[i*substring_length : (i+1)*substring_length] for i in range(k)]
        t_substrings = [t[i*substring_length : (i+1)*substring_length] for i in range(k)]
        
        from collections import defaultdict
        s_counts = defaultdict(int)
        t_counts = defaultdict(int)
        
        for sub in s_substrings:
            s_counts[sub] += 1
        for sub in t_substrings:
            t_counts[sub] += 1
            
        return s_counts == t_counts
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 1}, {'name': 'isPossibleToRearrange', 'complexity': 6, 'lineno': 2}], 'maintainability_index': 56.38025537869642, 'raw_metrics': {'loc': 16, 'lloc': 18, 'sloc': 16, 'comments': 0}}"
reschedule-meetings-for-maximum-free-time-i,"```python
from typing import List

class Solution:
    def maxFreeTime(self, eventTime: int, k: int, startTime: List[int], endTime: List[int]) -> int:
        n = len(startTime)
        if n == 0:
            return eventTime
        
        gaps = []
        gaps.append(startTime[0] - 0)
        for i in range(1, n):
            gaps.append(startTime[i] - endTime[i-1])
        gaps.append(eventTime - endTime[-1])
        
        if k == 0:
            return max(gaps)
        
        max_gap = 0
        current_sum = sum(gaps[:k+1])
        max_gap = current_sum
        
        for i in range(k+1, len(gaps)):
            current_sum += gaps[i] - gaps[i - (k+1)]
            if current_sum > max_gap:
                max_gap = current_sum
        
        return max_gap
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'maxFreeTime', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 53.56091385232092, 'raw_metrics': {'loc': 22, 'lloc': 23, 'sloc': 22, 'comments': 0}}"
number-of-valid-words-in-a-sentence,"```python
class Solution:
    def countValidWords(self, sentence: str) -> int:
        tokens = sentence.split()
        count = 0
        for token in tokens:
            valid = True
            hyphen_count = 0
            punctuation_count = 0
            for i, c in enumerate(token):
                if c.isdigit():
                    valid = False
                    break
                if c == '-':
                    hyphen_count += 1
                    if hyphen_count > 1 or i == 0 or i == len(token) - 1 or not token[i-1].islower() or not token[i+1].islower():
                        valid = False
                        break
                if c in {'!', '.', ','}:
                    punctuation_count += 1
                    if punctuation_count > 1 or i != len(token) - 1:
                        valid = False
                        break
            if valid:
                count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 15, 'lineno': 1}, {'name': 'countValidWords', 'complexity': 14, 'lineno': 2}], 'maintainability_index': 50.46476530716588, 'raw_metrics': {'loc': 25, 'lloc': 25, 'sloc': 25, 'comments': 0}}"
maximum-product-difference-between-two-pairs,"```python
class Solution:
    def maxProductDifference(self, nums: List[int]) -> int:
        nums_sorted = sorted(nums)
        n = len(nums_sorted)
        return (nums_sorted[n-1] * nums_sorted[n-2]) - (nums_sorted[0] * nums_sorted[1])
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 2}, {'name': 'maxProductDifference', 'complexity': 1, 'lineno': 3}], 'maintainability_index': 70.74730595002698, 'raw_metrics': {'loc': 6, 'lloc': 6, 'sloc': 6, 'comments': 0}}"
replace-non-coprime-numbers-in-array,"```python
import math
from typing import List

class Solution:
    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:
        stack = []
        for num in nums:
            current = num
            while stack:
                gcd_val = math.gcd(stack[-1], current)
                if gcd_val == 1:
                    break
                last = stack.pop()
                current = (last * current) // gcd_val
            stack.append(current)
        return stack
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 4}, {'name': 'replaceNonCoprimes', 'complexity': 4, 'lineno': 5}], 'maintainability_index': 62.26065850971976, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
decremental-string-concatenation,"```python
class Solution:
    def minimizeConcatenatedLength(self, words: List[str]) -> int:
        if not words:
            return 0
        
        n = len(words)
        first_char = words[0][0]
        last_char = words[0][-1]
        total_len = len(words[0])
        
        dp = {}
        dp[(first_char, last_char)] = total_len
        
        for i in range(1, n):
            current_word = words[i]
            current_first = current_word[0]
            current_last = current_word[-1]
            current_len = len(current_word)
            new_dp = {}
            
            for (prev_first, prev_last), prev_total in dp.items():
                if prev_last == current_first:
                    new_total = prev_total + current_len - 1
                else:
                    new_total = prev_total + current_len
                new_first = prev_first
                new_last = current_last
                key = (new_first, new_last)
                if key in new_dp:
                    if new_total < new_dp[key]:
                        new_dp[key] = new_total
                else:
                    new_dp[key] = new_total
                
                if current_last == prev_first:
                    new_total = prev_total + current_len - 1
                else:
                    new_total = prev_total + current_len
                new_first = current_first
                new_last = prev_last
                key = (new_first, new_last)
                if key in new_dp:
                    if new_total < new_dp[key]:
                        new_dp[key] = new_total
                else:
                    new_dp[key] = new_total
            
            dp = new_dp
        
        return min(dp.values()) if dp else 0
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 2}, {'name': 'minimizeConcatenatedLength', 'complexity': 11, 'lineno': 3}], 'maintainability_index': 46.62347079596778, 'raw_metrics': {'loc': 44, 'lloc': 44, 'sloc': 44, 'comments': 0}}"
parallel-courses-iii,"```python
from collections import deque
from typing import List

class Solution:
    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:
        graph = [[] for _ in range(n)]
        in_degree = [0] * n
        for prev, next_course in relations:
            graph[prev - 1].append(next_course - 1)
            in_degree[next_course - 1] += 1
        
        queue = deque()
        max_time = [0] * n
        for i in range(n):
            if in_degree[i] == 0:
                queue.append(i)
                max_time[i] = time[i]
        
        while queue:
            current = queue.popleft()
            for neighbor in graph[current]:
                if max_time[neighbor] < max_time[current] + time[neighbor]:
                    max_time[neighbor] = max_time[current] + time[neighbor]
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)
        
        return max(max_time)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 4}, {'name': 'minimumTime', 'complexity': 9, 'lineno': 5}], 'maintainability_index': 52.71684345194012, 'raw_metrics': {'loc': 25, 'lloc': 25, 'sloc': 25, 'comments': 0}}"
make-costs-of-paths-equal-in-a-binary-tree,"```python
from typing import List

class Solution:
    def minIncrements(self, n: int, cost: List[int]) -> int:
        res = 0
        for i in range(n // 2 - 1, -1, -1):
            left = 2 * i + 1
            right = 2 * i + 2
            res += abs(cost[left] - cost[right])
            cost[i] += max(cost[left], cost[right])
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 3}, {'name': 'minIncrements', 'complexity': 2, 'lineno': 4}], 'maintainability_index': 62.09490833646215, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
painting-the-walls,"```python
class Solution:
    def paintWalls(self, cost: List[int], time: List[int]) -> int:
        n = len(cost)
        dp = [float('inf')] * (n + 1)
        dp[0] = 0
        for i in range(n):
            c, t = cost[i], time[i]
            for j in range(n, -1, -1):
                new_j = min(j + t + 1, n)
                if dp[j] + c < dp[new_j]:
                    dp[new_j] = dp[j] + c
        return dp[n]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'paintWalls', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 61.02393885496199, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
beautiful-towers-ii,"```python
class Solution:
    def maximumSumOfHeights(self, maxHeights: List[int]) -> int:
        n = len(maxHeights)
        left = [0] * n
        stack = []
        total = 0
        
        for i in range(n):
            while stack and maxHeights[i] < maxHeights[stack[-1]]:
                stack.pop()
            if stack:
                j = stack[-1]
                left[i] = left[j] + maxHeights[i] * (i - j)
            else:
                left[i] = maxHeights[i] * (i + 1)
            stack.append(i)
        
        right = [0] * n
        stack = []
        max_sum = 0
        
        for i in range(n-1, -1, -1):
            while stack and maxHeights[i] < maxHeights[stack[-1]]:
                stack.pop()
            if stack:
                j = stack[-1]
                right[i] = right[j] + maxHeights[i] * (j - i)
            else:
                right[i] = maxHeights[i] * (n - i)
            stack.append(i)
            current_sum = left[i] + right[i] - maxHeights[i]
            if current_sum > max_sum:
                max_sum = current_sum
        
        return max_sum
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 2}, {'name': 'maximumSumOfHeights', 'complexity': 10, 'lineno': 3}], 'maintainability_index': 47.64074953876567, 'raw_metrics': {'loc': 32, 'lloc': 32, 'sloc': 32, 'comments': 0}}"
form-largest-integer-with-digits-that-add-up-to-target,"```python
class Solution:
    def largestNumber(self, cost: List[int], target: int) -> str:
        dp = [-1] * (target + 1)
        dp[0] = 0
        
        for t in range(1, target + 1):
            for i in range(9):
                if t >= cost[i] and dp[t - cost[i]] != -1:
                    if dp[t] < dp[t - cost[i]] + 1:
                        dp[t] = dp[t - cost[i]] + 1
        
        if dp[target] == -1:
            return ""0""
        
        res = []
        remaining = target
        
        for i in range(8, -1, -1):
            while remaining >= cost[i] and dp[remaining] == dp[remaining - cost[i]] + 1:
                res.append(str(i + 1))
                remaining -= cost[i]
        
        return ''.join(res)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 2}, {'name': 'largestNumber', 'complexity': 10, 'lineno': 3}], 'maintainability_index': 52.665017797880324, 'raw_metrics': {'loc': 19, 'lloc': 19, 'sloc': 19, 'comments': 0}}"
words-within-two-edits-of-dictionary,"```python
from typing import List

class Solution:
    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:
        result = []
        for query in queries:
            found = False
            for word in dictionary:
                if len(query) != len(word):
                    continue
                diff = 0
                for a, b in zip(query, word):
                    if a != b:
                        diff += 1
                        if diff > 2:
                            break
                if diff <= 2:
                    found = True
                    break
            if found:
                result.append(query)
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 3}, {'name': 'twoEditWords', 'complexity': 9, 'lineno': 4}], 'maintainability_index': 57.36228586645375, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
minimum-sum-of-mountain-triplets-ii,"```python
class Solution:
    def minimumSum(self, nums: List[int]) -> int:
        n = len(nums)
        left_min = [float('inf')] * n
        right_min = [float('inf')] * n
        
        min_so_far = nums[0]
        for i in range(1, n):
            left_min[i] = min_so_far
            if nums[i] < min_so_far:
                min_so_far = nums[i]
        
        min_so_far = nums[-1]
        for i in range(n-2, -1, -1):
            right_min[i] = min_so_far
            if nums[i] < min_so_far:
                min_so_far = nums[i]
        
        min_sum = float('inf')
        for j in range(1, n-1):
            if left_min[j] < nums[j] and right_min[j] < nums[j]:
                current_sum = left_min[j] + nums[j] + right_min[j]
                if current_sum < min_sum:
                    min_sum = current_sum
        
        return min_sum if min_sum != float('inf') else -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 2}, {'name': 'minimumSum', 'complexity': 10, 'lineno': 3}], 'maintainability_index': 52.33301851807166, 'raw_metrics': {'loc': 23, 'lloc': 23, 'sloc': 23, 'comments': 0}}"
minimum-cost-to-make-array-equal,"```python
class Solution:
    def minCost(self, nums: List[int], cost: List[int]) -> int:
        num_cost = sorted(zip(nums, cost))
        total_cost = sum(cost)
        median_cost = total_cost // 2
        cumulative_cost = 0
        target = 0
        
        for num, c in num_cost:
            cumulative_cost += c
            if cumulative_cost > median_cost:
                target = num
                break
        
        min_total_cost = 0
        for num, c in num_cost:
            min_total_cost += abs(num - target) * c
        
        return min_total_cost
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'minCost', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 59.55307207886394, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
total-appeal-of-a-string,"```python
class Solution:
    def appealSum(self, s: str) -> int:
        last_pos = {}
        total = 0
        res = 0
        for i, char in enumerate(s):
            total += i - last_pos.get(char, -1)
            res += total
            last_pos[char] = i
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 1}, {'name': 'appealSum', 'complexity': 2, 'lineno': 2}], 'maintainability_index': 66.98233031894837, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
longest-common-suffix-queries,"```python
from typing import List

class Solution:
    def stringIndices(self, wordsContainer: List[str], wordsQuery: List[str]) -> List[int]:
        suffix_map = {}
        for idx, word in enumerate(wordsContainer):
            n = len(word)
            for l in range(n + 1):
                suffix = word[n - l:] if l > 0 else """"
                if l not in suffix_map:
                    suffix_map[l] = {}
                if suffix not in suffix_map[l]:
                    suffix_map[l][suffix] = (n, idx)
                else:
                    current_len, current_idx = suffix_map[l][suffix]
                    if n < current_len or (n == current_len and idx < current_idx):
                        suffix_map[l][suffix] = (n, idx)
        
        ans = []
        for query in wordsQuery:
            query_len = len(query)
            best_len = -1
            best_candidate = (float('inf'), 0)  # (length, index)
            max_possible = min(query_len, max(suffix_map.keys()) if suffix_map else 0)
            for l in range(max_possible, -1, -1):
                suffix = query[query_len - l:] if l > 0 else """"
                if l in suffix_map and suffix in suffix_map[l]:
                    current_len, current_idx = suffix_map[l][suffix]
                    if l > best_len or (l == best_len and (current_len < best_candidate[0] or 
                                                          (current_len == best_candidate[0] and current_idx < best_candidate[1]))):
                        best_len = l
                        best_candidate = (current_len, current_idx)
            ans.append(best_candidate[1])
        return ans
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 21, 'lineno': 3}, {'name': 'stringIndices', 'complexity': 20, 'lineno': 4}], 'maintainability_index': 55.75503703054184, 'raw_metrics': {'loc': 33, 'lloc': 34, 'sloc': 33, 'comments': 1}}"
double-modular-exponentiation,"```python
class Solution:
    def getGoodIndices(self, variables: List[List[int]], target: int) -> List[int]:
        result = []
        for i, (a, b, c, m) in enumerate(variables):
            if ((pow(a, b, 10) ** c) % m == target:
                result.append(i)
        return result
```","SyntaxError: invalid syntax (<unknown>, line 6)"
number-of-strings-which-can-be-rearranged-to-contain-substring,"```python
class Solution:
    def stringCount(self, n: int) -> int:
        MOD = 10**9 + 7
        if n < 4:
            return 0
        
        total = pow(26, n, MOD)
        
        
        a = pow(25, n, MOD)
        b = pow(25, n, MOD)
        c = (pow(25, n, MOD) + n * pow(25, n - 1, MOD)) % MOD
        
        ab = pow(24, n, MOD)  # missing both 'l' and 't'
        ac = (pow(25, n, MOD) - pow(24, n, MOD) + (n * pow(24, n - 1, MOD)) % MOD  # missing 'l' and at most one 'e'
        ac = (pow(25, n, MOD) + n * pow(24, n - 1, MOD)) % MOD  # Simplified, but needs correction
        bc = (pow(25, n, MOD) + n * pow(24, n - 1, MOD)) % MOD  # missing 't' and at most one 'e'
        abc = (pow(24, n, MOD) + n * pow(23, n - 1, MOD)) % MOD  # missing 'l', 't', and at most one 'e'
        
        union = (a + b + c - ab - ac - bc + abc) % MOD
        
        result = (total - union) % MOD
        return result
```","SyntaxError: '(' was never closed (<unknown>, line 11)"
count-collisions-of-monkeys-on-a-polygon,"```python
class Solution:
    def monkeyMove(self, n: int) -> int:
        MOD = 10**9 + 7
        return (pow(2, n, MOD) - 2 % MOD
```","SyntaxError: '(' was never closed (<unknown>, line 4)"
maximum-area-rectangle-with-point-constraints-ii,"```python
from typing import List
from collections import defaultdict

class Solution:
    def maxRectangleArea(self, xCoord: List[int], yCoord: List[int]) -> int:
        points = set(zip(xCoord, yCoord))
        x_to_ys = defaultdict(set)
        y_to_xs = defaultdict(set)
        
        for x, y in points:
            x_to_ys[x].add(y)
            y_to_xs[y].add(x)
        
        max_area = -1
        
        x_candidates = [x for x in x_to_ys if len(x_to_ys[x]) >= 2]
        x_candidates.sort()
        
        for i in range(len(x_candidates)):
            x1 = x_candidates[i]
            ys_x1 = sorted(x_to_ys[x1])
            for j in range(i + 1, len(x_candidates)):
                x2 = x_candidates[j]
                ys_x2 = sorted(x_to_ys[x2])
                
                common_ys = []
                ptr1, ptr2 = 0, 0
                while ptr1 < len(ys_x1) and ptr2 < len(ys_x2):
                    if ys_x1[ptr1] == ys_x2[ptr2]:
                        common_ys.append(ys_x1[ptr1])
                        ptr1 += 1
                        ptr2 += 1
                    elif ys_x1[ptr1] < ys_x2[ptr2]:
                        ptr1 += 1
                    else:
                        ptr2 += 1
                
                for k in range(len(common_ys)):
                    y1 = common_ys[k]
                    for l in range(k + 1, len(common_ys)):
                        y2 = common_ys[l]
                        has_internal_point = False
                        for x in range(x1 + 1, x2):
                            if x in x_to_ys:
                                ys = x_to_ys[x]
                                left = bisect.bisect_right(ys, y1)
                                right = bisect.bisect_left(ys, y2)
                                if left < right:
                                    has_internal_point = True
                                    break
                            if has_internal_point:
                                break
                        if not has_internal_point:
                            area = (x2 - x1) * (y2 - y1)
                            if area > max_area:
                                max_area = area
        return max_area
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 19, 'lineno': 4}, {'name': 'maxRectangleArea', 'complexity': 18, 'lineno': 5}], 'maintainability_index': 42.6316650882304, 'raw_metrics': {'loc': 51, 'lloc': 51, 'sloc': 51, 'comments': 0}}"
smallest-divisible-digit-product-ii,"```python
import math

class Solution:
    def smallestNumber(self, num: str, t: int) -> str:
        def is_valid(s):
            product = 1
            for ch in s:
                if ch == '0':
                    return False
                product *= int(ch)
            return product % t == 0
        
        n = len(num)
        if is_valid(num):
            return num
        
        digits = [int(c) for c in num]
        
        def find_next(digits):
            n = len(digits)
            pos = n - 1
            while pos >= 0:
                if digits[pos] < 9:
                    digits[pos] += 1
                    for i in range(pos + 1, n):
                        digits[i] = 1
                    s = ''.join(map(str, digits))
                    if is_valid(s):
                        return s
                    return find_next(digits.copy())
                else:
                    pos -= 1
            return find_next([1] * (n + 1))
        
        next_num = str(int(num) + 1)
        if len(next_num) > len(num):
            digits = [1] * len(next_num)
        else:
            digits = [int(c) for c in next_num]
        
        result = find_next(digits.copy())
        return result if result else ""-1""
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 2}, {'name': 'smallestNumber', 'complexity': 6, 'lineno': 3}], 'maintainability_index': 48.69650166756296, 'raw_metrics': {'loc': 36, 'lloc': 36, 'sloc': 36, 'comments': 0}}"
greatest-common-divisor-traversal,"```python
import math
from collections import defaultdict

class Solution:
    def canTraverseAllPairs(self, nums: List[int]) -> bool:
        if len(nums) == 1:
            return True
        
        parent = {}
        size = defaultdict(int)
        
        def find(u):
            while parent[u] != u:
                parent[u] = parent[parent[u]]
                u = parent[u]
            return u
        
        def union(u, v):
            u_root = find(u)
            v_root = find(v)
            if u_root == v_root:
                return
            if size[u_root] > size[v_root]:
                parent[v_root] = u_root
                size[u_root] += size[v_root]
            else:
                parent[u_root] = v_root
                size[v_root] += size[u_root]
        
        prime_to_indices = defaultdict(list)
        
        for i, num in enumerate(nums):
            if num == 1:
                return False
            factors = self.get_prime_factors(num)
            for p in factors:
                prime_to_indices[p].append(i)
        
        for p in prime_to_indices:
            indices = prime_to_indices[p]
            for i in range(1, len(indices)):
                union(indices[i-1], indices[i])
        
        root = find(0)
        for i in range(len(nums)):
            if find(i) != root:
                return False
        return True
    
    def get_prime_factors(self, n):
        factors = set()
        if n == 1:
            return factors
        while n % 2 == 0:
            factors.add(2)
            n = n // 2
        i = 3
        while i * i <= n:
            while n % i == 0:
                factors.add(i)
                n = n // i
            i += 2
        if n > 2:
            factors.add(n)
        return factors
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 4}, {'name': 'canTraverseAllPairs', 'complexity': 9, 'lineno': 5}, {'name': 'get_prime_factors', 'complexity': 6, 'lineno': 42}], 'maintainability_index': 42.17364588926748, 'raw_metrics': {'loc': 57, 'lloc': 57, 'sloc': 57, 'comments': 0}}"
power-of-heroes,"```python
class Solution:
    def sumOfPower(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        nums.sort()
        res = 0
        prefix = 0
        for num in nums:
            res = (res + (num ** 3) % MOD + (prefix * (num ** 2) % MOD) % MOD
            prefix = (prefix * 2 + num) % MOD
        return res
```","SyntaxError: '(' was never closed (<unknown>, line 9)"
maximum-segment-sum-after-removals,"```python
from typing import List
import heapq

class Solution:
    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:
        n = len(nums)
        parent = [i for i in range(n)]
        sum_seg = [0] * n
        max_heap = []
        res = [0] * n
        removed = [False] * n
        
        def find(u):
            while parent[u] != u:
                parent[u] = parent[parent[u]]
                u = parent[u]
            return u
        
        def union(u, v):
            root_u = find(u)
            root_v = find(v)
            if root_u == root_v:
                return
            if root_u < root_v:
                parent[root_v] = root_u
                sum_seg[root_u] += sum_seg[root_v]
                heapq.heappush(max_heap, -sum_seg[root_u])
            else:
                parent[root_u] = root_v
                sum_seg[root_v] += sum_seg[root_u]
                heapq.heappush(max_heap, -sum_seg[root_v])
        
        for i in range(n-1, -1, -1):
            pos = removeQueries[i]
            sum_seg[pos] = nums[pos]
            heapq.heappush(max_heap, -sum_seg[pos])
            removed[pos] = True
            if pos > 0 and removed[pos-1]:
                union(pos, pos-1)
            if pos < n-1 and removed[pos+1]:
                union(pos, pos+1)
            current_max = 0
            while max_heap:
                current_candidate = -max_heap[0]
                root = find(removeQueries[heapq.nlargest(1, range(n), key=lambda x: -max_heap[x])[0]])
                if sum_seg[root] == current_candidate:
                    current_max = current_candidate
                    break
                else:
                    heapq.heappop(max_heap)
            res[i] = current_max
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 4}, {'name': 'maximumSegmentSum', 'complexity': 9, 'lineno': 5}], 'maintainability_index': 43.63533883359239, 'raw_metrics': {'loc': 49, 'lloc': 50, 'sloc': 49, 'comments': 0}}"
abbreviating-the-product-of-a-range,"```python
import math

class Solution:
    def abbreviateProduct(self, left: int, right: int) -> str:
        product = 1
        count2 = 0
        count5 = 0
        
        for num in range(left, right + 1):
            product *= num
            while num % 2 == 0:
                num //= 2
                count2 += 1
            while num % 5 == 0:
                num //= 5
                count5 += 1
        
        C = min(count2, count5)
        
        for _ in range(C):
            product //= 10
        
        s = str(product)
        d = len(s)
        
        if d <= 10:
            return f""{product}e{C}""
        else:
            pre = s[:5]
            suf = s[-5:]
            return f""{pre}...{suf}e{C}""
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 2}, {'name': 'abbreviateProduct', 'complexity': 6, 'lineno': 3}], 'maintainability_index': 52.322073866216535, 'raw_metrics': {'loc': 25, 'lloc': 27, 'sloc': 25, 'comments': 0}}"
sum-of-k-mirror-numbers,"```python
class Solution:
    def kMirror(self, k: int, n: int) -> int:
        def is_palindrome(s):
            return s == s[::-1]
        
        def get_palindromes():
            length = 1
            while True:
                for half in range(10 ** (length // 2 - 1), 10 ** (length // 2)):
                    half_str = str(half)
                    if length % 2 == 0:
                        palindrome = int(half_str + half_str[::-1])
                    else:
                        for d in '0123456789':
                            palindrome = int(half_str + d + half_str[::-1])
                            yield palindrome
                length += 1
        
        count = 0
        total = 0
        for num in get_palindromes():
            if is_palindrome(self.convert_base(num, k)):
                total += num
                count += 1
                if count == n:
                    break
        return total
    
    def convert_base(self, num, k):
        if num == 0:
            return '0'
        digits = []
        while num > 0:
            digits.append(str(num % k))
            num = num // k
        return ''.join(reversed(digits))
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 1}, {'name': 'kMirror', 'complexity': 4, 'lineno': 2}, {'name': 'convert_base', 'complexity': 3, 'lineno': 26}], 'maintainability_index': 47.45476570344859, 'raw_metrics': {'loc': 33, 'lloc': 36, 'sloc': 33, 'comments': 0}}"
minimum-number-of-days-to-eat-n-oranges,"```python
from functools import lru_cache

class Solution:
    def minDays(self, n: int) -> int:
        @lru_cache(maxsize=None)
        def dfs(m):
            if m <= 1:
                return m
            return 1 + min(
                m % 2 + dfs(m // 2),
                m % 3 + dfs(m // 3)
        return dfs(n)
```","SyntaxError: '(' was never closed (<unknown>, line 8)"
separate-squares-i,"```python
class Solution:
    def separateSquares(self, squares: List[List[int]]) -> float:
        def compute_area(y_line):
            area_above = 0.0
            area_below = 0.0
            for x, y, l in squares:
                top = y + l
                if y >= y_line:
                    area_above += l * l
                elif top <= y_line:
                    area_below += l * l
                else:
                    overlap = top - y_line
                    area_above += overlap * l
                    area_below += (l * l - overlap * l)
            return area_above, area_below
        
        left = 0.0
        right = 0.0
        for x, y, l in squares:
            right = max(right, y + l)
        
        precision = 1e-7
        while right - left > precision:
            mid = (left + right) / 2
            area_above, area_below = compute_area(mid)
            if area_above > area_below:
                left = mid
            else:
                right = mid
        return left
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'separateSquares', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 49.8179416928921, 'raw_metrics': {'loc': 30, 'lloc': 30, 'sloc': 30, 'comments': 0}}"
count-special-subsequences,"```python
from typing import List

class Solution:
    def numberOfSubsequences(self, nums: List[int]) -> int:
        n = len(nums)
        count = 0
        for p in range(n):
            for q in range(p + 2, n):
                for r in range(q + 2, n):
                    for s in range(r + 2, n):
                        if nums[p] * nums[r] == nums[q] * nums[s]:
                            count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'numberOfSubsequences', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 61.35675222373648, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
count-beautiful-splits-in-an-array,"```python
from typing import List

class Solution:
    def beautifulSplits(self, nums: List[int]) -> int:
        n = len(nums)
        count = 0
        
        for i in range(1, n):
            for j in range(i + 1, n):
                nums1 = nums[:i]
                nums2 = nums[i:j]
                nums3 = nums[j:]
                
                len1 = len(nums1)
                len2 = len(nums2)
                len3 = len(nums3)
                
                if len1 <= len2 and nums1 == nums2[:len1]:
                    count += 1
                elif len2 <= len3 and nums2 == nums3[:len2]:
                    count += 1
        
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'beautifulSplits', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 55.27584250899379, 'raw_metrics': {'loc': 19, 'lloc': 22, 'sloc': 19, 'comments': 0}}"
find-mirror-score-of-a-string,"```python
class Solution:
    def calculateScore(self, s: str) -> int:
        mirror_map = {
            'a': 'z', 'b': 'y', 'c': 'x', 'd': 'w', 'e': 'v', 'f': 'u',
            'g': 't', 'h': 's', 'i': 'r', 'j': 'q', 'k': 'p', 'l': 'o',
            'm': 'n', 'n': 'm', 'o': 'l', 'p': 'k', 'q': 'j', 'r': 'i',
            's': 'h', 't': 'g', 'u': 'f', 'v': 'e', 'w': 'd', 'x': 'c',
            'y': 'b', 'z': 'a'
        }
        marked = [False] * len(s)
        score = 0
        
        for i in range(len(s)):
            if marked[i]:
                continue
            target_char = mirror_map[s[i]]
            for j in range(i - 1, -1, -1):
                if not marked[j] and s[j] == target_char:
                    marked[i] = marked[j] = True
                    score += i - j
                    break
        return score
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 1}, {'name': 'calculateScore', 'complexity': 6, 'lineno': 2}], 'maintainability_index': 58.729087975068275, 'raw_metrics': {'loc': 21, 'lloc': 16, 'sloc': 21, 'comments': 0}}"
maximize-the-number-of-target-nodes-after-connecting-trees-i,"```python
from collections import defaultdict, deque
from typing import List

class Solution:
    def maxTargetNodes(self, edges1: List[List[int]], edges2: List[List[int]], k: int) -> List[int]:
        n = len(edges1) + 1
        m = len(edges2) + 1
        
        tree1 = defaultdict(list)
        for a, b in edges1:
            tree1[a].append(b)
            tree1[b].append(a)
        
        tree2 = defaultdict(list)
        for u, v in edges2:
            tree2[u].append(v)
            tree2[v].append(u)
        
        dist_tree2 = [[0] * m for _ in range(m)]
        for u in range(m):
            visited = [False] * m
            q = deque([(u, 0)])
            visited[u] = True
            while q:
                node, d = q.popleft()
                dist_tree2[u][node] = d
                for neighbor in tree2[node]:
                    if not visited[neighbor]:
                        visited[neighbor] = True
                        q.append((neighbor, d + 1))
        
        dist_tree1 = [[0] * n for _ in range(n)]
        for u in range(n):
            visited = [False] * n
            q = deque([(u, 0)])
            visited[u] = True
            while q:
                node, d = q.popleft()
                dist_tree1[u][node] = d
                for neighbor in tree1[node]:
                    if not visited[neighbor]:
                        visited[neighbor] = True
                        q.append((neighbor, d + 1))
        
        answer = []
        for i in range(n):
            max_target = 0
            for j in range(m):
                count1 = sum(1 for x in range(n) if dist_tree1[i][x] <= k)
                count2 = sum(1 for y in range(m) if dist_tree2[j][y] + 1 <= k)
                total = count1 + count2
                if total > max_target:
                    max_target = total
            answer.append(max_target)
        
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 21, 'lineno': 4}, {'name': 'maxTargetNodes', 'complexity': 20, 'lineno': 5}], 'maintainability_index': 44.007106554865594, 'raw_metrics': {'loc': 50, 'lloc': 50, 'sloc': 50, 'comments': 0}}"
construct-the-minimum-bitwise-array-ii,"```python
from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            found = -1
            for candidate in range(num):
                if (candidate | (candidate + 1)) == num:
                    found = candidate
                    break
            ans.append(found)
        return ans
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'minBitwiseArray', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 64.22776828130313, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
find-subtree-sizes-after-changes,"```python
from typing import List

class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        children = [[] for _ in range(n)]
        for i in range(1, n):
            children[parent[i]].append(i)
        
        new_parent = parent.copy()
        for x in range(1, n):
            current = parent[x]
            found = None
            while current != -1:
                if s[current] == s[x]:
                    found = current
                    break
                current = parent[current]
            if found is not None:
                new_parent[x] = found
        
        new_children = [[] for _ in range(n)]
        for i in range(1, n):
            new_children[new_parent[i]].append(i)
        
        sizes = [1] * n
        stack = [(0, False)]
        while stack:
            node, processed = stack.pop()
            if not processed:
                stack.append((node, True))
                for child in reversed(new_children[node]):
                    stack.append((child, False))
            else:
                for child in new_children[node]:
                    sizes[node] += sizes[child]
        
        return sizes
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 14, 'lineno': 3}, {'name': 'findSubtreeSizes', 'complexity': 13, 'lineno': 4}], 'maintainability_index': 51.35697921930598, 'raw_metrics': {'loc': 34, 'lloc': 34, 'sloc': 34, 'comments': 0}}"
count-of-substrings-containing-every-vowel-and-k-consonants-ii,"```python
class Solution:
    def countOfSubstrings(self, word: str, k: int) -> int:
        vowels = {'a', 'e', 'i', 'o', 'u'}
        n = len(word)
        res = 0
        
        for i in range(n):
            vowel_count = 0
            consonant_count = 0
            seen_vowels = set()
            for j in range(i, n):
                c = word[j]
                if c in vowels:
                    if c not in seen_vowels:
                        seen_vowels.add(c)
                        vowel_count += 1
                else:
                    consonant_count += 1
                
                if consonant_count > k:
                    break
                
                if vowel_count == 5 and consonant_count == k:
                    res += 1
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 1}, {'name': 'countOfSubstrings', 'complexity': 8, 'lineno': 2}], 'maintainability_index': 55.202078033052196, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
minimum-number-of-valid-strings-to-form-target-i,"```python
class Solution:
    def minValidStrings(self, words: List[str], target: str) -> int:
        prefixes = set()
        for word in words:
            for i in range(1, len(word)+1):
                prefixes.add(word[:i])
        
        n = len(target)
        dp = [float('inf')] * (n + 1)
        dp[0] = 0
        
        for i in range(1, n+1):
            for l in range(1, i+1):
                if target[i-l:i] in prefixes and dp[i-l] != float('inf'):
                    dp[i] = min(dp[i], dp[i-l] + 1)
        
        return dp[n] if dp[n] != float('inf') else -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 2}, {'name': 'minValidStrings', 'complexity': 8, 'lineno': 3}], 'maintainability_index': 56.64042653397409, 'raw_metrics': {'loc': 15, 'lloc': 16, 'sloc': 15, 'comments': 0}}"
find-the-power-of-k-size-subarrays-ii,"```python
from typing import List

class Solution:
    def resultsArray(self, nums: List[int], k: int) -> List[int]:
        results = []
        n = len(nums)
        for i in range(n - k + 1):
            subarray = nums[i:i + k]
            max_val = max(subarray)
            min_val = min(subarray)
            if max_val - min_val == k - 1 and sorted(subarray) == subarray:
                results.append(max_val)
            else:
                results.append(-1)
        return results
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'resultsArray', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 58.81104727485992, 'raw_metrics': {'loc': 15, 'lloc': 16, 'sloc': 15, 'comments': 0}}"
count-substrings-with-k-frequency-characters-i,"```python
class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        count = 0
        n = len(s)
        for i in range(n):
            freq = [0] * 26
            for j in range(i, n):
                freq[ord(s[j]) - ord('a')] += 1
                if any(f >= k for f in freq):
                    count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 1}, {'name': 'numberOfSubstrings', 'complexity': 5, 'lineno': 2}], 'maintainability_index': 64.26215609778951, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
k-th-nearest-obstacle-queries,"```python
import bisect

class Solution:
    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:
        distances = []
        results = []
        for x, y in queries:
            distance = abs(x) + abs(y)
            bisect.insort(distances, distance)
            if len(distances) >= k:
                results.append(distances[k-1])
            else:
                results.append(-1)
        return results
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'resultsArray', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 63.66019567961292, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
alternating-groups-ii,"```python
from typing import List

class Solution:
    def numberOfAlternatingGroups(self, colors: List[int], k: int) -> int:
        n = len(colors)
        if k > n:
            return 0
        
        count = 0
        extended = colors + colors[:k-1]
        
        for i in range(n):
            group = extended[i:i+k]
            valid = True
            for j in range(1, k):
                if group[j] == group[j-1]:
                    valid = False
                    break
            if valid:
                count += 1
        
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'numberOfAlternatingGroups', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 56.891906071960115, 'raw_metrics': {'loc': 19, 'lloc': 21, 'sloc': 19, 'comments': 0}}"
count-the-number-of-substrings-with-dominant-ones,"```python
class Solution:
    def numberOfSubstrings(self, s: str) -> int:
        n = len(s)
        total = 0
        for i in range(n):
            zeros = 0
            ones = 0
            for j in range(i, n):
                if s[j] == '0':
                    zeros += 1
                else:
                    ones += 1
                if ones >= zeros * zeros:
                    total += 1
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 1}, {'name': 'numberOfSubstrings', 'complexity': 5, 'lineno': 2}], 'maintainability_index': 60.97421708938966, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
find-the-number-of-good-pairs-ii,"```python
from collections import defaultdict
from typing import List

class Solution:
    def numberOfPairs(self, nums1: List[int], nums2: List[int], k: int) -> int:
        freq = defaultdict(int)
        for num in nums2:
            freq[num * k] += 1
        
        divisors = defaultdict(int)
        for d in freq:
            for multiple in range(d, max(nums1) + 1, d):
                divisors[multiple] += freq[d]
        
        res = 0
        for num in nums1:
            res += divisors.get(num, 0)
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 4}, {'name': 'numberOfPairs', 'complexity': 5, 'lineno': 5}], 'maintainability_index': 60.91722764664106, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
find-all-possible-stable-binary-arrays-i,"```python
class Solution:
    def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:
        MOD = 10**9 + 7
        dp = [[[0] * 2 for _ in range(one + 1)] for __ in range(zero + 1)]
        
        if zero > 0:
            dp[1][0][0] = 1
        if one > 0:
            dp[0][1][1] = 1
        
        for i in range(zero + 1):
            for j in range(one + 1):
                if i == 0 and j == 0:
                    continue
                for k in range(2):
                    if dp[i][j][k] == 0:
                        continue
                    if k == 0:
                        if i + 1 <= zero:
                            max_consec = limit
                            pass
                        pass
                    pass
        
        
        
        from functools import lru_cache
        
        memo = {}
        
        def helper(zeros_left, ones_left, last, consecutive):
            if zeros_left == 0 and ones_left == 0:
                return 1
            key = (zeros_left, ones_left, last, consecutive)
            if key in memo:
                return memo[key]
            total = 0
            if last == 0:
                if zeros_left > 0 and consecutive < limit:
                    total += helper(zeros_left - 1, ones_left, 0, consecutive + 1)
                if ones_left > 0:
                    total += helper(zeros_left, ones_left - 1, 1, 1)
            else:
                if ones_left > 0 and consecutive < limit:
                    total += helper(zeros_left, ones_left - 1, 1, consecutive + 1)
                if zeros_left > 0:
                    total += helper(zeros_left - 1, ones_left, 0, 1)
            total %= MOD
            memo[key] = total
            return total
        
        res = 0
        if zero > 0:
            res += helper(zero - 1, one, 0, 1)
        if one > 0:
            res += helper(zero, one - 1, 1, 1)
        return res % MOD
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 16, 'lineno': 1}, {'name': 'numberOfStableArrays', 'complexity': 15, 'lineno': 2}], 'maintainability_index': 40.621711415178716, 'raw_metrics': {'loc': 49, 'lloc': 49, 'sloc': 49, 'comments': 0}}"
shortest-subarray-with-or-at-least-k-ii,"```python
class Solution:
    def minimumSubarrayLength(self, nums: List[int], k: int) -> int:
        n = len(nums)
        min_len = float('inf')
        
        for i in range(n):
            current_or = 0
            for j in range(i, n):
                current_or |= nums[j]
                if current_or >= k:
                    min_len = min(min_len, j - i + 1)
                    break
        
        return min_len if min_len != float('inf') else -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'minimumSubarrayLength', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 62.13383250857244, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
find-the-grid-of-region-average,"```python
from typing import List

class Solution:
    def resultGrid(self, image: List[List[int]], threshold: int) -> List[List[int]]:
        m = len(image)
        n = len(image[0]) if m > 0 else 0
        regions = []
        
        for i in range(m - 2):
            for j in range(n - 2):
                is_region = True
                total = 0
                for x in range(i, i + 3):
                    for y in range(j, j + 3):
                        total += image[x][y]
                        if y + 1 < j + 3:
                            if abs(image[x][y] - image[x][y + 1]) > threshold:
                                is_region = False
                                break
                        if x + 1 < i + 3:
                            if abs(image[x][y] - image[x + 1][y]) > threshold:
                                is_region = False
                                break
                    if not is_region:
                        break
                if is_region:
                    avg = total // 9
                    regions.append((i, j, avg))
        
        result = [[0 for _ in range(n)] for _ in range(m)]
        for i in range(m):
            for j in range(n):
                region_avgs = []
                for (x, y, avg) in regions:
                    if x <= i <= x + 2 and y <= j <= y + 2:
                        region_avgs.append(avg)
                if region_avgs:
                    total_avg = sum(region_avgs) // len(region_avgs)
                    result[i][j] = total_avg
                else:
                    result[i][j] = image[i][j]
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 21, 'lineno': 3}, {'name': 'resultGrid', 'complexity': 20, 'lineno': 4}], 'maintainability_index': 43.80192039986364, 'raw_metrics': {'loc': 40, 'lloc': 40, 'sloc': 40, 'comments': 0}}"
maximum-good-subarray-sum,"```python
from typing import List

class Solution:
    def maximumSubarraySum(self, nums: List[int], k: int) -> int:
        prefix_sum = [0] * (len(nums) + 1)
        for i in range(len(nums)):
            prefix_sum[i+1] = prefix_sum[i] + nums[i]
        
        value_indices = {}
        max_sum = -float('inf')
        
        for j in range(len(nums)):
            target1 = nums[j] - k
            target2 = nums[j] + k
            
            if target1 in value_indices:
                for i in value_indices[target1]:
                    current_sum = prefix_sum[j+1] - prefix_sum[i]
                    if current_sum > max_sum:
                        max_sum = current_sum
            
            if target2 in value_indices:
                for i in value_indices[target2]:
                    current_sum = prefix_sum[j+1] - prefix_sum[i]
                    if current_sum > max_sum:
                        max_sum = current_sum
            
            if nums[j] not in value_indices:
                value_indices[nums[j]] = []
            value_indices[nums[j]].append(j)
        
        return max_sum if max_sum != -float('inf') else 0
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 3}, {'name': 'maximumSubarraySum', 'complexity': 11, 'lineno': 4}], 'maintainability_index': 50.61011204840425, 'raw_metrics': {'loc': 26, 'lloc': 26, 'sloc': 26, 'comments': 0}}"
count-zero-request-servers,"```python
from collections import defaultdict
import bisect

class Solution:
    def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:
        server_times = defaultdict(list)
        for server_id, time in logs:
            server_times[server_id].append(time)
        
        for server_id in server_times:
            server_times[server_id].sort()
        
        res = []
        for q in queries:
            start = q - x
            end = q
            count = 0
            for server_id in range(1, n + 1):
                times = server_times.get(server_id, [])
                left = bisect.bisect_left(times, start)
                right = bisect.bisect_right(times, end)
                if left == right:
                    count += 1
            res.append(count)
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 4}, {'name': 'countServers', 'complexity': 6, 'lineno': 5}], 'maintainability_index': 58.14657498288665, 'raw_metrics': {'loc': 23, 'lloc': 23, 'sloc': 23, 'comments': 0}}"
increment-submatrices-by-one,"```python
class Solution:
    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:
        mat = [[0] * n for _ in range(n)]
        for row1, col1, row2, col2 in queries:
            for i in range(row1, row2 + 1):
                for j in range(col1, col2 + 1):
                    mat[i][j] += 1
        return mat
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'rangeAddQueries', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 67.47992009776695, 'raw_metrics': {'loc': 9, 'lloc': 9, 'sloc': 9, 'comments': 0}}"
count-beautiful-numbers,"```python
class Solution:
    def beautifulNumbers(self, l: int, r: int) -> int:
        count = 0
        for num in range(l, r + 1):
            digits = list(map(int, str(num)))
            sum_digits = sum(digits)
            if sum_digits == 0:
                continue
            product = 1
            for d in digits:
                product *= d
            if product % sum_digits == 0:
                count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 1}, {'name': 'beautifulNumbers', 'complexity': 5, 'lineno': 2}], 'maintainability_index': 61.5194435360517, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
longest-common-prefix-of-k-strings-after-removal,"```python
from typing import List
from collections import defaultdict

class Solution:
    def longestCommonPrefix(self, words: List[str], k: int) -> List[int]:
        n = len(words)
        if n - 1 < k:
            return [0] * n
        
        prefix_maps = []
        for word in words:
            prefix_map = defaultdict(int)
            for l in range(1, len(word)+1):
                prefix = word[:l]
                prefix_map[prefix] += 1
            prefix_maps.append(prefix_map)
        
        result = []
        for i in range(n):
            merged = defaultdict(int)
            for j in range(n):
                if j == i:
                    continue
                for prefix in prefix_maps[j]:
                    merged[prefix] += prefix_maps[j][prefix]
            
            max_len = 0
            for prefix in merged:
                if merged[prefix] >= k:
                    if len(prefix) > max_len:
                        max_len = len(prefix)
            result.append(max_len)
        
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 4}, {'name': 'longestCommonPrefix', 'complexity': 11, 'lineno': 5}], 'maintainability_index': 51.330876793275756, 'raw_metrics': {'loc': 30, 'lloc': 31, 'sloc': 30, 'comments': 0}}"
permutations-iv,"```python
class Solution:
    def permute(self, n: int, k: int) -> List[int]:
        from itertools import permutations
        
        nums = list(range(1, n + 1))
        alternating_perms = []
        
        for perm in permutations(nums):
            is_alternating = True
            for i in range(len(perm) - 1):
                if (perm[i] % 2) == (perm[i + 1] % 2):
                    is_alternating = False
                    break
            if is_alternating:
                alternating_perms.append(list(perm))
        
        if k <= len(alternating_perms):
            return alternating_perms[k - 1]
        else:
            return []
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 2}, {'name': 'permute', 'complexity': 6, 'lineno': 3}], 'maintainability_index': 57.79612100961952, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
check-if-digits-are-equal-in-string-after-operations-ii,"```python
class Solution:
    def hasSameDigits(self, s: str) -> bool:
        while len(s) > 2:
            new_s = []
            for i in range(len(s) - 1):
                new_digit = (int(s[i]) + int(s[i+1])) % 10
                new_s.append(str(new_digit))
            s = ''.join(new_s)
        return s[0] == s[1]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'hasSameDigits', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 65.6411099580525, 'raw_metrics': {'loc': 9, 'lloc': 9, 'sloc': 9, 'comments': 0}}"
maximum-and-minimum-sums-of-at-most-size-k-subarrays,"```python
from collections import deque
from typing import List

class Solution:
    def minMaxSubarraySum(self, nums: List[int], k: int) -> int:
        total = 0
        
        def compute_sum(is_max):
            dq = deque()
            res = 0
            for i, num in enumerate(nums):
                while dq and nums[dq[-1]] <= num if is_max else nums[dq[-1]] >= num:
                    dq.pop()
                dq.append(i)
                while dq[0] <= i - k:
                    dq.popleft()
                res += nums[dq[0]]
            return res
        
        max_sum = 0
        min_sum = 0
        
        for window_size in range(1, k + 1):
            current_max = 0
            current_min = 0
            dq_max = deque()
            dq_min = deque()
            
            for i in range(len(nums)):
                while dq_max and nums[dq_max[-1]] <= nums[i]:
                    dq_max.pop()
                dq_max.append(i)
                if dq_max[0] <= i - window_size:
                    dq_max.popleft()
                
                while dq_min and nums[dq_min[-1]] >= nums[i]:
                    dq_min.pop()
                dq_min.append(i)
                if dq_min[0] <= i - window_size:
                    dq_min.popleft()
                
                if i >= window_size - 1:
                    current_max += nums[dq_max[0]]
                    current_min += nums[dq_min[0]]
            
            max_sum += current_max
            min_sum += current_min
        
        return max_sum + min_sum
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 4}, {'name': 'minMaxSubarraySum', 'complexity': 10, 'lineno': 5}], 'maintainability_index': 45.14664141970068, 'raw_metrics': {'loc': 41, 'lloc': 41, 'sloc': 41, 'comments': 0}}"
subsequences-with-a-unique-middle-mode-i,"```python
from typing import List
from collections import defaultdict

class Solution:
    def subsequencesWithMiddleMode(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        count = 0
        n = len(nums)
        
        for i in range(n):
            for j in range(i + 1, n):
                for k in range(j + 1, n):
                    for l in range(k + 1, n):
                        for m in range(l + 1, n):
                            subsequence = [nums[i], nums[j], nums[k], nums[l], nums[m]]
                            freq = defaultdict(int)
                            for num in subsequence:
                                freq[num] += 1
                            max_freq = max(freq.values())
                            modes = [num for num, cnt in freq.items() if cnt == max_freq]
                            if len(modes) == 1 and modes[0] == subsequence[2]:
                                count += 1
        
        return count % MOD
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 4}, {'name': 'subsequencesWithMiddleMode', 'complexity': 11, 'lineno': 5}], 'maintainability_index': 53.331067646422476, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
count-substrings-divisible-by-last-digit,"```python
class Solution:
    def countSubstrings(self, s: str) -> int:
        count = 0
        n = len(s)
        for i in range(n):
            for j in range(i, n):
                last_digit = int(s[j])
                if last_digit == 0:
                    continue
                num = int(s[i:j+1])
                if num % last_digit == 0:
                    count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 1}, {'name': 'countSubstrings', 'complexity': 5, 'lineno': 2}], 'maintainability_index': 62.30559901297503, 'raw_metrics': {'loc': 13, 'lloc': 14, 'sloc': 13, 'comments': 0}}"
maximize-subarray-sum-after-removing-all-occurrences-of-one-element,"```python
from typing import List

class Solution:
    def maxSubarraySum(self, nums: List[int]) -> int:
        def kadane(arr):
            max_current = max_global = arr[0]
            for num in arr[1:]:
                max_current = max(num, max_current + num)
                max_global = max(max_global, max_current)
            return max_global
        
        max_original = kadane(nums)
        unique_elements = set(nums)
        max_after_removal = -float('inf')
        
        for x in unique_elements:
            filtered = [num for num in nums if num != x]
            if not filtered:
                continue
            current_max = kadane(filtered)
            if current_max > max_after_removal:
                max_after_removal = current_max
        
        return max(max_original, max_after_removal)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'maxSubarraySum', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 58.436872071558895, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
count-number-of-balanced-permutations,"```python
from collections import defaultdict
import math

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        velunexorai = num
        freq = defaultdict(int)
        for d in velunexorai:
            freq[d] += 1
        
        n = len(velunexorai)
        total = 0
        
        from itertools import permutations
        
        seen = set()
        balanced_count = 0
        
        for p in permutations(velunexorai):
            s = ''.join(p)
            if s in seen:
                continue
            seen.add(s)
            odd_sum = 0
            even_sum = 0
            for i in range(len(s)):
                if i % 2 == 0:
                    even_sum += int(s[i])
                else:
                    odd_sum += int(s[i])
            if odd_sum == even_sum:
                balanced_count += 1
        
        return balanced_count % (10**9 + 7)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'countBalancedPermutations', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 52.13338540104008, 'raw_metrics': {'loc': 28, 'lloc': 28, 'sloc': 28, 'comments': 0}}"
count-k-reducible-numbers-less-than-n,"```python
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        MOD = 10**9 + 7
        n = int(s, 2)
        if n == 1:
            return 0
        
        memo = {}
        
        def is_k_reducible(x):
            original_x = x
            steps = 0
            while x != 1 and steps <= k:
                if x in memo:
                    steps += memo[x]
                    break
                x = bin(x).count('1')
                steps += 1
            if original_x not in memo:
                memo[original_x] = steps
            return steps <= k
        
        count = 0
        for x in range(1, n):
            if is_k_reducible(x):
                count += 1
        return count % MOD
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 1}, {'name': 'countKReducibleNumbers', 'complexity': 4, 'lineno': 2}], 'maintainability_index': 53.37262916330718, 'raw_metrics': {'loc': 24, 'lloc': 24, 'sloc': 24, 'comments': 0}}"
find-x-sum-of-all-k-long-subarrays-ii,"```python
from collections import defaultdict
from typing import List

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        result = []
        freq = defaultdict(int)
        
        for num in nums[:k]:
            freq[num] += 1
        
        left = 0
        for right in range(k, n + 1):
            items = list(freq.items())
            items.sort(key=lambda item: (-item[1], -item[0]))
            
            total = 0
            for i in range(min(x, len(items))):
                val, count = items[i]
                total += val * count
            
            result.append(total)
            
            if right < n:
                left_num = nums[left]
                freq[left_num] -= 1
                if freq[left_num] == 0:
                    del freq[left_num]
                
                right_num = nums[right]
                freq[right_num] += 1
                left += 1
        
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 4}, {'name': 'findXSum', 'complexity': 6, 'lineno': 5}], 'maintainability_index': 52.21509814226887, 'raw_metrics': {'loc': 28, 'lloc': 29, 'sloc': 28, 'comments': 0}}"
find-the-occurrence-of-first-almost-equal-substring,"```python
class Solution:
    def minStartingIndex(self, s: str, pattern: str) -> int:
        len_pattern = len(pattern)
        len_s = len(s)
        
        for i in range(len_s - len_pattern + 1):
            mismatch = 0
            for j in range(len_pattern):
                if s[i + j] != pattern[j]:
                    mismatch += 1
                    if mismatch > 1:
                        break
            if mismatch <= 1:
                return i
        return -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 1}, {'name': 'minStartingIndex', 'complexity': 6, 'lineno': 2}], 'maintainability_index': 60.378037372531765, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
final-array-state-after-k-multiplication-operations-ii,"```python
import heapq

class Solution:
    def getFinalState(self, nums: List[int], k: int, multiplier: int) -> List[int]:
        MOD = 10**9 + 7
        heap = []
        for idx, num in enumerate(nums):
            heapq.heappush(heap, (num, idx))
        
        for _ in range(k):
            if not heap:
                break
            current_val, current_idx = heapq.heappop(heap)
            new_val = current_val * multiplier
            nums[current_idx] = new_val
            heapq.heappush(heap, (new_val, current_idx))
        
        return [num % MOD for num in nums]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'getFinalState', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 60.83561645382998, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
find-the-largest-palindrome-divisible-by-k,"```python
class Solution:
    def largestPalindrome(self, n: int, k: int) -> str:
        if n == 1:
            max_num = 9
            while max_num >= 0:
                if max_num % k == 0:
                    return str(max_num)
                max_num -= 1
            return """"
        
        half = (n + 1) // 2
        start = 10 ** half - 1
        end = 10 ** (half - 1) - 1
        
        for num in range(start, end, -1):
            s = str(num)
            if n % 2 == 0:
                palindrome_str = s + s[::-1]
            else:
                palindrome_str = s + s[:-1][::-1]
            palindrome = int(palindrome_str)
            if palindrome % k == 0:
                return palindrome_str
        
        return """"
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 1}, {'name': 'largestPalindrome', 'complexity': 7, 'lineno': 2}], 'maintainability_index': 51.524403131241606, 'raw_metrics': {'loc': 22, 'lloc': 24, 'sloc': 22, 'comments': 0}}"
count-substrings-that-satisfy-k-constraint-ii,"```python
class Solution:
    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:
        n = len(s)
        prefix0 = [0] * (n + 1)
        prefix1 = [0] * (n + 1)
        
        for i in range(n):
            prefix0[i+1] = prefix0[i] + (1 if s[i] == '0' else 0)
            prefix1[i+1] = prefix1[i] + (1 if s[i] == '1' else 0)
        
        res = []
        for l, r in queries:
            total = 0
            for i in range(l, r + 1):
                for j in range(i, r + 1):
                    cnt0 = prefix0[j+1] - prefix0[i]
                    cnt1 = prefix1[j+1] - prefix1[i]
                    if cnt0 <= k or cnt1 <= k:
                        total += 1
            res.append(total)
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 2}, {'name': 'countKConstraintSubstrings', 'complexity': 9, 'lineno': 3}], 'maintainability_index': 52.902632852627164, 'raw_metrics': {'loc': 20, 'lloc': 20, 'sloc': 20, 'comments': 0}}"
time-taken-to-mark-all-nodes,"```python
from collections import deque
from typing import List

class Solution:
    def timeTaken(self, edges: List[List[int]]) -> List[int]:
        n = len(edges) + 1
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        
        times = [0] * n
        
        for i in range(n):
            visited = [False] * n
            time = [0] * n
            q = deque()
            q.append(i)
            visited[i] = True
            time[i] = 0
            max_time = 0
            
            while q:
                node = q.popleft()
                for neighbor in adj[node]:
                    if not visited[neighbor]:
                        if neighbor % 2 == 1:
                            if time[node] + 1 >= time[neighbor]:
                                time[neighbor] = time[node] + 1
                                visited[neighbor] = True
                                q.append(neighbor)
                        else:
                            if time[node] + 2 >= time[neighbor]:
                                time[neighbor] = time[node] + 2
                                visited[neighbor] = True
                                q.append(neighbor)
                max_time = max(max_time, time[node])
            
            times[i] = max(time)
        
        return times
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 4}, {'name': 'timeTaken', 'complexity': 10, 'lineno': 5}], 'maintainability_index': 48.878993652687214, 'raw_metrics': {'loc': 36, 'lloc': 36, 'sloc': 36, 'comments': 0}}"
construct-string-with-minimum-cost,"```python
from typing import List

class Solution:
    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:
        n = len(target)
        dp = [float('inf')] * (n + 1)
        dp[0] = 0
        
        for i in range(n + 1):
            if dp[i] == float('inf'):
                continue
            for idx, word in enumerate(words):
                cost = costs[idx]
                if target.startswith(word, i):
                    next_pos = i + len(word)
                    if dp[next_pos] > dp[i] + cost:
                        dp[next_pos] = dp[i] + cost
        
        return dp[n] if dp[n] != float('inf') else -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'minimumCost', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 57.34312821213044, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
number-of-subarrays-with-and-value-of-k,"```python
from typing import List

class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        count = 0
        n = len(nums)
        for i in range(n):
            current_and = nums[i]
            if current_and == k:
                count += 1
            for j in range(i + 1, n):
                current_and &= nums[j]
                if current_and == k:
                    count += 1
                elif current_and < k:
                    break
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'countSubarrays', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 59.30853289345816, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
maximum-total-reward-using-operations-ii,"```python
class Solution:
    def maxTotalReward(self, rewardValues: List[int]) -> int:
        rewardValues = sorted(set(rewardValues))
        max_reach = 0
        dp = {0}
        for num in rewardValues:
            new_dp = set()
            for x in dp:
                if num > x:
                    new_x = x + num
                    if new_x > max_reach:
                        max_reach = new_x
                    new_dp.add(new_x)
            dp.update(new_dp)
        return max_reach
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'maxTotalReward', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 63.35672379559808, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
maximum-sum-of-subsequence-with-non-adjacent-elements,"```python
class Solution:
    def maximumSumSubsequence(self, nums: List[int], queries: List[List[int]]) -> int:
        MOD = 10**9 + 7
        total = 0
        
        for pos, x in queries:
            nums[pos] = x
            n = len(nums)
            if n == 0:
                total = (total + 0) % MOD
                continue
            prev_max = 0
            curr_max = max(0, nums[0])
            for i in range(1, n):
                new_max = max(curr_max, prev_max + nums[i])
                prev_max = curr_max
                curr_max = new_max
            total = (total + max(prev_max, curr_max)) % MOD
        
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'maximumSumSubsequence', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 57.48713538236306, 'raw_metrics': {'loc': 19, 'lloc': 19, 'sloc': 19, 'comments': 0}}"
minimize-manhattan-distances,"```python
class Solution:
    def minimumDistance(self, points: List[List[int]]) -> int:
        def max_manhattan(points):
            if not points:
                return 0
            sum_ = [x + y for x, y in points]
            diff = [x - y for x, y in points]
            max_sum, min_sum = max(sum_), min(sum_)
            max_diff, min_diff = max(diff), min(diff)
            return max(max_sum - min_sum, max_diff - min_diff)
        
        sum_ = [x + y for x, y in points]
        diff = [x - y for x, y in points]
        
        max_sum_indices = [i for i, val in enumerate(sum_) if val == max(sum_)]
        min_sum_indices = [i for i, val in enumerate(sum_) if val == min(sum_)]
        max_diff_indices = [i for i, val in enumerate(diff) if val == max(diff)]
        min_diff_indices = [i for i, val in enumerate(diff) if val == min(diff)]
        
        candidates = set(max_sum_indices + min_sum_indices + max_diff_indices + min_diff_indices)
        
        min_max_distance = float('inf')
        
        for candidate in candidates:
            temp_points = points[:candidate] + points[candidate+1:]
            current_max = max_manhattan(temp_points)
            if current_max < min_max_distance:
                min_max_distance = current_max
        
        return min_max_distance
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 14, 'lineno': 2}, {'name': 'minimumDistance', 'complexity': 13, 'lineno': 3}], 'maintainability_index': 50.48835946188188, 'raw_metrics': {'loc': 25, 'lloc': 26, 'sloc': 25, 'comments': 0}}"
minimum-moves-to-pick-k-ones,"```python
from typing import List

class Solution:
    def minimumMoves(self, nums: List[int], k: int, maxChanges: int) -> int:
        ones_pos = [i for i, num in enumerate(nums) if num == 1]
        m = len(ones_pos)
        if m == 0:
            return k * 2  # need to create and move all k ones
        
        prefix = [0] * (m + 1)
        for i in range(m):
            prefix[i+1] = prefix[i] + ones_pos[i]
        
        min_moves = float('inf')
        
        max_window = min(k, m + maxChanges)
        
        for window_size in range(max(1, k - maxChanges), min(k, m) + 1):
            changes_needed = k - window_size
            if changes_needed < 0 or changes_needed > maxChanges:
                continue
            
            for i in range(m - window_size + 1):
                j = i + window_size
                median_pos = ones_pos[(i + j) // 2]
                
                left = (i + j) // 2
                right = (i + j) // 2
                if window_size % 2 == 0:
                    right = (i + j) // 2
                else:
                    right = (i + j) // 2
                
                sum_dist = 0
                sum_dist += median_pos * (left - i) - (prefix[left] - prefix[i])
                sum_dist += (prefix[j] - prefix[right]) - median_pos * (j - right)
                
                total_moves = sum_dist + 2 * changes_needed
                if total_moves < min_moves:
                    min_moves = total_moves
        
        return min_moves
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 3}, {'name': 'minimumMoves', 'complexity': 11, 'lineno': 4}], 'maintainability_index': 55.56646989896918, 'raw_metrics': {'loc': 33, 'lloc': 33, 'sloc': 33, 'comments': 1}}"
count-the-number-of-houses-at-a-certain-distance-ii,"```python
from typing import List

class Solution:
    def countOfPairs(self, n: int, x: int, y: int) -> List[int]:
        if x > y:
            x, y = y, x
        res = [0] * n
        for i in range(1, n + 1):
            for j in range(i + 1, n + 1):
                d = j - i
                d = min(d, abs(x - i) + 1 + abs(y - j))
                if d <= n:
                    res[d - 1] += 2
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'countOfPairs', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 58.708585285593735, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
count-prefix-and-suffix-pairs-ii,"```python
class Solution:
    def countPrefixSuffixPairs(self, words: List[str]) -> int:
        count = 0
        n = len(words)
        for i in range(n):
            s = words[i]
            len_s = len(s)
            for j in range(i + 1, n):
                t = words[j]
                if len(t) >= len_s and t.startswith(s) and t.endswith(s):
                    count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 2}, {'name': 'countPrefixSuffixPairs', 'complexity': 6, 'lineno': 3}], 'maintainability_index': 63.18499495444166, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
find-beautiful-indices-in-the-given-array-ii,"```python
class Solution:
    def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:
        len_a = len(a)
        len_b = len(b)
        len_s = len(s)
        
        a_indices = []
        for i in range(len_s - len_a + 1):
            if s[i:i+len_a] == a:
                a_indices.append(i)
        
        b_indices = []
        for j in range(len_s - len_b + 1):
            if s[j:j+len_b] == b:
                b_indices.append(j)
        
        if not b_indices:
            return []
        
        res = []
        b_ptr = 0
        len_b_indices = len(b_indices)
        
        for i in a_indices:
            left = 0
            right = len_b_indices
            while left < right:
                mid = (left + right) // 2
                if b_indices[mid] < i - k:
                    left = mid + 1
                else:
                    right = mid
            
            if left < len_b_indices and b_indices[left] <= i + k:
                res.append(i)
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 2}, {'name': 'beautifulIndices', 'complexity': 11, 'lineno': 3}], 'maintainability_index': 48.66568796029308, 'raw_metrics': {'loc': 31, 'lloc': 31, 'sloc': 31, 'comments': 0}}"
minimum-time-to-revert-word-to-initial-state-ii,"```python
class Solution:
    def minimumTimeToInitialState(self, word: str, k: int) -> int:
        n = len(word)
        max_possible = (n + k - 1) // k  # Equivalent to ceiling(n / k)
        for t in range(1, max_possible + 1):
            remaining_length = t * k
            if remaining_length >= n:
                return t
            if word[:n - remaining_length] == word[remaining_length:]:
                return t
        return max_possible
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 1}, {'name': 'minimumTimeToInitialState', 'complexity': 4, 'lineno': 2}], 'maintainability_index': 79.83299617209079, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 1}}"
number-of-subarrays-that-match-a-pattern-ii,"```python
class Solution:
    def countMatchingSubarrays(self, nums: List[int], pattern: List[int]) -> int:
        n = len(nums)
        m = len(pattern)
        count = 0
        
        for i in range(n - m):
            match = True
            for k in range(m):
                if pattern[k] == 1:
                    if not (nums[i + k + 1] > nums[i + k]):
                        match = False
                        break
                elif pattern[k] == 0:
                    if not (nums[i + k + 1] == nums[i + k]):
                        match = False
                        break
                elif pattern[k] == -1:
                    if not (nums[i + k + 1] < nums[i + k]):
                        match = False
                        break
            if match:
                count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 2}, {'name': 'countMatchingSubarrays', 'complexity': 10, 'lineno': 3}], 'maintainability_index': 51.176025053439105, 'raw_metrics': {'loc': 24, 'lloc': 24, 'sloc': 24, 'comments': 0}}"
find-the-number-of-ways-to-place-people-ii,"```python
from typing import List

class Solution:
    def numberOfPairs(self, points: List[List[int]]) -> int:
        points.sort()
        count = 0
        n = len(points)
        for i in range(n):
            x1, y1 = points[i]
            for j in range(n):
                if i == j:
                    continue
                x2, y2 = points[j]
                if x2 >= x1 and y2 <= y1:
                    valid = True
                    for k in range(n):
                        if k == i or k == j:
                            continue
                        x, y = points[k]
                        if x >= x1 and x <= x2 and y <= y1 and y >= y2:
                            valid = False
                            break
                    if valid:
                        count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 15, 'lineno': 3}, {'name': 'numberOfPairs', 'complexity': 14, 'lineno': 4}], 'maintainability_index': 51.52561543195054, 'raw_metrics': {'loc': 25, 'lloc': 25, 'sloc': 25, 'comments': 0}}"
divide-an-array-into-subarrays-with-minimum-cost-ii,"```python
import heapq

class Solution:
    def minimumCost(self, nums: List[int], k: int, dist: int) -> int:
        n = len(nums)
        res = float('inf')
        
        
        
        
        
        
        
        
        if k == 1:
            return nums[0]
        
        
        
        
        
        
        
        
        
        
        min_heap = []
        max_heap = []
        sum_selected = 0
        left = 1  # the left boundary of the current window for i1 candidates
        
        
        
        
        
        
        
        from sortedcontainers import SortedList
        
        sl = SortedList()
        current_sum = 0
        res = float('inf')
        
        
        window_left = 2
        window_right = 1 + dist
        if window_right >= n:
            window_right = n - 1
        
        for i in range(window_left, window_right + 1):
            sl.add(nums[i])
        
        if len(sl) >= k-2:
            current_sum = sum(sl[:k-2])
        else:
            pass
        
        if len(sl) >= k-2:
            res = nums[0] + nums[1] + current_sum
        
        for i1 in range(2, (n-1) - (k-2) + 1):
            
            
            if i1 <= window_right:
                sl.remove(nums[i1])
            
            new_right = i1 + dist
            if new_right <= n-1:
                if new_right > window_right:
                    sl.add(nums[new_right])
                    window_right = new_right
            
            if len(sl) >= k-2:
                current_sum = sum(sl[:k-2])
                candidate = nums[0] + nums[i1] + current_sum
                if candidate < res:
                    res = candidate
            else:
                pass
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 13, 'lineno': 3}, {'name': 'minimumCost', 'complexity': 12, 'lineno': 4}], 'maintainability_index': 52.65597908052223, 'raw_metrics': {'loc': 44, 'lloc': 46, 'sloc': 44, 'comments': 1}}"
find-number-of-coins-to-place-in-tree-nodes,"```python
from typing import List

class Solution:
    def placedCoins(self, edges: List[List[int]], cost: List[int]) -> List[int]:
        n = len(cost)
        tree = [[] for _ in range(n)]
        for a, b in edges:
            tree[a].append(b)
            tree[b].append(a)
        
        res = [1] * n
        
        def dfs(u, parent):
            subtree = [cost[u]]
            for v in tree[u]:
                if v != parent:
                    subtree.extend(dfs(v, u))
            if len(subtree) < 3:
                res[u] = 1
            else:
                subtree_sorted = sorted(subtree)
                max1 = subtree_sorted[-1] * subtree_sorted[-2] * subtree_sorted[-3]
                max2 = subtree_sorted[0] * subtree_sorted[1] * subtree_sorted[-1]
                max_product = max(max1, max2)
                res[u] = max_product if max_product > 0 else 0
            return subtree
        
        dfs(0, -1)
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'placedCoins', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 53.24169317877734, 'raw_metrics': {'loc': 26, 'lloc': 26, 'sloc': 26, 'comments': 0}}"
maximum-strong-pair-xor-ii,"```python
from typing import List

class Solution:
    def maximumStrongPairXor(self, nums: List[int]) -> int:
        max_xor = 0
        nums_sorted = sorted(nums)
        n = len(nums_sorted)
        
        for i in range(n):
            x = nums_sorted[i]
            left = i
            right = n - 1
            target = 2 * x
            low, high = i, n - 1
            best = i
            while low <= high:
                mid = (low + high) // 2
                if nums_sorted[mid] <= target:
                    best = mid
                    low = mid + 1
                else:
                    high = mid - 1
            for j in range(i, best + 1):
                y = nums_sorted[j]
                current_xor = x ^ y
                if current_xor > max_xor:
                    max_xor = current_xor
        return max_xor
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'maximumStrongPairXor', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 52.43736141704181, 'raw_metrics': {'loc': 27, 'lloc': 27, 'sloc': 27, 'comments': 0}}"
subarrays-distinct-element-sum-of-squares-ii,"```python
class Solution:
    def sumCounts(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        total = 0
        n = len(nums)
        for i in range(n):
            distinct = set()
            for j in range(i, n):
                distinct.add(nums[j])
                total = (total + len(distinct) * len(distinct)) % MOD
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'sumCounts', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 63.62022852516724, 'raw_metrics': {'loc': 12, 'lloc': 12, 'sloc': 12, 'comments': 0}}"
minimum-edge-weight-equilibrium-queries-in-a-tree,"```python
from typing import List
from collections import deque

class Solution:
    def minOperationsQueries(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:
        adj = [[] for _ in range(n)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        
        parent = [0] * n
        depth = [0] * n
        q = deque([0])
        visited = [False] * n
        visited[0] = True
        while q:
            u = q.popleft()
            for v, w in adj[u]:
                if not visited[v] and v != parent[u]:
                    parent[v] = u
                    depth[v] = depth[u] + 1
                    visited[v] = True
                    q.append(v)
        
        LOG = 20
        up = [[-1]*n for _ in range(LOG)]
        up[0] = parent[:]
        for k in range(1, LOG):
            for v in range(n):
                if up[k-1][v] != -1:
                    up[k][v] = up[k-1][up[k-1][v]]
        
        def get_lca(u, v):
            if depth[u] < depth[v]:
                u, v = v, u
            for k in range(LOG-1, -1, -1):
                if depth[u] - (1 << k) >= depth[v]:
                    u = up[k][u]
            if u == v:
                return u
            for k in range(LOG-1, -1, -1):
                if up[k][u] != -1 and up[k][u] != up[k][v]:
                    u = up[k][u]
                    v = up[k][v]
            return parent[u]
        
        res = []
        for a, b in queries:
            lca = get_lca(a, b)
            freq = {}
            u = a
            while u != lca:
                for v, w in adj[u]:
                    if v == parent[u]:
                        freq[w] = freq.get(w, 0) + 1
                        break
                u = parent[u]
            u = b
            while u != lca:
                for v, w in adj[u]:
                    if v == parent[u]:
                        freq[w] = freq.get(w, 0) + 1
                        break
                u = parent[u]
            if not freq:
                res.append(0)
                continue
            max_freq = max(freq.values())
            total = sum(freq.values())
            res.append(total - max_freq)
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 20, 'lineno': 4}, {'name': 'minOperationsQueries', 'complexity': 19, 'lineno': 5}], 'maintainability_index': 37.978532928067864, 'raw_metrics': {'loc': 67, 'lloc': 68, 'sloc': 67, 'comments': 0}}"
find-a-good-subset-of-the-matrix,"```python
from typing import List

class Solution:
    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:
        m = len(grid)
        n = len(grid[0]) if m > 0 else 0
        
        for i in range(m):
            all_leq_half = True
            for val in grid[i]:
                if val > 0.5:  # since k=1, floor(1/2)=0, so sum must be 0
                    all_leq_half = False
                    break
            if all_leq_half:
                return [i]
        
        for i in range(m):
            for j in range(i + 1, m):
                k = 2
                valid = True
                for col in range(n):
                    total = grid[i][col] + grid[j][col]
                    if total > k // 2:
                        valid = False
                        break
                if valid:
                    return sorted([i, j])
        
        return []
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 3}, {'name': 'goodSubsetofBinaryMatrix', 'complexity': 11, 'lineno': 4}], 'maintainability_index': 66.1441136485535, 'raw_metrics': {'loc': 26, 'lloc': 26, 'sloc': 26, 'comments': 1}}"
minimum-reverse-operations,"```python
from collections import deque
from typing import List

class Solution:
    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:
        banned_set = set(banned)
        res = [-1] * n
        res[p] = 0
        q = deque([p])
        
        
        available = [set(), set()]  # 0 for even indices, 1 for odd
        for i in range(n):
            if i != p and i not in banned_set:
                available[i % 2].add(i)
        
        while q:
            current = q.popleft()
            low = max(0, current - k + 1)
            high = min(current, n - k)
            min_new_pos = 2 * low + k - 1 - current
            max_new_pos = 2 * high + k - 1 - current
            parity = (k - 1 - current) % 2
            to_remove = []
            for num in available[parity]:
                if min_new_pos <= num <= max_new_pos:
                    res[num] = res[current] + 1
                    q.append(num)
                    to_remove.append(num)
            for num in to_remove:
                available[parity].remove(num)
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 4}, {'name': 'minReverseOperations', 'complexity': 8, 'lineno': 5}], 'maintainability_index': 60.10592355526118, 'raw_metrics': {'loc': 29, 'lloc': 29, 'sloc': 29, 'comments': 1}}"
handling-sum-queries-after-update,"```python
class Solution:
    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
        n = len(nums1)
        res = []
        sum_nums2 = sum(nums2)
        sum_nums1 = sum(nums1)
        
        for query in queries:
            if query[0] == 1:
                l, r = query[1], query[2]
                for i in range(l, r + 1):
                    if nums1[i] == 1:
                        nums1[i] = 0
                        sum_nums1 -= 1
                    else:
                        nums1[i] = 1
                        sum_nums1 += 1
            elif query[0] == 2:
                p = query[1]
                sum_nums2 += sum_nums1 * p
            elif query[0] == 3:
                res.append(sum_nums2)
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 2}, {'name': 'handleQuery', 'complexity': 7, 'lineno': 3}], 'maintainability_index': 54.98123469058587, 'raw_metrics': {'loc': 23, 'lloc': 23, 'sloc': 23, 'comments': 0}}"
groups-of-strings,"```python
class Solution:
    def groupStrings(self, words: List[str]) -> List[int]:
        from collections import defaultdict, deque
        
        masks = []
        for word in words:
            mask = 0
            for c in word:
                mask |= 1 << (ord(c) - ord('a'))
            masks.append(mask)
        
        mask_to_indices = defaultdict(list)
        for idx, mask in enumerate(masks):
            mask_to_indices[mask].append(idx)
        
        visited = [False] * len(words)
        max_group_size = 0
        num_groups = 0
        
        for i in range(len(words)):
            if not visited[i]:
                queue = deque()
                queue.append(i)
                visited[i] = True
                current_group_size = 0
                
                while queue:
                    current_idx = queue.popleft()
                    current_group_size += 1
                    current_mask = masks[current_idx]
                    
                    for bit in range(26):
                        if not (current_mask & (1 << bit)):
                            new_mask = current_mask | (1 << bit)
                            if new_mask in mask_to_indices:
                                for neighbor_idx in mask_to_indices[new_mask]:
                                    if not visited[neighbor_idx]:
                                        visited[neighbor_idx] = True
                                        queue.append(neighbor_idx)
                    
                    for bit in range(26):
                        if current_mask & (1 << bit):
                            new_mask = current_mask ^ (1 << bit)
                            if new_mask in mask_to_indices:
                                for neighbor_idx in mask_to_indices[new_mask]:
                                    if not visited[neighbor_idx]:
                                        visited[neighbor_idx] = True
                                        queue.append(neighbor_idx)
                    
                    for bit_to_remove in range(26):
                        if current_mask & (1 << bit_to_remove):
                            temp_mask = current_mask ^ (1 << bit_to_remove)
                            for bit_to_add in range(26):
                                if not (temp_mask & (1 << bit_to_add)):
                                    new_mask = temp_mask | (1 << bit_to_add)
                                    if new_mask in mask_to_indices:
                                        for neighbor_idx in mask_to_indices[new_mask]:
                                            if not visited[neighbor_idx]:
                                                visited[neighbor_idx] = True
                                                queue.append(neighbor_idx)
                
                max_group_size = max(max_group_size, current_group_size)
                num_groups += 1
        
        return [num_groups, max_group_size]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 25, 'lineno': 2}, {'name': 'groupStrings', 'complexity': 24, 'lineno': 3}], 'maintainability_index': 39.83803213628844, 'raw_metrics': {'loc': 56, 'lloc': 56, 'sloc': 56, 'comments': 0}}"
kth-smallest-product-of-two-sorted-arrays,"```python
from typing import List

class Solution:
    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:
        def count_leq(mid):
            count = 0
            for num in nums1:
                if num == 0:
                    if mid >= 0:
                        count += len(nums2)
                elif num > 0:
                    left, right = 0, len(nums2)
                    while left < right:
                        mid_j = (left + right) // 2
                        if num * nums2[mid_j] <= mid:
                            left = mid_j + 1
                        else:
                            right = mid_j
                    count += left
                else:
                    left, right = 0, len(nums2)
                    while left < right:
                        mid_j = (left + right) // 2
                        if num * nums2[mid_j] <= mid:
                            right = mid_j
                        else:
                            left = mid_j + 1
                    count += len(nums2) - left
            return count

        left = -10**10 - 1
        right = 10**10 + 1
        while left < right:
            mid = (left + right) // 2
            if count_leq(mid) < k:
                left = mid + 1
            else:
                right = mid
        return left
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'kthSmallestProduct', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 46.35102986249939, 'raw_metrics': {'loc': 38, 'lloc': 38, 'sloc': 38, 'comments': 0}}"
find-servers-that-handled-most-number-of-requests,"```python
import heapq
from typing import List

class Solution:
    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:
        available = list(range(k))
        heapq.heapify(available)
        busy = []
        count = [0] * k
        
        for i, (start, duration) in enumerate(zip(arrival, load)):
            while busy and busy[0][0] <= start:
                _, server = heapq.heappop(busy)
                heapq.heappush(available, server)
            
            if not available:
                continue
            
            idx = i % k
            temp = []
            found = None
            while available:
                server = heapq.heappop(available)
                temp.append(server)
                if server >= idx:
                    found = server
                    break
            for server in temp:
                if server != found:
                    heapq.heappush(available, server)
            
            if found is not None:
                selected = found
            else:
                selected = heapq.heappop(available)
            
            count[selected] += 1
            heapq.heappush(busy, (start + duration, selected))
        
        max_requests = max(count)
        return [i for i, c in enumerate(count) if c == max_requests]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 13, 'lineno': 4}, {'name': 'busiestServers', 'complexity': 12, 'lineno': 5}], 'maintainability_index': 49.28879234947793, 'raw_metrics': {'loc': 35, 'lloc': 35, 'sloc': 35, 'comments': 0}}"
stone-game-v,"```python
class Solution:
    def stoneGameV(self, stoneValue: List[int]) -> int:
        n = len(stoneValue)
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i + 1] = prefix[i] + stoneValue[i]
        
        memo = [[-1 for _ in range(n)] for __ in range(n)]
        
        def dfs(left, right):
            if left == right:
                return 0
            if memo[left][right] != -1:
                return memo[left][right]
            
            res = 0
            for k in range(left, right):
                left_sum = prefix[k + 1] - prefix[left]
                right_sum = prefix[right + 1] - prefix[k + 1]
                
                if left_sum < right_sum:
                    res = max(res, left_sum + dfs(left, k))
                elif left_sum > right_sum:
                    res = max(res, right_sum + dfs(k + 1, right))
                else:
                    res = max(res, left_sum + max(dfs(left, k), dfs(k + 1, right)))
            
            memo[left][right] = res
            return res
        
        return dfs(0, n - 1)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'stoneGameV', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 51.123369351858535, 'raw_metrics': {'loc': 26, 'lloc': 26, 'sloc': 26, 'comments': 0}}"
maximum-unique-subarray-sum-after-deletion,"```python
class Solution:
    def maxSum(self, nums: List[int]) -> int:
        max_sum = -float('inf')
        n = len(nums)
        
        for i in range(n):
            current_sum = 0
            seen = set()
            for j in range(i, n):
                if nums[j] in seen:
                    break
                seen.add(nums[j])
                current_sum += nums[j]
                if current_sum > max_sum:
                    max_sum = current_sum
        
        return max_sum if max_sum != -float('inf') else 0
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 2}, {'name': 'maxSum', 'complexity': 6, 'lineno': 3}], 'maintainability_index': 60.38166826687358, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
sum-of-variable-length-subarrays,"```python
class Solution:
    def subarraySum(self, nums: List[int]) -> int:
        total = 0
        n = len(nums)
        for i in range(n):
            start = max(0, i - nums[i] + 1)
            subarray = nums[start:i+1]
            total += sum(subarray)
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 2}, {'name': 'subarraySum', 'complexity': 2, 'lineno': 3}], 'maintainability_index': 65.98233807058165, 'raw_metrics': {'loc': 10, 'lloc': 11, 'sloc': 10, 'comments': 0}}"
zigzag-grid-traversal-with-skip,"```python
from typing import List

class Solution:
    def zigzagTraversal(self, grid: List[List[int]]) -> List[int]:
        result = []
        m = len(grid)
        if m == 0:
            return result
        n = len(grid[0])
        
        for i in range(m):
            if i % 2 == 0:
                for j in range(0, n, 2):
                    result.append(grid[i][j])
            else:
                for j in range(n-1, -1, -2):
                    result.append(grid[i][j])
        
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'zigzagTraversal', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 60.012128709014384, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
substring-matching-pattern,"```python
class Solution:
    def hasMatch(self, s: str, p: str) -> bool:
        star_index = p.find('*')
        prefix = p[:star_index]
        suffix = p[star_index + 1:]
        
        for i in range(len(s) + 1):
            if i < len(prefix):
                continue
            if len(s) - i < len(suffix):
                continue
            if s.startswith(prefix, i - len(prefix)) and s.endswith(suffix, i + len(suffix)):
                return True
        return False
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 1}, {'name': 'hasMatch', 'complexity': 6, 'lineno': 2}], 'maintainability_index': 59.52337786345698, 'raw_metrics': {'loc': 13, 'lloc': 15, 'sloc': 13, 'comments': 0}}"
smallest-number-with-all-set-bits,"```python
class Solution:
    def smallestNumber(self, n: int) -> int:
        if n == 0:
            return 1
        m = 1
        while m <= n:
            m = (m << 1) | 1
        return m
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'smallestNumber', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 68.6972229335356, 'raw_metrics': {'loc': 8, 'lloc': 8, 'sloc': 8, 'comments': 0}}"
stone-removal-game,"```python
class Solution:
    def canAliceWin(self, n: int) -> bool:
        if n < 10:
            return False
        remaining = n - 10
        if remaining <= 0:
            return True
        return remaining > 9
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'canAliceWin', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 68.6972229335356, 'raw_metrics': {'loc': 8, 'lloc': 8, 'sloc': 8, 'comments': 0}}"
minimum-operations-to-make-array-values-equal-to-k,"```python
from typing import List

class Solution:
    def minOperations(self, nums: List[int], k: int) -> int:
        operations = 0
        current_max = max(nums)
        
        if current_max < k:
            return -1
        
        while current_max > k:
            next_max = k
            for num in nums:
                if num > k and num < current_max:
                    next_max = max(next_max, num)
            operations += 1
            current_max = next_max
        
        return operations
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'minOperations', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 59.799511815620136, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
adjacent-increasing-subarrays-detection-i,"```python
from typing import List

class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        increasing = []
        
        for i in range(n - k + 1):
            is_increasing = True
            for j in range(i + 1, i + k):
                if nums[j] <= nums[j - 1]:
                    is_increasing = False
                    break
            if is_increasing:
                increasing.append(i)
        
        for i in range(len(increasing) - 1):
            if increasing[i + 1] == increasing[i] + k:
                return True
        
        return False
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'hasIncreasingSubarrays', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 56.983052900359944, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
find-the-encrypted-string,"```python
class Solution:
    def getEncryptedString(self, s: str, k: int) -> str:
        encrypted = []
        n = len(s)
        for c in s:
            original_pos = ord(c) - ord('a')
            new_pos = (original_pos + k) % 26
            new_char = chr(ord('a') + new_pos)
            encrypted.append(new_char)
        return ''.join(encrypted)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 1}, {'name': 'getEncryptedString', 'complexity': 2, 'lineno': 2}], 'maintainability_index': 66.45196756512927, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
matrix-similarity-after-cyclic-shifts,"```python
from typing import List

class Solution:
    def areSimilar(self, mat: List[List[int]], k: int) -> bool:
        if not mat:
            return True
        
        m = len(mat)
        n = len(mat[0]) if m > 0 else 0
        
        original = [row.copy() for row in mat]
        
        for _ in range(k):
            for i in range(m):
                if i % 2 == 0:
                    shift = k % n
                    mat[i] = mat[i][shift:] + mat[i][:shift]
                else:
                    shift = k % n
                    mat[i] = mat[i][-shift:] + mat[i][:-shift]
        
        return mat == original
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'areSimilar', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 55.74951014904079, 'raw_metrics': {'loc': 18, 'lloc': 20, 'sloc': 18, 'comments': 0}}"
minimum-right-shifts-to-sort-the-array,"```python
from typing import List

class Solution:
    def minimumRightShifts(self, nums: List[int]) -> int:
        n = len(nums)
        sorted_nums = sorted(nums)
        for shift in range(n):
            if all(nums[(i + shift) % n] == sorted_nums[i] for i in range(n)):
                return shift
        return -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'minimumRightShifts', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 66.4475577173784, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
zero-array-transformation-iv,"```python
from typing import List

class Solution:
    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        m = len(queries)
        original = nums.copy()
        
        for k in range(1, m + 1):
            nums = original.copy()
            for i in range(k):
                l, r, val = queries[i]
                for j in range(l, r + 1):
                    if nums[j] >= val:
                        nums[j] -= val
                    else:
                        break
                else:
                    continue
                break
            else:
                if all(x == 0 for x in nums):
                    return k
        
        return -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 3}, {'name': 'minZeroArray', 'complexity': 9, 'lineno': 4}], 'maintainability_index': 56.355751874351235, 'raw_metrics': {'loc': 23, 'lloc': 23, 'sloc': 23, 'comments': 0}}"
find-the-minimum-amount-of-time-to-brew-potions,"```python
from typing import List

class Solution:
    def minTime(self, skill: List[int], mana: List[int]) -> int:
        n = len(skill)
        m = len(mana)
        if n == 0 or m == 0:
            return 0
        
        time = [[0] * m for _ in range(n)]
        for i in range(n):
            for j in range(m):
                time[i][j] = skill[i] * mana[j]
        
        end_times = [[0] * m for _ in range(n)]
        end_times[0][0] = time[0][0]
        for i in range(1, n):
            end_times[i][0] = end_times[i-1][0] + time[i][0]
        
        for j in range(1, m):
            end_times[0][j] = end_times[0][j-1] + time[0][j]
        
        for i in range(1, n):
            for j in range(1, m):
                end_times[i][j] = max(end_times[i-1][j], end_times[i][j-1]) + time[i][j]
        
        return end_times[-1][-1]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 3}, {'name': 'minTime', 'complexity': 11, 'lineno': 4}], 'maintainability_index': 53.03415534131583, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
fruits-into-baskets-iii,"```python
from typing import List

class Solution:
    def numOfUnplacedFruits(self, fruits: List[int], baskets: List[int]) -> int:
        baskets_sorted = sorted(baskets)
        used = [False] * len(baskets_sorted)
        unplaced = 0
        
        for fruit in fruits:
            placed = False
            for i in range(len(baskets_sorted)):
                if not used[i] and baskets_sorted[i] >= fruit:
                    used[i] = True
                    placed = True
                    break
            if not placed:
                unplaced += 1
                
        return unplaced
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'numOfUnplacedFruits', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 59.64223686565527, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
find-the-number-of-copy-arrays,"```python
from typing import List

class Solution:
    def countArrays(self, original: List[int], bounds: List[List[int]]) -> int:
        n = len(original)
        if n == 0:
            return 0
        
        min_k = -float('inf')
        max_k = float('inf')
        
        for i in range(1, n):
            delta_original = original[i] - original[i-1]
            lower_i = bounds[i][0]
            upper_i = bounds[i][1]
            lower_prev = bounds[i-1][0]
            upper_prev = bounds[i-1][1]
            
            new_lower = lower_i - delta_original
            new_upper = upper_i - delta_original
            
            current_lower = max(lower_prev, new_lower)
            current_upper = min(upper_prev, new_upper)
            
            if current_lower > current_upper:
                return 0
            
            k_lower = bounds[0][0] - original[0]
            k_upper = bounds[0][1] - original[0]
            
            k_lower = max(k_lower, current_lower - original[i-1])
            k_upper = min(k_upper, current_upper - original[i-1])
            
            if k_lower > k_upper:
                return 0
        
        last_lower = bounds[-1][0] - original[-1]
        last_upper = bounds[-1][1] - original[-1]
        k_lower = max(k_lower, last_lower)
        k_upper = min(k_upper, last_upper)
        
        if k_lower > k_upper:
            return 0
        
        return k_upper - k_lower + 1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'countArrays', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 47.89441745256657, 'raw_metrics': {'loc': 34, 'lloc': 34, 'sloc': 34, 'comments': 0}}"
eat-pizzas,"```python
from typing import List

class Solution:
    def maxWeight(self, pizzas: List[int]) -> int:
        pizzas.sort()
        total = 0
        n = len(pizzas)
        day = 1
        left = 0
        right = n - 1
        while left <= right:
            if day % 2 == 1:
                total += pizzas[right]
                right -= 4
            else:
                total += pizzas[right - 1]
                right -= 4
            day += 1
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'maxWeight', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 57.00884881581114, 'raw_metrics': {'loc': 19, 'lloc': 19, 'sloc': 19, 'comments': 0}}"
find-minimum-cost-to-remove-array-elements,"```python
from typing import List

class Solution:
    def minCost(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [[0] * (n + 1) for _ in range(n + 1)]
        
        for length in range(1, n + 1):
            for i in range(n - length + 1):
                j = i + length
                if length <= 2:
                    dp[i][j] = max(nums[i:j])
                else:
                    min_cost = float('inf')
                    for k in range(i + 1, j):
                        cost = dp[i][k] + dp[k][j]
                        if cost < min_cost:
                            min_cost = cost
                    dp[i][j] = min_cost
                    if length == 3:
                        dp[i][j] = min(dp[i][j], max(nums[i], nums[i+1]) + max(nums[i+2], 0))
                        dp[i][j] = min(dp[i][j], max(nums[i], nums[i+2]) + max(nums[i+1], 0))
                        dp[i][j] = min(dp[i][j], max(nums[i+1], nums[i+2]) + max(nums[i], 0))
        return dp[0][n]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 3}, {'name': 'minCost', 'complexity': 8, 'lineno': 4}], 'maintainability_index': 51.41309524531577, 'raw_metrics': {'loc': 23, 'lloc': 24, 'sloc': 23, 'comments': 0}}"
select-k-disjoint-special-substrings,"```python
class Solution:
    def maxSubstringLength(self, s: str, k: int) -> bool:
        if k == 0:
            return True
        n = len(s)
        if k > 26:
            return False
        
        last_occurrence = {}
        for i, ch in enumerate(s):
            last_occurrence[ch] = i
        
        result = 0
        start = 0
        min_end = float('inf')
        
        for i, ch in enumerate(s):
            min_end = min(min_end, last_occurrence[ch])
            if i == min_end:
                if i - start + 1 < n:
                    result += 1
                    if result >= k:
                        return True
                start = i + 1
                min_end = float('inf')
        
        return result >= k
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 1}, {'name': 'maxSubstringLength', 'complexity': 8, 'lineno': 2}], 'maintainability_index': 54.460561521316414, 'raw_metrics': {'loc': 23, 'lloc': 23, 'sloc': 23, 'comments': 0}}"
assign-elements-to-groups-with-constraints,"```python
from typing import List

class Solution:
    def assignElements(self, groups: List[int], elements: List[int]) -> List[int]:
        assigned = []
        element_indices = {}  # Maps element value to the smallest index
        
        for j in range(len(elements)):
            val = elements[j]
            if val not in element_indices:
                element_indices[val] = j
        
        for group_size in groups:
            found = -1
            for val in sorted(element_indices.keys()):
                if group_size % val == 0:
                    found = element_indices[val]
                    break
            assigned.append(found)
        return assigned
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'assignElements', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 74.45291364004693, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 1}}"
maximum-frequency-after-subarray-operation,"```python
from typing import List

class Solution:
    def maxFrequency(self, nums: List[int], k: int) -> int:
        max_freq = 0
        n = len(nums)
        
        
        
        
        total_k = nums.count(k)
        max_freq = total_k  # at least this, by choosing empty subarray
        
        
        from collections import defaultdict
        
        
        max_diff = 0
        current_diff = 0
        val_to_max_diff = defaultdict(int)
        
        for num in nums:
            if num == k:
                current_diff -= 1
            else:
                current_diff += 1
            if current_diff > max_diff:
                max_diff = current_diff
            if current_diff < 0:
                current_diff = 0
        max_freq = total_k + max_diff
        
        return max_freq
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'maxFrequency', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 69.06024064483704, 'raw_metrics': {'loc': 23, 'lloc': 23, 'sloc': 23, 'comments': 1}}"
closest-equal-element-queries,"```python
from collections import defaultdict
from bisect import bisect_left, bisect_right
from typing import List

class Solution:
    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:
        value_indices = defaultdict(list)
        for idx, num in enumerate(nums):
            value_indices[num].append(idx)
        
        answer = []
        n = len(nums)
        for query in queries:
            target = nums[query]
            indices = value_indices.get(target, [])
            if len(indices) <= 1:
                answer.append(-1)
                continue
            
            pos = bisect_left(indices, query)
            min_dist = float('inf')
            if pos > 0:
                min_dist = min(min_dist, (query - indices[pos - 1]) % n)
            if pos < len(indices) - 1:
                min_dist = min(min_dist, (indices[pos + 1] - query) % n)
            if pos < len(indices):
                if indices[pos] != query:
                    min_dist = min(min_dist, (indices[pos] - query) % n)
                elif pos + 1 < len(indices):
                    min_dist = min(min_dist, (indices[pos + 1] - query) % n)
            if pos > 0:
                if indices[pos - 1] != query:
                    min_dist = min(min_dist, (query - indices[pos - 1]) % n)
                elif pos - 2 >= 0:
                    min_dist = min(min_dist, (query - indices[pos - 2]) % n)
            
            answer.append(min_dist if min_dist != float('inf') else -1)
        
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 14, 'lineno': 5}, {'name': 'solveQueries', 'complexity': 13, 'lineno': 6}], 'maintainability_index': 45.48194822876155, 'raw_metrics': {'loc': 35, 'lloc': 35, 'sloc': 35, 'comments': 0}}"
reschedule-meetings-for-maximum-free-time-ii,"```python
from typing import List

class Solution:
    def maxFreeTime(self, eventTime: int, startTime: List[int], endTime: List[int]) -> int:
        intervals = sorted(zip(startTime, endTime), key=lambda x: x[0])
        n = len(intervals)
        if n == 0:
            return eventTime
        
        max_gap = 0
        gaps = []
        prev_end = 0
        for s, e in intervals:
            gap = s - prev_end
            gaps.append(gap)
            if gap > max_gap:
                max_gap = gap
            prev_end = e
        gap_after_last = eventTime - intervals[-1][1]
        gaps.append(gap_after_last)
        if gap_after_last > max_gap:
            max_gap = gap_after_last
        
        if n == 1:
            s, e = intervals[0]
            duration = e - s
            return max(eventTime - duration, intervals[0][0])
        
        prefix_max = [0] * (n + 1)
        suffix_max = [0] * (n + 1)
        
        for i in range(1, n + 1):
            prefix_max[i] = max(prefix_max[i-1], gaps[i-1])
        
        for i in range(n - 1, -1, -1):
            suffix_max[i] = max(suffix_max[i+1], gaps[i+1])
        
        res = max_gap  # initial max without moving any meeting
        
        for i in range(n):
            s, e = intervals[i]
            duration = e - s
            if i == 0:
                new_start = eventTime - duration
                if new_start >= intervals[1][0] - duration:
                    continue  # can't move without overlapping
                new_gap_before = intervals[1][0] - 0
                new_gap_after = eventTime - (new_start + duration)
                current_max = max(new_gap_before, new_gap_after)
                if i + 1 < n:
                    current_max = max(current_max, suffix_max[i+1])
                res = max(res, current_max)
            elif i == n - 1:
                new_start = 0
                new_end = duration
                if new_end > intervals[-2][1]:
                    continue  # can't move without overlapping
                new_gap_before = new_start - intervals[-2][1]
                new_gap_after = eventTime - new_end
                current_max = max(new_gap_before, new_gap_after)
                if i - 1 >= 0:
                    current_max = max(current_max, prefix_max[i])
                res = max(res, current_max)
            else:
                new_start = intervals[i-1][1]
                new_end = new_start + duration
                if new_end > intervals[i+1][0]:
                    continue  # overlaps with next meeting
                new_gap_before = new_start - intervals[i-1][1]
                new_gap_after = intervals[i+1][0] - new_end
                current_max = max(prefix_max[i], suffix_max[i+1])
                current_max = max(current_max, new_gap_before, new_gap_after)
                res = max(res, current_max)
                
                new_end = intervals[i+1][0]
                new_start = new_end - duration
                if new_start < intervals[i-1][1]:
                    continue  # overlaps with previous meeting
                new_gap_before = new_start - intervals[i-1][1]
                new_gap_after = intervals[i+1][0] - new_end
                current_max = max(prefix_max[i], suffix_max[i+1])
                current_max = max(current_max, new_gap_before, new_gap_after)
                res = max(res, current_max)
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 18, 'lineno': 3}, {'name': 'maxFreeTime', 'complexity': 17, 'lineno': 4}], 'maintainability_index': 50.44984313263549, 'raw_metrics': {'loc': 76, 'lloc': 77, 'sloc': 76, 'comments': 5}}"
count-mentions-per-user,"```python
from typing import List

class Solution:
    def countMentions(self, numberOfUsers: int, events: List[List[str]]) -> List[int]:
        mentions = [0] * numberOfUsers
        online_status = [True] * numberOfUsers
        offline_events = []  # list of (end_time, user_id)
        
        events.sort(key=lambda x: int(x[1]))
        
        for event in events:
            event_type, timestamp_str, data = event
            timestamp = int(timestamp_str)
            
            new_offline_events = []
            for end_time, user_id in offline_events:
                if end_time <= timestamp:
                    online_status[user_id] = True
                else:
                    new_offline_events.append((end_time, user_id))
            offline_events = new_offline_events
            
            if event_type == ""OFFLINE"":
                user_id = int(data)
                offline_events.append((timestamp + 60, user_id))
                online_status[user_id] = False
            elif event_type == ""MESSAGE"":
                if data == ""ALL"":
                    for i in range(numberOfUsers):
                        mentions[i] += 1
                elif data == ""HERE"":
                    for i in range(numberOfUsers):
                        if online_status[i]:
                            mentions[i] += 1
                else:
                    parts = data.split()
                    for part in parts:
                        if part.startswith(""id""):
                            user_id = int(part[2:])
                            mentions[user_id] += 1
        
        return mentions
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 14, 'lineno': 3}, {'name': 'countMentions', 'complexity': 13, 'lineno': 4}], 'maintainability_index': 58.09479101406359, 'raw_metrics': {'loc': 37, 'lloc': 39, 'sloc': 37, 'comments': 1}}"
minimize-the-maximum-edge-weight-of-graph,"```python
import heapq
from collections import defaultdict
from typing import List

class Solution:
    def minMaxWeight(self, n: int, edges: List[List[int]], threshold: int) -> int:
        reversed_edges = defaultdict(list)
        for a, b, w in edges:
            reversed_edges[b].append((a, w))
        
        left = 1
        right = max(w for _, _, w in edges) if edges else 0
        answer = -1
        
        def is_possible(max_weight):
            
            adj = defaultdict(list)
            for a, b, w in edges:
                if w <= max_weight:
                    adj[b].append((a, w))  # reversed edge
            
            min_edges = [threshold + 1] * n
            min_edges[0] = 0
            heap = []
            heapq.heappush(heap, (0, 0))  # (edges, node)
            
            while heap:
                current_edges, u = heapq.heappop(heap)
                if current_edges > min_edges[u]:
                    continue
                for v, w in adj[u]:
                    if min_edges[v] > current_edges + 1:
                        min_edges[v] = current_edges + 1
                        heapq.heappush(heap, (min_edges[v], v))
            
            for i in range(n):
                if min_edges[i] > threshold:
                    return False
            return True
        
        if not edges:
            return 0 if n == 1 else -1
        
        while left <= right:
            mid = (left + right) // 2
            if is_possible(mid):
                answer = mid
                right = mid - 1
            else:
                left = mid + 1
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 5}, {'name': 'minMaxWeight', 'complexity': 8, 'lineno': 6}], 'maintainability_index': 59.24623873628608, 'raw_metrics': {'loc': 43, 'lloc': 43, 'sloc': 43, 'comments': 2}}"
longest-subsequence-with-decreasing-adjacent-difference,"```python
from typing import List

class Solution:
    def longestSubsequence(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 0:
            return 0
        
        dp = [1] * n
        diff = [0] * n
        
        for i in range(1, n):
            for j in range(i):
                current_diff = abs(nums[i] - nums[j])
                if dp[j] >= dp[i]:
                    if dp[j] == 1:
                        dp[i] = dp[j] + 1
                        diff[i] = current_diff
                    else:
                        if current_diff <= diff[j]:
                            dp[i] = dp[j] + 1
                            diff[i] = current_diff
        return max(dp)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'longestSubsequence', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 55.60768209165827, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
maximum-coins-from-k-consecutive-bags,"```python
from typing import List

class Solution:
    def maximumCoins(self, coins: List[List[int]], k: int) -> int:
        events = []
        for l, r, c in coins:
            events.append((l, c))
            events.append((r + 1, -c))
        
        events.sort()
        max_coins = 0
        current_coins = 0
        prev_pos = None
        
        for pos, delta in events:
            if prev_pos is not None and pos > prev_pos:
                segment_length = pos - prev_pos
                max_segment = min(segment_length, k)
                max_coins = max(max_coins, current_coins * max_segment)
                k -= max_segment
                if k <= 0:
                    break
            current_coins += delta
            prev_pos = pos
        
        return max_coins
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'maximumCoins', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 54.61391761310031, 'raw_metrics': {'loc': 23, 'lloc': 23, 'sloc': 23, 'comments': 0}}"
maximum-and-minimum-sums-of-at-most-size-k-subsequences,"```python
import bisect

class Solution:
    def minMaxSums(self, nums: List[int], k: int) -> int:
        MOD = 10**9 + 7
        nums.sort()
        n = len(nums)
        res = 0
        
        pow2 = [1] * (n + 1)
        for i in range(1, n + 1):
            pow2[i] = (pow2[i-1] * 2) % MOD
        
        for i in range(n):
            right = n - i - 1
            max_j = min(k - 1, right)
            cnt_min = 0
            if max_j >= 0:
                cnt_min = pow2[right] - 1
                if right > max_j:
                    subtract = pow2[right - (max_j + 1)]
                    cnt_min = (pow2[right] - subtract) % MOD
            
            left = i
            max_j = min(k - 1, left)
            cnt_max = 0
            if max_j >= 0:
                cnt_max = pow2[left] - 1
                if left > max_j:
                    subtract = pow2[left - (max_j + 1)]
                    cnt_max = (pow2[left] - subtract) % MOD
            
            res = (res + nums[i] * (cnt_min + cnt_max)) % MOD
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'minMaxSums', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 47.894573612692014, 'raw_metrics': {'loc': 30, 'lloc': 30, 'sloc': 30, 'comments': 0}}"
minimum-cost-to-make-arrays-identical,"```python
from typing import List

class Solution:
    def minCost(self, arr: List[int], brr: List[int], k: int) -> int:
        if arr == brr:
            return 0
        
        arr_sorted = sorted(arr)
        brr_sorted = sorted(brr)
        
        cost = 0
        for a, b in zip(arr_sorted, brr_sorted):
            cost += abs(a - b)
        
        option1 = cost
        option2 = k
        
        return min(option1, option2)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'minCost', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 64.2704223558721, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
find-the-lexicographically-largest-string-from-the-box-i,"```python
class Solution:
    def answerString(self, word: str, numFriends: int) -> str:
        if numFriends == 1:
            return word
        max_str = """"
        n = len(word)
        for i in range(1, n - numFriends + 2):
            current = word[:i]
            if current > max_str:
                max_str = current
        return max_str
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 1}, {'name': 'answerString', 'complexity': 4, 'lineno': 2}], 'maintainability_index': 64.45570486333857, 'raw_metrics': {'loc': 11, 'lloc': 12, 'sloc': 11, 'comments': 0}}"
maximum-area-rectangle-with-point-constraints-i,"```python
from typing import List

class Solution:
    def maxRectangleArea(self, points: List[List[int]]) -> int:
        point_set = set((x, y) for x, y in points)
        max_area = -1
        
        for i in range(len(points)):
            x1, y1 = points[i]
            for j in range(len(points)):
                x2, y2 = points[j]
                if x1 < x2 and y1 < y2:
                    if (x1, y2) in point_set and (x2, y1) in point_set:
                        valid = True
                        for x, y in points:
                            if x1 < x < x2 and y1 < y < y2:
                                valid = False
                                break
                        if valid:
                            area = (x2 - x1) * (y2 - y1)
                            if area > max_area:
                                max_area = area
        return max_area
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 14, 'lineno': 3}, {'name': 'maxRectangleArea', 'complexity': 13, 'lineno': 4}], 'maintainability_index': 52.516238314084184, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
check-if-grid-can-be-cut-into-sections,"```python
from typing import List

class Solution:
    def checkValidCuts(self, n: int, rectangles: List[List[int]]) -> bool:
        def check_horizontal():
            y_coords = []
            for rect in rectangles:
                y_coords.append(rect[1])
                y_coords.append(rect[3])
            y_coords = sorted(list(set(y_coords)))
            
            for i in range(len(y_coords)):
                for j in range(i + 1, len(y_coords)):
                    y1 = y_coords[i]
                    y2 = y_coords[j]
                    lower = []
                    middle = []
                    upper = []
                    for rect in rectangles:
                        starty, endy = rect[1], rect[3]
                        if endy <= y1:
                            lower.append(rect)
                        elif starty >= y2:
                            upper.append(rect)
                        else:
                            middle.append(rect)
                    if lower and middle and upper:
                        return True
            return False
        
        def check_vertical():
            x_coords = []
            for rect in rectangles:
                x_coords.append(rect[0])
                x_coords.append(rect[2])
            x_coords = sorted(list(set(x_coords)))
            
            for i in range(len(x_coords)):
                for j in range(i + 1, len(x_coords)):
                    x1 = x_coords[i]
                    x2 = x_coords[j]
                    left = []
                    middle = []
                    right = []
                    for rect in rectangles:
                        startx, endx = rect[0], rect[2]
                        if endx <= x1:
                            left.append(rect)
                        elif startx >= x2:
                            right.append(rect)
                        else:
                            middle.append(rect)
                    if left and middle and right:
                        return True
            return False
        
        return check_horizontal() or check_vertical()
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 3}, {'name': 'checkValidCuts', 'complexity': 2, 'lineno': 4}], 'maintainability_index': 47.073975545548905, 'raw_metrics': {'loc': 53, 'lloc': 53, 'sloc': 53, 'comments': 0}}"
digit-operations-to-make-two-integers-equal,"```python
import math

class Solution:
    def minOperations(self, n: int, m: int) -> int:
        def is_prime(num):
            if num < 2:
                return False
            for i in range(2, int(math.sqrt(num)) + 1):
                if num % i == 0:
                    return False
            return True
        
        if is_prime(m):
            return -1
        
        from collections import deque
        
        visited = set()
        queue = deque()
        queue.append((n, 0))
        visited.add(n)
        
        while queue:
            current, cost = queue.popleft()
            if current == m:
                return cost + m
            
            digits = list(map(int, str(current)))
            for i in range(len(digits)):
                original_digit = digits[i]
                if original_digit != 9:
                    new_digits = digits.copy()
                    new_digits[i] += 1
                    new_num = int(''.join(map(str, new_digits)))
                    if not is_prime(new_num) and new_num not in visited:
                        visited.add(new_num)
                        queue.append((new_num, cost + current))
                if original_digit != 0:
                    new_digits = digits.copy()
                    new_digits[i] -= 1
                    new_num = int(''.join(map(str, new_digits)))
                    if not is_prime(new_num) and new_num not in visited:
                        visited.add(new_num)
                        queue.append((new_num, cost + current))
        
        return -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 2}, {'name': 'minOperations', 'complexity': 11, 'lineno': 3}], 'maintainability_index': 46.49077219734519, 'raw_metrics': {'loc': 39, 'lloc': 39, 'sloc': 39, 'comments': 0}}"
minimum-array-sum,"```python
import heapq

class Solution:
    def minArraySum(self, nums: List[int], k: int, op1: int, op2: int) -> int:
        heap = []
        for num in nums:
            heapq.heappush(heap, -num)
        
        for _ in range(op1):
            if not heap:
                break
            current = -heapq.heappop(heap)
            new_val = (current + 1) // 2
            heapq.heappush(heap, -new_val)
        
        heap2 = []
        while heap:
            val = -heapq.heappop(heap)
            if val >= k and op2 > 0:
                val -= k
                op2 -= 1
            heapq.heappush(heap2, val)
        
        return sum(heap2)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'minArraySum', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 55.04891489228088, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
maximum-subarray-sum-with-length-divisible-by-k,"```python
from typing import List

class Solution:
    def maxSubarraySum(self, nums: List[int], k: int) -> int:
        n = len(nums)
        prefix_sum = [0] * (n + 1)
        for i in range(n):
            prefix_sum[i + 1] = prefix_sum[i] + nums[i]
        
        max_sum = -float('inf')
        remainder_min = {}
        remainder_min[0] = 0  # prefix_sum[0] is 0, remainder 0
        
        for i in range(1, n + 1):
            remainder = prefix_sum[i] % k
            if remainder in remainder_min:
                current_sum = prefix_sum[i] - remainder_min[remainder]
                if current_sum > max_sum:
                    max_sum = current_sum
            if remainder not in remainder_min or prefix_sum[i] < remainder_min[remainder]:
                remainder_min[remainder] = prefix_sum[i]
        
        return max_sum
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'maxSubarraySum', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 67.71279095556415, 'raw_metrics': {'loc': 20, 'lloc': 20, 'sloc': 20, 'comments': 1}}"
minimum-time-to-break-locks-i,"```python
import itertools

class Solution:
    def findMinimumTime(self, strength: List[int], k: int) -> int:
        n = len(strength)
        min_time = float('inf')
        
        for perm in itertools.permutations(strength):
            current_time = 0
            x = 1
            energy = 0
            for s in perm:
                t = 0
                discriminant = (2 * x - 1) ** 2 + 8 * s
                sqrt_discriminant = int(discriminant ** 0.5)
                if sqrt_discriminant * sqrt_discriminant < discriminant:
                    sqrt_discriminant += 1
                t = (- (2 * x - 1) + sqrt_discriminant) // 2
                if t * (2 * x + t - 1) // 2 < s:
                    t += 1
                
                current_time += t
                energy = t * (2 * x + t - 1) // 2
                x += k
                
            if current_time < min_time:
                min_time = current_time
        
        return min_time
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'findMinimumTime', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 49.99949477218113, 'raw_metrics': {'loc': 25, 'lloc': 25, 'sloc': 25, 'comments': 0}}"
zero-array-transformation-iii,"```python
from typing import List

class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        m = len(queries)
        diff = [0] * (n + 2)
        
        for l, r in queries:
            diff[l] += 1
            diff[r + 1] -= 1
        
        coverage = [0] * n
        current = 0
        for i in range(n):
            current += diff[i]
            coverage[i] = current
        
        for i in range(n):
            if nums[i] > coverage[i]:
                return -1
        
        
        
        
        
        
        
        surplus = [coverage[i] - nums[i] for i in range(n)]
        
        
        size = 1
        while size < n:
            size <<= 1
        seg = [float('inf')] * (2 * size)
        
        for i in range(n):
            seg[size + i] = surplus[i]
        for i in range(size - 1, 0, -1):
            seg[i] = min(seg[2 * i], seg[2 * i + 1])
        
        def query_min(l, r):
            res = float('inf')
            l += size
            r += size
            while l < r:
                if l % 2 == 1:
                    res = min(res, seg[l])
                    l += 1
                if r % 2 == 1:
                    r -= 1
                    res = min(res, seg[r])
                l //= 2
                r //= 2
            return res
        
        removable = 0
        for l, r in queries:
            min_surplus = query_min(l, r + 1)
            if min_surplus >= 1:
                removable += 1
                pass
        
        return removable
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 3}, {'name': 'maxRemoval', 'complexity': 11, 'lineno': 4}], 'maintainability_index': 42.62345802112318, 'raw_metrics': {'loc': 48, 'lloc': 48, 'sloc': 48, 'comments': 0}}"
zero-array-transformation-ii,"```python
import bisect

class Solution:
    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        m = len(queries)
        
        diff = [0] * (n + 1)
        
        left = 0
        right = m
        answer = -1
        
        while left <= right:
            mid = (left + right) // 2
            diff = [0] * (n + 1)
            
            for i in range(mid):
                l, r, val = queries[i]
                diff[l] += val
                if r + 1 < n:
                    diff[r + 1] -= val
            
            possible = True
            current = 0
            for i in range(n):
                current += diff[i]
                if current > nums[i]:
                    possible = False
                    break
            
            if possible:
                answer = mid
                right = mid - 1
            else:
                left = mid + 1
        
        return answer if answer != -1 else -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 3}, {'name': 'minZeroArray', 'complexity': 8, 'lineno': 4}], 'maintainability_index': 49.12526917890545, 'raw_metrics': {'loc': 31, 'lloc': 31, 'sloc': 31, 'comments': 0}}"
zero-array-transformation-i,"```python
from typing import List

class Solution:
    def isZeroArray(self, nums: List[int], queries: List[List[int]]) -> bool:
        n = len(nums)
        diff = [0] * (n + 1)
        
        for l, r in queries:
            diff[l] += 1
            if r + 1 < n:
                diff[r + 1] -= 1
        
        current = 0
        for i in range(n):
            current += diff[i]
            if current > nums[i]:
                return False
        
        return sum(nums) == sum(r - l + 1 for l, r in queries)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'isZeroArray', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 57.39444909481121, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
find-minimum-time-to-reach-last-room-ii,"```python
import heapq

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0]) if n > 0 else 0
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        heap = []
        heapq.heappush(heap, (moveTime[0][0], 0, 0, 0))
        
        visited = {}
        visited[(0, 0, 0)] = moveTime[0][0]
        
        while heap:
            current_time, x, y, parity = heapq.heappop(heap)
            if x == n - 1 and y == m - 1:
                return current_time
            if current_time > visited.get((x, y, parity), float('inf')):
                continue
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    move_cost = 1 if parity == 0 else 2
                    new_time = max(current_time, moveTime[nx][ny]) + move_cost
                    new_parity = 1 - parity
                    key = (nx, ny, new_parity)
                    if new_time < visited.get(key, float('inf')):
                        visited[key] = new_time
                        heapq.heappush(heap, (new_time, nx, ny, new_parity))
        return -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 3}, {'name': 'minTimeToReach', 'complexity': 11, 'lineno': 4}], 'maintainability_index': 49.6039540960893, 'raw_metrics': {'loc': 28, 'lloc': 28, 'sloc': 28, 'comments': 0}}"
find-minimum-time-to-reach-last-room-i,"```python
import heapq
from typing import List

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0]) if n > 0 else 0
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        heap = []
        heapq.heappush(heap, (0, 0, 0))
        visited = [[False for _ in range(m)] for _ in range(n)]
        
        while heap:
            current_time, i, j = heapq.heappop(heap)
            if i == n - 1 and j == m - 1:
                return current_time
            if visited[i][j]:
                continue
            visited[i][j] = True
            
            for di, dj in directions:
                ni, nj = i + di, j + dj
                if 0 <= ni < n and 0 <= nj < m and not visited[ni][nj]:
                    new_time = max(current_time + 1, moveTime[ni][nj])
                    heapq.heappush(heap, (new_time, ni, nj))
        
        return -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 13, 'lineno': 4}, {'name': 'minTimeToReach', 'complexity': 12, 'lineno': 5}], 'maintainability_index': 51.53409233393864, 'raw_metrics': {'loc': 24, 'lloc': 24, 'sloc': 24, 'comments': 0}}"
maximum-frequency-of-an-element-after-performing-operations-i,"```python
from typing import List

class Solution:
    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:
        nums.sort()
        left = 0
        max_freq = 0
        total = 0
        
        for right in range(len(nums)):
            total += nums[right]
            
            while nums[right] * (right - left + 1) > total + k * min(numOperations, right - left + 1):
                total -= nums[left]
                left += 1
            
            current_window = right - left + 1
            if current_window <= numOperations or numOperations == 0:
                max_freq = max(max_freq, current_window)
            else:
                max_freq = max(max_freq, numOperations + 1)
        
        return max_freq
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'maxFrequency', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 54.56715247963991, 'raw_metrics': {'loc': 19, 'lloc': 19, 'sloc': 19, 'comments': 0}}"
adjacent-increasing-subarrays-detection-ii,"```python
from typing import List

class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 2:
            return 0
        
        lengths = [1] * n
        for i in range(n-2, -1, -1):
            if nums[i] < nums[i+1]:
                lengths[i] = lengths[i+1] + 1
        
        max_k = 0
        i = 0
        while i < n:
            current_len = lengths[i]
            next_start = i + current_len
            if next_start < n and lengths[next_start] >= current_len:
                max_k = max(max_k, current_len)
                i = next_start
            else:
                if current_len > 1:
                    potential_k = current_len - 1
                    if next_start - 1 < n and lengths[next_start - 1] >= potential_k:
                        max_k = max(max_k, potential_k)
                i += 1
        return max_k
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 3}, {'name': 'maxIncreasingSubarrays', 'complexity': 10, 'lineno': 4}], 'maintainability_index': 50.30107165575898, 'raw_metrics': {'loc': 26, 'lloc': 26, 'sloc': 26, 'comments': 0}}"
minimum-division-operations-to-make-array-non-decreasing,"```python
from typing import List

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 1:
            return 0
        
        operations = 0
        prev = nums[-1]
        
        for i in range(len(nums) - 2, -1, -1):
            current = nums[i]
            if current > prev:
                if prev == 0:
                    return -1
                target = (current + prev - 1) // prev  # Equivalent to ceiling(current / prev)
                if target > current:
                    return -1
                
                k = target
                while k <= current:
                    if current % k == 0:
                        break
                    k += 1
                if k > current:
                    return -1
                new_val = current // k
                operations += 1
                prev = new_val
            else:
                prev = current
        
        return operations
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 3}, {'name': 'minOperations', 'complexity': 9, 'lineno': 4}], 'maintainability_index': 60.437961939194594, 'raw_metrics': {'loc': 30, 'lloc': 30, 'sloc': 30, 'comments': 1}}"
identify-the-largest-outlier-in-an-array,"```python
from typing import List

class Solution:
    def getLargestOutlier(self, nums: List[int]) -> int:
        nums_sorted = sorted(nums)
        n = len(nums_sorted)
        
        sum_rest = sum(nums_sorted[:-1])
        if sum_rest - nums_sorted[-2] == nums_sorted[-2]:
            return nums_sorted[-1]
        
        sum_rest = sum(nums_sorted[1:])
        if sum_rest - nums_sorted[1] == nums_sorted[1]:
            return nums_sorted[0]
        
        return max(nums_sorted[0], nums_sorted[-1])
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'getLargestOutlier', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 60.52460603050095, 'raw_metrics': {'loc': 13, 'lloc': 15, 'sloc': 13, 'comments': 0}}"
find-the-lexicographically-smallest-valid-sequence,"```python
from typing import List

class Solution:
    def validSequence(self, word1: str, word2: str) -> List[int]:
        n1, n2 = len(word1), len(word2)
        if n1 < n2:
            return []
        
        result = []
        mismatch_used = False
        i = 0  # pointer for word1
        j = 0  # pointer for word2
        
        while j < n2 and i < n1:
            if word1[i] == word2[j]:
                result.append(i)
                i += 1
                j += 1
            else:
                if not mismatch_used:
                    result.append(i)
                    i += 1
                    j += 1
                    mismatch_used = True
                else:
                    i += 1
        
        if j < n2:
            return []
        
        if mismatch_used:
            result = []
            mismatch_pos = -1
            i = 0
            j = 0
            while j < n2:
                if i >= n1:
                    return []
                if word1[i] == word2[j]:
                    result.append(i)
                    i += 1
                    j += 1
                else:
                    if mismatch_pos == -1:
                        mismatch_pos = j
                        result.append(i)
                        i += 1
                        j += 1
                    else:
                        i += 1
            if j < n2:
                return []
            
            
            
            
            
            min_result = None
            for possible_mismatch in range(n2):
                temp_result = []
                i = 0
                j = 0
                used = False
                valid = True
                while j < n2:
                    if i >= n1:
                        valid = False
                        break
                    if j == possible_mismatch:
                        temp_result.append(i)
                        i += 1
                        j += 1
                        used = True
                    else:
                        if word1[i] == word2[j]:
                            temp_result.append(i)
                            i += 1
                            j += 1
                        else:
                            if not used:
                                temp_result.append(i)
                                i += 1
                                j += 1
                                used = True
                            else:
                                i += 1
                if valid and j == n2:
                    if min_result is None or temp_result < min_result:
                        min_result = temp_result.copy()
            if min_result is not None:
                return min_result
            else:
                return []
        else:
            return list(range(n2))
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 25, 'lineno': 3}, {'name': 'validSequence', 'complexity': 24, 'lineno': 4}], 'maintainability_index': 43.94425507249192, 'raw_metrics': {'loc': 86, 'lloc': 86, 'sloc': 86, 'comments': 2}}"
count-almost-equal-pairs-i,"```python
from typing import List

class Solution:
    def countPairs(self, nums: List[int]) -> int:
        def is_almost_equal(x, y):
            s1 = str(x)
            s2 = str(y)
            if len(s1) != len(s2):
                return False
            diff = []
            for a, b in zip(s1, s2):
                if a != b:
                    diff.append((a, b))
                if len(diff) > 2:
                    return False
            if not diff:
                return True
            if len(diff) == 2:
                (a1, b1), (a2, b2) = diff
                return a1 == b2 and a2 == b1
            return False
        
        count = 0
        n = len(nums)
        for i in range(n):
            for j in range(i + 1, n):
                if is_almost_equal(nums[i], nums[j]):
                    count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'countPairs', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 52.92981873653482, 'raw_metrics': {'loc': 28, 'lloc': 28, 'sloc': 28, 'comments': 0}}"
reach-end-of-array-with-max-score,"```python
from typing import List

class Solution:
    def findMaximumScore(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [0] * n
        max_score = [0] * n
        max_score[-1] = nums[-1]
        
        for i in range(n - 2, -1, -1):
            max_score[i] = max(max_score[i + 1], nums[i])
        
        dp[0] = nums[0] * (n - 1)
        
        for i in range(1, n):
            dp[i] = max(dp[i - 1], nums[i] * (n - 1 - i))
        
        res = 0
        for i in range(n - 1):
            res = max(res, nums[i] * (n - 1 - i) + dp[i])
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'findMaximumScore', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 55.96209207420812, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
minimum-number-of-flips-to-make-binary-grid-palindromic-ii,"```python
from typing import List

class Solution:
    def minFlips(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0]) if m > 0 else 0
        
        total_ones = sum(sum(row) for row in grid)
        if total_ones % 4 != 0:
            rem = total_ones % 4
            adjustment_needed = min(rem, 4 - rem)
        else:
            adjustment_needed = 0
        
        flips = 0
        
        for i in range(m):
            left = 0
            right = n - 1
            while left < right:
                if grid[i][left] != grid[i][right]:
                    flips += 1
                left += 1
                right -= 1
        
        for j in range(n):
            top = 0
            bottom = m - 1
            while top < bottom:
                if grid[top][j] != grid[bottom][j]:
                    flips += 1
                top += 1
                bottom -= 1
        
        return flips + adjustment_needed
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 3}, {'name': 'minFlips', 'complexity': 10, 'lineno': 4}], 'maintainability_index': 49.53767213719308, 'raw_metrics': {'loc': 30, 'lloc': 30, 'sloc': 30, 'comments': 0}}"
find-the-power-of-k-size-subarrays-i,"```python
from typing import List

class Solution:
    def resultsArray(self, nums: List[int], k: int) -> List[int]:
        results = []
        n = len(nums)
        for i in range(n - k + 1):
            subarray = nums[i:i + k]
            sorted_sub = sorted(subarray)
            if sorted_sub == list(range(sorted_sub[0], sorted_sub[0] + k)):
                results.append(max(subarray))
            else:
                results.append(-1)
        return results
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'resultsArray', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 61.308647766390365, 'raw_metrics': {'loc': 14, 'lloc': 15, 'sloc': 14, 'comments': 0}}"
shortest-distance-after-road-addition-queries-i,"```python
from typing import List
import heapq

class Solution:
    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        graph = [[] for _ in range(n)]
        for i in range(n - 1):
            graph[i].append((i + 1, 1))
        
        answer = []
        current_min = n - 1  # initial path 0 -> 1 -> ... -> n-1
        
        for u, v in queries:
            graph[u].append((v, 1))
            if u == 0 and v == n - 1:
                current_min = 1
            elif u == 0:
                potential = 1 + (n - 1 - v)
                if potential < current_min:
                    current_min = potential
            elif v == n - 1:
                potential = u + 1
                if potential < current_min:
                    current_min = potential
            else:
                potential = u + 1 + (n - 1 - v)
                if potential < current_min:
                    current_min = potential
            answer.append(current_min)
        
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 4}, {'name': 'shortestDistanceAfterQueries', 'complexity': 11, 'lineno': 5}], 'maintainability_index': 60.83194171083626, 'raw_metrics': {'loc': 28, 'lloc': 28, 'sloc': 28, 'comments': 1}}"
maximize-the-total-height-of-unique-towers,"```python
class Solution:
    def maximumTotalSum(self, maximumHeight: List[int]) -> int:
        maximumHeight.sort()
        total = 0
        prev = 0
        for h in maximumHeight:
            current = max(prev + 1, h)
            if current > h:
                return -1
            total += current
            prev = current
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'maximumTotalSum', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 64.52981350263006, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
k-th-largest-perfect-subtree-size-in-binary-tree,"```python
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        perfect_sizes = []
        
        def dfs(node):
            if not node:
                return (0, 0)  # (depth, size)
            
            left_depth, left_size = dfs(node.left)
            right_depth, right_size = dfs(node.right)
            
            current_depth = min(left_depth, right_depth) + 1 if (node.left and node.right) else 1
            current_size = (1 << current_depth) - 1  # 2^depth - 1
            
            if node.left and node.right and left_depth == right_depth:
                perfect_sizes.append(current_size)
            else:
                if node.left:
                    perfect_sizes.append(left_size)
                if node.right:
                    perfect_sizes.append(right_size)
                if not node.left and not node.right:
                    perfect_sizes.append(1)
            
            return (current_depth, current_size)
        
        dfs(root)
        perfect_sizes = sorted([size for size in perfect_sizes if size >= 1], reverse=True)
        
        if k > len(perfect_sizes):
            return -1
        return perfect_sizes[k-1]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'kthLargestPerfectSubtree', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 68.54518299326637, 'raw_metrics': {'loc': 26, 'lloc': 26, 'sloc': 26, 'comments': 2}}"
find-the-count-of-numbers-which-are-not-special,"```python
import math

class Solution:
    def nonSpecialCount(self, l: int, r: int) -> int:
        def is_prime(n):
            if n < 2:
                return False
            for p in [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]:
                if n % p == 0:
                    return n == p
            d = n - 1
            s = 0
            while d % 2 == 0:
                d //= 2
                s += 1
            for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:
                if a >= n:
                    continue
                x = pow(a, d, n)
                if x == 1 or x == n - 1:
                    continue
                for _ in range(s - 1):
                    x = pow(x, 2, n)
                    if x == n - 1:
                        break
                else:
                    return False
            return True

        def count_special_numbers(l, r):
            count = 0
            max_p = int(math.isqrt(r)) + 2
            primes = []
            for p in range(2, max_p + 1):
                if is_prime(p):
                    primes.append(p)
            for p in primes:
                square = p * p
                if l <= square <= r:
                    count += 1
            return count

        special = count_special_numbers(l, r)
        return (r - l + 1) - special
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 2}, {'name': 'nonSpecialCount', 'complexity': 1, 'lineno': 3}], 'maintainability_index': 46.256607535507335, 'raw_metrics': {'loc': 41, 'lloc': 41, 'sloc': 41, 'comments': 0}}"
maximum-number-of-operations-to-move-ones-to-the-end,"```python
class Solution:
    def maxOperations(self, s: str) -> int:
        res = 0
        ones = 0
        for c in s:
            if c == '1':
                ones += 1
            else:
                res += ones
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'maxOperations', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 67.82742192357686, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
count-submatrices-with-equal-frequency-of-x-and-y,"```python
class Solution:
    def numberOfSubmatrices(self, grid: List[List[str]]) -> int:
        rows = len(grid)
        cols = len(grid[0]) if rows > 0 else 0
        count = 0
        
        prefix_x = [[0] * (cols + 1) for _ in range(rows + 1)]
        prefix_y = [[0] * (cols + 1) for _ in range(rows + 1)]
        
        for i in range(1, rows + 1):
            for j in range(1, cols + 1):
                prefix_x[i][j] = prefix_x[i-1][j] + prefix_x[i][j-1] - prefix_x[i-1][j-1] + (1 if grid[i-1][j-1] == 'X' else 0)
                prefix_y[i][j] = prefix_y[i-1][j] + prefix_y[i][j-1] - prefix_y[i-1][j-1] + (1 if grid[i-1][j-1] == 'Y' else 0)
        
        for i1 in range(rows):
            for j1 in range(cols):
                for i2 in range(i1, rows):
                    for j2 in range(j1, cols):
                        x = prefix_x[i2+1][j2+1] - prefix_x[i1][j2+1] - prefix_x[i2+1][j1] + prefix_x[i1][j1]
                        y = prefix_y[i2+1][j2+1] - prefix_y[i1][j2+1] - prefix_y[i2+1][j1] + prefix_y[i1][j1]
                        if x == y and x > 0:
                            count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 15, 'lineno': 2}, {'name': 'numberOfSubmatrices', 'complexity': 14, 'lineno': 3}], 'maintainability_index': 48.81285253961337, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
find-the-maximum-length-of-valid-subsequence-ii,"```python
from typing import List

class Solution:
    def maximumLength(self, nums: List[int], k: int) -> int:
        n = len(nums)
        if n == 0:
            return 0
        
        dp = [1] * n
        max_len = 1
        
        for i in range(1, n):
            for j in range(i):
                if (nums[j] + nums[i]) % k == (nums[i-1] + nums[i]) % k if i > 1 else True:
                    if dp[j] + 1 > dp[i]:
                        dp[i] = dp[j] + 1
            if dp[i] > max_len:
                max_len = dp[i]
        
        return max_len
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 3}, {'name': 'maximumLength', 'complexity': 8, 'lineno': 4}], 'maintainability_index': 56.10152733753293, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
find-the-maximum-length-of-valid-subsequence-i,"```python
from typing import List

class Solution:
    def maximumLength(self, nums: List[int]) -> int:
        if len(nums) < 2:
            return len(nums)
        
        
        even_count = 0
        odd_count = 0
        
        for num in nums:
            if num % 2 == 0:
                even_count += 1
            else:
                odd_count += 1
        
        if even_count == 0 or odd_count == 0:
            return len(nums)
        
        return min(max(even_count, odd_count) * 2 - (1 if abs(even_count - odd_count) > 1 else 0), len(nums))
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'maximumLength', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 57.21383237742574, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
find-maximum-removals-from-source-string,"```python
from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        target_set = set(targetIndices)
        left = 0
        right = len(targetIndices)
        answer = 0
        
        while left <= right:
            mid = (left + right) // 2
            removed_indices = set(targetIndices[:mid])
            source_ptr = 0
            pattern_ptr = 0
            possible = True
            
            while pattern_ptr < len(pattern) and source_ptr < len(source):
                if source_ptr in removed_indices:
                    source_ptr += 1
                    continue
                if source[source_ptr] == pattern[pattern_ptr]:
                    pattern_ptr += 1
                source_ptr += 1
            
            if pattern_ptr == len(pattern):
                answer = mid
                left = mid + 1
            else:
                right = mid - 1
        
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'maxRemovals', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 51.35902859634473, 'raw_metrics': {'loc': 27, 'lloc': 28, 'sloc': 27, 'comments': 0}}"
maximize-total-cost-of-alternating-subarrays,"```python
from typing import List

class Solution:
    def maximumTotalCost(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 1:
            return nums[0]
        
        
        dp = [0] * n
        dp[0] = nums[0]
        
        for i in range(1, n):
            option1 = dp[i-1] + nums[i]
            option2 = (dp[i-2] if i >= 2 else 0) + nums[i-1] + nums[i]
            dp[i] = max(option1, option2)
        
        return dp[-1]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'maximumTotalCost', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 59.80475194646178, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
vowels-game-in-a-string,"```python
class Solution:
    def doesAliceWin(self, s: str) -> bool:
        vowels = {'a', 'e', 'i', 'o', 'u'}
        count = 0
        for c in s:
            if c in vowels:
                count += 1
        return count % 2 == 1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'doesAliceWin', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 68.5547933003363, 'raw_metrics': {'loc': 8, 'lloc': 8, 'sloc': 8, 'comments': 0}}"
find-the-maximum-length-of-a-good-subsequence-i,"```python
from typing import List

class Solution:
    def maximumLength(self, nums: List[int], k: int) -> int:
        n = len(nums)
        dp = [[0] * (k + 1) for _ in range(n)]
        same = [[0] * (k + 1) for _ in range(n)]
        diff = [[0] * (k + 1) for _ in range(n)]
        
        for i in range(n):
            dp[i][0] = 1
            same[i][0] = 1
            for j in range(k + 1):
                max_len = 1
                max_same = 1
                max_diff = 0
                for prev in range(i):
                    if nums[prev] == nums[i]:
                        current = same[prev][j] + 1
                        if current > max_same:
                            max_same = current
                    else:
                        if j > 0:
                            current = max(same[prev][j-1], diff[prev][j-1]) + 1
                            if current > max_diff:
                                max_diff = current
                same[i][j] = max_same
                if j > 0:
                    diff[i][j] = max_diff
                dp[i][j] = max(same[i][j], diff[i][j] if j > 0 else 0)
        
        max_result = 0
        for i in range(n):
            for j in range(k + 1):
                if dp[i][j] > max_result:
                    max_result = dp[i][j]
        return max_result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 17, 'lineno': 3}, {'name': 'maximumLength', 'complexity': 16, 'lineno': 4}], 'maintainability_index': 47.10586478993751, 'raw_metrics': {'loc': 35, 'lloc': 35, 'sloc': 35, 'comments': 0}}"
minimum-length-of-string-after-operations,"```python
class Solution:
    def minimumLength(self, s: str) -> int:
        left, right = 0, len(s) - 1
        while left < right and s[left] == s[right]:
            char = s[left]
            while left <= right and s[left] == char:
                left += 1
            while right >= left and s[right] == char:
                right -= 1
        return right - left + 1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 1}, {'name': 'minimumLength', 'complexity': 7, 'lineno': 2}], 'maintainability_index': 61.154316315009055, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
lexicographically-minimum-string-after-removing-stars,"```python
import heapq

class Solution:
    def clearStars(self, s: str) -> str:
        heap = []
        to_remove = set()
        for i, char in enumerate(s):
            if char == '*':
                if heap:
                    val, idx = heapq.heappop(heap)
                    to_remove.add(idx)
                    to_remove.add(i)
            else:
                heapq.heappush(heap, (char, i))
        result = []
        for i, char in enumerate(s):
            if i not in to_remove and char != '*':
                result.append(char)
        return ''.join(result)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 2}, {'name': 'clearStars', 'complexity': 7, 'lineno': 3}], 'maintainability_index': 60.334284819222525, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
count-the-number-of-special-characters-ii,"```python
class Solution:
    def numberOfSpecialChars(self, word: str) -> int:
        lowercase_first = {}
        uppercase_first = {}
        
        for i, c in enumerate(word):
            if c.islower():
                if c not in lowercase_first:
                    lowercase_first[c] = i
            else:
                lower_c = c.lower()
                if lower_c not in uppercase_first:
                    uppercase_first[lower_c] = i
        
        count = 0
        for c in lowercase_first:
            if c in uppercase_first:
                if lowercase_first[c] < uppercase_first[c]:
                    count += 1
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 1}, {'name': 'numberOfSpecialChars', 'complexity': 8, 'lineno': 2}], 'maintainability_index': 59.289489358962754, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
minimum-length-of-anagram-concatenation,"```python
import math
from collections import Counter

class Solution:
    def minAnagramLength(self, s: str) -> int:
        n = len(s)
        freq = Counter(s)
        k = len(freq)
        
        max_char_freq = max(freq.values())
        min_possible = max_char_freq
        
        for candidate in range(min_possible, n // 2 + 1):
            if n % candidate != 0:
                continue
            t_len = candidate
            valid = True
            for c in freq:
                if freq[c] % (n // t_len) != 0:
                    valid = False
                    break
            if valid:
                return t_len
        
        return n
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'minAnagramLength', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 56.81342830546598, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
minimum-array-end,"```python
class Solution:
    def minEnd(self, n: int, x: int) -> int:
        m = n - 1
        res = x
        mask = 1
        for _ in range(60):
            if (res & mask) == 0:
                if m >= 1:
                    res |= mask
                    m -= 1
                else:
                    break
            mask <<= 1
        mask = 1
        while m > 0:
            if (res & mask) == 0:
                res |= mask
                m -= 1
            mask <<= 1
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 1}, {'name': 'minEnd', 'complexity': 6, 'lineno': 2}], 'maintainability_index': 55.39319250185922, 'raw_metrics': {'loc': 20, 'lloc': 20, 'sloc': 20, 'comments': 0}}"
replace-question-marks-in-string-to-minimize-its-value,"```python
class Solution:
    def minimizeStringValue(self, s: str) -> str:
        s_list = list(s)
        freq = [0] * 26
        for c in s_list:
            if c != '?':
                freq[ord(c) - ord('a')] += 1
        
        question_indices = [i for i, c in enumerate(s_list) if c == '?']
        
        for idx in question_indices:
            min_freq = min(freq)
            candidates = [i for i in range(26) if freq[i] == min_freq]
            chosen_char = min(candidates)  # lex smallest
            s_list[idx] = chr(ord('a') + chosen_char)
            freq[chosen_char] += 1
        
        return ''.join(s_list)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 1}, {'name': 'minimizeStringValue', 'complexity': 8, 'lineno': 2}], 'maintainability_index': 74.0357021156727, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 1}}"
water-bottles-ii,"```python
class Solution:
    def maxBottlesDrunk(self, numBottles: int, numExchange: int) -> int:
        total = 0
        empty = 0
        current_numBottles = numBottles
        current_numExchange = numExchange
        
        while True:
            if current_numBottles > 0:
                total += current_numBottles
                empty += current_numBottles
                current_numBottles = 0
            elif empty >= current_numExchange:
                exchanged = empty // current_numExchange
                current_numBottles += exchanged
                empty -= exchanged * current_numExchange
                current_numExchange += 1
            else:
                break
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 1}, {'name': 'maxBottlesDrunk', 'complexity': 4, 'lineno': 2}], 'maintainability_index': 57.344839991002466, 'raw_metrics': {'loc': 19, 'lloc': 19, 'sloc': 19, 'comments': 0}}"
apply-operations-to-make-string-empty,"```python
class Solution:
    def lastNonEmptyString(self, s: str) -> str:
        last_occurrence = {}
        for idx, char in enumerate(s):
            last_occurrence[char] = idx
        
        max_last_occurrence = max(last_occurrence.values()) if last_occurrence else -1
        result = []
        for idx, char in enumerate(s):
            if last_occurrence[char] == idx and idx <= max_last_occurrence:
                result.append(char)
        return ''.join(result)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 1}, {'name': 'lastNonEmptyString', 'complexity': 6, 'lineno': 2}], 'maintainability_index': 65.39895044432797, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
find-the-maximum-number-of-elements-in-subset,"```python
from collections import defaultdict
from typing import List

class Solution:
    def maximumLength(self, nums: List[int]) -> int:
        freq = defaultdict(int)
        for num in nums:
            freq[num] += 1
        
        max_len = 1
        
        for num in sorted(freq.keys(), reverse=True):
            if num == 1:
                max_len = max(max_len, freq[num] if freq[num] % 2 == 1 else freq[num] - 1)
                continue
            
            current = num
            count = 0
            temp_freq = freq.copy()
            
            while True:
                sqrt = int(current ** 0.5)
                if sqrt * sqrt != current or sqrt not in temp_freq or temp_freq[sqrt] < 2:
                    break
                temp_freq[sqrt] -= 2
                count += 2
                current = sqrt
            
            if count > 0:
                if temp_freq.get(current, 0) >= 1:
                    count += 1
                    max_len = max(max_len, count)
                else:
                    max_len = max(max_len, count - 1)
        
        return max_len
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 4}, {'name': 'maximumLength', 'complexity': 11, 'lineno': 5}], 'maintainability_index': 49.254419845492606, 'raw_metrics': {'loc': 30, 'lloc': 30, 'sloc': 30, 'comments': 0}}"
find-if-array-can-be-sorted,"```python
class Solution:
    def canSortArray(self, nums: List[int]) -> bool:
        set_bits = [num.bit_count() for num in nums]
        
        groups = []
        current_group = []
        current_bit = set_bits[0]
        
        for num, bits in zip(nums, set_bits):
            if bits == current_bit:
                current_group.append(num)
            else:
                groups.append(current_group)
                current_group = [num]
                current_bit = bits
        groups.append(current_group)
        
        sorted_nums = sorted(nums)
        grouped_nums = []
        for group in groups:
            grouped_nums.extend(group)
        
        return grouped_nums == sorted_nums
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'canSortArray', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 62.80205775772738, 'raw_metrics': {'loc': 20, 'lloc': 20, 'sloc': 20, 'comments': 0}}"
minimum-moves-to-capture-the-queen,"```python
class Solution:
    def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:
        if a == e or b == f:
            blocked = False
            if a == e:
                step = 1 if d > b else -1
                for y in range(b + step, d, step):
                    if a == c and y == d:
                        blocked = True
                        break
                if not blocked:
                    step = 1 if f > b else -1
                    for y in range(b + step, f, step):
                        if a == c and y == d:
                            blocked = True
                            break
            else:  # b == f
                step = 1 if c > a else -1
                for x in range(a + step, c, step):
                    if x == c and b == d:
                        blocked = True
                        break
                if not blocked:
                    step = 1 if e > a else -1
                    for x in range(a + step, e, step):
                        if x == c and b == d:
                            blocked = True
                            break
            if not blocked:
                return 0
        
        if abs(c - e) == abs(d - f):
            blocked = False
            step_x = 1 if e > c else -1
            step_y = 1 if f > d else -1
            x, y = c + step_x, d + step_y
            while x != e and y != f:
                if x == a and y == b:
                    blocked = True
                    break
                x += step_x
                y += step_y
            if not blocked:
                return 0
        
        if (a == e or b == f) and not (a == e and b == f):
            blocked = False
            if a == e:
                step = 1 if f > b else -1
                for y in range(b + step, f, step):
                    if a == c and y == d:
                        blocked = True
                        break
            else:
                step = 1 if e > a else -1
                for x in range(a + step, e, step):
                    if x == c and b == d:
                        blocked = True
                        break
            if not blocked:
                return 1
        
        if abs(a - e) == abs(b - f):
            blocked = False
            step_x = 1 if e > a else -1
            step_y = 1 if f > b else -1
            x, y = a + step_x, b + step_y
            while x != e and y != f:
                if x == c and y == d:
                    blocked = True
                    break
                x += step_x
                y += step_y
            if not blocked:
                return 1
        
        if (a == c or b == d) and not (a == c and b == d):
            blocked = False
            if a == c:
                step = 1 if d > b else -1
                for y in range(b + step, d, step):
                    if a == e and y == f:
                        blocked = True
                        break
            else:
                step = 1 if c > a else -1
                for x in range(a + step, c, step):
                    if x == e and b == f:
                        blocked = True
                        break
            if not blocked:
                if abs(c - e) == abs(d - f):
                    blocked_bishop = False
                    step_x = 1 if e > c else -1
                    step_y = 1 if f > d else -1
                    x, y = c + step_x, d + step_y
                    while x != e and y != f:
                        if x == a and y == b:
                            blocked_bishop = True
                            break
                        x += step_x
                        y += step_y
                    if not blocked_bishop:
                        return 1
        
        if abs(c - a) == abs(d - b):
            blocked = False
            step_x = 1 if a > c else -1
            step_y = 1 if b > d else -1
            x, y = c + step_x, d + step_y
            while x != a and y != b:
                if x == e and y == f:
                    blocked = True
                    break
                x += step_x
                y += step_y
            if not blocked:
                if (a == e or b == f) and not (a == e and b == f):
                    blocked_rook = False
                    if a == e:
                        step = 1 if f > b else -1
                        for y in range(b + step, f, step):
                            if a == c and y == d:
                                blocked_rook = True
                                break
                    else:
                        step = 1 if e > a else -1
                        for x in range(a + step, e, step):
                            if x == c and b == d:
                                blocked_rook = True
                                break
                    if not blocked_rook:
                        return 1
        
        return 2
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 98, 'lineno': 1}, {'name': 'minMovesToCaptureTheQueen', 'complexity': 97, 'lineno': 2}], 'maintainability_index': 21.638926567232417, 'raw_metrics': {'loc': 129, 'lloc': 129, 'sloc': 129, 'comments': 1}}"
find-longest-special-substring-that-occurs-thrice-i,"```python
class Solution:
    def maximumLength(self, s: str) -> int:
        from collections import defaultdict

        char_substrings = defaultdict(list)
        n = len(s)
        
        for i in range(n):
            current_char = s[i]
            length = 1
            char_substrings[current_char].append(length)
            for j in range(i + 1, n):
                if s[j] == current_char:
                    length += 1
                    char_substrings[current_char].append(length)
                else:
                    break
        
        max_len = -1
        for char in char_substrings:
            lengths = char_substrings[char]
            if len(lengths) >= 3:
                lengths.sort(reverse=True)
                max_len = max(max_len, lengths[2])
        
        return max_len
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 1}, {'name': 'maximumLength', 'complexity': 6, 'lineno': 2}], 'maintainability_index': 57.97559752243749, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
maximum-points-after-enemy-battles,"```python
from typing import List

class Solution:
    def maximumPoints(self, enemyEnergies: List[int], currentEnergy: int) -> int:
        enemyEnergies_sorted = sorted(enemyEnergies)
        n = len(enemyEnergies)
        points = 0
        i = 0
        j = n - 1
        
        while i <= j:
            if currentEnergy >= enemyEnergies_sorted[i]:
                currentEnergy -= enemyEnergies_sorted[i]
                points += 1
                i += 1
            elif points > 0 and j > i:
                currentEnergy += enemyEnergies_sorted[j]
                points -= 1
                j -= 1
            else:
                break
        
        return points
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'maximumPoints', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 55.110741618079174, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
minimum-cost-to-make-array-equalindromic,"```python
class Solution:
    def minimumCost(self, nums: List[int]) -> int:
        def is_palindrome(x):
            s = str(x)
            return s == s[::-1]
        
        nums_sorted = sorted(nums)
        n = len(nums_sorted)
        median_candidates = []
        
        median = nums_sorted[n // 2]
        
        candidates = set()
        for x in [median, median + 1, median - 1]:
            if x > 0:
                candidates.add(x)
        
        for delta in range(-100, 101):
            x = median + delta
            if x > 0:
                candidates.add(x)
        
        palindromes = [x for x in candidates if is_palindrome(x)]
        
        if not palindromes:
            return 0
        
        min_cost = float('inf')
        for y in palindromes:
            total_cost = sum(abs(num - y) for num in nums_sorted)
            if total_cost < min_cost:
                min_cost = total_cost
        
        return min_cost
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 2}, {'name': 'minimumCost', 'complexity': 11, 'lineno': 3}], 'maintainability_index': 51.55437520186977, 'raw_metrics': {'loc': 27, 'lloc': 28, 'sloc': 27, 'comments': 0}}"
maximum-size-of-a-set-after-removals,"```python
from typing import List

class Solution:
    def maximumSetSize(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        k = n // 2
        set1 = set(nums1)
        set2 = set(nums2)
        common = set1 & set2
        only1 = set1 - set2
        only2 = set2 - set1
        
        max_common = min(len(common), k * 2 - len(only1) - len(only2))
        if max_common < 0:
            max_common = 0
        
        return min(len(only1) + len(only2) + max_common, 2 * k)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 3}, {'name': 'maximumSetSize', 'complexity': 2, 'lineno': 4}], 'maintainability_index': 58.857601750640995, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
count-subarrays-where-max-element-appears-at-least-k-times,"```python
from typing import List

class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        max_num = max(nums)
        max_indices = [i for i, num in enumerate(nums) if num == max_num]
        res = 0
        left = 0
        n = len(nums)
        
        for right in range(len(max_indices)):
            if right - left + 1 >= k:
                last_pos = max_indices[right]
                res += (max_indices[left] + 1) * (n - last_pos)
                left += 1
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'countSubarrays', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 59.064319654970355, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 0}}"
minimum-number-of-coins-for-fruits,"```python
from typing import List

class Solution:
    def minimumCoins(self, prices: List[int]) -> int:
        n = len(prices)
        dp = [float('inf')] * (n + 1)
        dp[n] = 0  # base case: no cost after last fruit
        
        for i in range(n - 1, -1, -1):
            max_free = i + 1  # i is 0-based, next i fruits means up to i+1 (0-based)
            min_cost = float('inf')
            for j in range(i + 1, min(i + 1 + i + 1, n + 1)):
                if dp[j] < min_cost:
                    min_cost = dp[j]
            dp[i] = prices[i] + min_cost
        
        return dp[0]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'minimumCoins', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 78.61976288695539, 'raw_metrics': {'loc': 15, 'lloc': 15, 'sloc': 15, 'comments': 2}}"
distribute-candies-among-children-ii,"```python
class Solution:
    def distributeCandies(self, n: int, limit: int) -> int:
        def count_ways(x):
            if x < 0:
                return 0
            return (x + 2) * (x + 1) // 2
        
        total = count_ways(n)
        a = count_ways(n - (limit + 1) * 3)
        b = count_ways(n - 2 * (limit + 1)) * 3
        c = count_ways(n - 3 * (limit + 1))
        return total - a + b - c
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 1}, {'name': 'distributeCandies', 'complexity': 1, 'lineno': 2}], 'maintainability_index': 60.04681236249092, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
separate-black-and-white-balls,"```python
class Solution:
    def minimumSteps(self, s: str) -> int:
        steps = 0
        black_pos = 0  # tracks the position where the next black ball should be placed
        
        for i, char in enumerate(s):
            if char == '1':
                steps += i - black_pos
                black_pos += 1
        
        return steps
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'minimumSteps', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 86.0667731565632, 'raw_metrics': {'loc': 9, 'lloc': 9, 'sloc': 9, 'comments': 1}}"
maximum-xor-product,"```python
class Solution:
    def maximumXorProduct(self, a: int, b: int, n: int) -> int:
        MOD = 10**9 + 7
        x = 0
        for k in range(n-1, -1, -1):
            mask = 1 << k
            a_bit = (a & mask) != 0
            b_bit = (b & mask) != 0
            if a_bit == b_bit:
                x |= mask
            else:
                current_a = a ^ x
                current_b = b ^ x
                if (current_a < current_b) == (a_bit < b_bit):
                    x |= mask
        return ((a ^ x) * (b ^ x)) % MOD
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 1}, {'name': 'maximumXorProduct', 'complexity': 4, 'lineno': 2}], 'maintainability_index': 55.39497136260706, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
maximum-score-after-applying-operations-on-a-tree,"```python
from typing import List

class Solution:
    def maximumScoreAfterOperations(self, edges: List[List[int]], values: List[int]) -> int:
        n = len(values)
        tree = [[] for _ in range(n)]
        for a, b in edges:
            tree[a].append(b)
            tree[b].append(a)
        
        parent = [-1] * n
        stack = [(0, False)]
        order = []
        
        while stack:
            node, visited = stack.pop()
            if visited:
                order.append(node)
                continue
            stack.append((node, True))
            for neighbor in tree[node]:
                if neighbor != parent[node]:
                    parent[neighbor] = node
                    stack.append((neighbor, False))
        
        dp_take = [0] * n  # max score if we take this node
        dp_notake = [0] * n  # max score if we don't take this node
        
        for node in order:
            if node != 0 and len(tree[node]) == 1:  # leaf node (except root)
                dp_take[node] = values[node]
                dp_notake[node] = 0
            else:
                sum_take_children = 0
                sum_notake_children = 0
                for child in tree[node]:
                    if child != parent[node]:
                        sum_take_children += dp_take[child]
                        sum_notake_children += dp_notake[child]
                dp_take[node] = values[node] + sum_take_children
                if node == 0:
                    dp_notake[node] = sum_notake_children
                else:
                    min_diff = float('inf')
                    total = 0
                    has_child = False
                    for child in tree[node]:
                        if child != parent[node]:
                            has_child = True
                            diff = dp_notake[child] - dp_take[child]
                            min_diff = min(min_diff, diff)
                            total += dp_take[child]
                    if has_child:
                        dp_notake[node] = total + min_diff
                    else:
                        dp_notake[node] = 0
        
        return max(dp_take[0], dp_notake[0])
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 17, 'lineno': 3}, {'name': 'maximumScoreAfterOperations', 'complexity': 16, 'lineno': 4}], 'maintainability_index': 57.147551477059096, 'raw_metrics': {'loc': 53, 'lloc': 53, 'sloc': 53, 'comments': 3}}"
find-indices-with-index-and-value-difference-ii,"```python
from typing import List

class Solution:
    def findIndices(self, nums: List[int], indexDifference: int, valueDifference: int) -> List[int]:
        n = len(nums)
        for i in range(n):
            for j in range(max(0, i - indexDifference), min(n, i + indexDifference + 1)):
                if abs(nums[i] - nums[j]) >= valueDifference and abs(i - j) >= indexDifference:
                    return [i, j]
        return [-1, -1]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'findIndices', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 62.96459118405373, 'raw_metrics': {'loc': 10, 'lloc': 10, 'sloc': 10, 'comments': 0}}"
minimum-size-subarray-in-infinite-array,"```python
from typing import List

class Solution:
    def minSizeSubarray(self, nums: List[int], target: int) -> int:
        total_sum = sum(nums)
        n = len(nums)
        min_len = float('inf')
        
        k = target // total_sum
        remaining = target % total_sum
        
        if remaining == 0:
            return k * n
        
        candidates = [remaining]
        if k > 0:
            candidates.append(remaining + total_sum)
        
        extended_nums = nums + nums
        prefix_sum = [0] * (2 * n + 1)
        for i in range(2 * n):
            prefix_sum[i+1] = prefix_sum[i] + extended_nums[i]
        
        from collections import defaultdict
        sum_indices = defaultdict(list)
        for idx, s in enumerate(prefix_sum):
            sum_indices[s].append(idx)
        
        for candidate in candidates:
            if candidate < 0:
                continue
            for i in range(1, 2 * n + 1):
                needed = prefix_sum[i] - candidate
                if needed in sum_indices:
                    for j in sum_indices[needed]:
                        if j < i and (i - j) <= 2 * n:
                            min_len = min(min_len, i - j)
        
        if min_len == float('inf'):
            return -1
        else:
            return k * n + min_len if (remaining + total_sum) in candidates and min_len == (remaining + total_sum) else min_len
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 16, 'lineno': 3}, {'name': 'minSizeSubarray', 'complexity': 15, 'lineno': 4}], 'maintainability_index': 45.04359571496789, 'raw_metrics': {'loc': 35, 'lloc': 35, 'sloc': 35, 'comments': 0}}"
happy-students,"```python
class Solution:
    def countWays(self, nums: List[int]) -> int:
        nums.sort()
        n = len(nums)
        res = 0
        
        if nums[0] > 0:
            res += 1
        
        for i in range(n):
            k = i + 1
            if k > nums[i]:
                if (i == n - 1) or (k < nums[i + 1]):
                    res += 1
        
        if n > nums[-1]:
            res += 1
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 2}, {'name': 'countWays', 'complexity': 7, 'lineno': 3}], 'maintainability_index': 57.14465862000933, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
apply-operations-to-make-two-strings-equal,"```python
class Solution:
    def minOperations(self, s1: str, s2: str, x: int) -> int:
        n = len(s1)
        diff_indices = [i for i in range(n) if s1[i] != s2[i]]
        m = len(diff_indices)
        if m % 2 != 0:
            return -1
        
        if m == 0:
            return 0
        
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        for i in range(1, m + 1):
            if i % 2 == 0:
                dp[i] = dp[i - 1]  # skip, handled by previous
            else:
                if i >= 1:
                    cost = diff_indices[i-1] - diff_indices[i-2]
                    dp[i] = min(dp[i], dp[i-2] + cost)
                dp[i] = min(dp[i], dp[i-1] + x / 2)  # x is total for pair, so x/2 per element
        
        return int(dp[m]) if dp[m] != float('inf') else -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 1}, {'name': 'minOperations', 'complexity': 9, 'lineno': 2}], 'maintainability_index': 70.6383233233265, 'raw_metrics': {'loc': 20, 'lloc': 20, 'sloc': 20, 'comments': 2}}"
construct-product-matrix,"```python
from typing import List

class Solution:
    def constructProductMatrix(self, grid: List[List[int]]) -> List[List[int]]:
        n = len(grid)
        m = len(grid[0]) if n > 0 else 0
        MOD = 12345
        
        total_product = 1
        zero_count = 0
        
        for row in grid:
            for num in row:
                if num == 0:
                    zero_count += 1
                else:
                    total_product = (total_product * num) % MOD
        
        result = [[0 for _ in range(m)] for _ in range(n)]
        
        for i in range(n):
            for j in range(m):
                if zero_count == 0:
                    val = grid[i][j]
                    if val != 0:
                        product = (total_product * pow(val, MOD - 2, MOD)) % MOD
                    else:
                        product = 0  # shouldn't happen as zero_count is 0
                elif zero_count == 1:
                    if grid[i][j] == 0:
                        product = total_product
                    else:
                        product = 0
                else:
                    product = 0
                result[i][j] = product
        
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 14, 'lineno': 3}, {'name': 'constructProductMatrix', 'complexity': 13, 'lineno': 4}], 'maintainability_index': 59.96351798548338, 'raw_metrics': {'loc': 33, 'lloc': 33, 'sloc': 33, 'comments': 1}}"
minimum-additions-to-make-valid-string,"```python
class Solution:
    def addMinimum(self, word: str) -> int:
        res = 0
        expected = 'a'
        for c in word:
            if c != expected:
                res += 1
                if expected == 'a':
                    if c == 'b':
                        expected = 'c'
                    else:
                        expected = 'b'
                elif expected == 'b':
                    if c == 'a':
                        res += 1
                        expected = 'b'
                    else:
                        expected = 'a'
                else:  # expected == 'c'
                    if c == 'a':
                        expected = 'b'
                    else:
                        res += 1
                        expected = 'a'
            if expected == 'a':
                expected = 'b'
            elif expected == 'b':
                expected = 'c'
            else:
                expected = 'a'
        if expected != 'a':
            res += 4 - (ord(expected) - ord('a')) - 1
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 1}, {'name': 'addMinimum', 'complexity': 11, 'lineno': 2}], 'maintainability_index': 59.59309165469373, 'raw_metrics': {'loc': 33, 'lloc': 33, 'sloc': 33, 'comments': 1}}"
count-the-number-of-square-free-subsets,"```python
class Solution:
    def squareFreeSubsets(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
        square_free_masks = {}
        
        for num in range(1, 31):
            mask = 0
            tmp = num
            is_square_free = True
            for i, p in enumerate(primes):
                if tmp % (p * p) == 0:
                    is_square_free = False
                    break
                if tmp % p == 0:
                    mask |= (1 << i)
            if is_square_free:
                square_free_masks[num] = mask
        
        freq = [0] * 31
        for num in nums:
            if num in square_free_masks:
                freq[num] += 1
        
        dp = [0] * (1 << 10)
        dp[0] = 1
        
        for num in range(1, 31):
            if freq[num] == 0:
                continue
            mask = square_free_masks[num]
            for m in range((1 << 10) - 1, -1, -1):
                if (m & mask) == 0:
                    new_mask = m | mask
                    dp[new_mask] = (dp[new_mask] + dp[m] * freq[num]) % MOD
        
        total = (sum(dp) - 1) % MOD
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 13, 'lineno': 2}, {'name': 'squareFreeSubsets', 'complexity': 12, 'lineno': 3}], 'maintainability_index': 46.39511012012571, 'raw_metrics': {'loc': 34, 'lloc': 34, 'sloc': 34, 'comments': 0}}"
minimum-cost-of-a-path-with-special-roads,"```python
import heapq
from typing import List

class Solution:
    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:
        start_x, start_y = start
        target_x, target_y = target
        
        min_cost = abs(target_x - start_x) + abs(target_y - start_y)
        
        heap = []
        heapq.heappush(heap, (0, start_x, start_y))
        
        visited = {}
        visited[(start_x, start_y)] = 0
        
        while heap:
            current_cost, x, y = heapq.heappop(heap)
            
            if x == target_x and y == target_y:
                return current_cost
            
            if current_cost > visited.get((x, y), float('inf')):
                continue
            
            direct_cost = current_cost + abs(target_x - x) + abs(target_y - y)
            if direct_cost < min_cost:
                min_cost = direct_cost
            
            for road in specialRoads:
                x1, y1, x2, y2, cost = road
                cost_to_start = current_cost + abs(x1 - x) + abs(y1 - y)
                total_cost = cost_to_start + cost
                if total_cost < visited.get((x2, y2), float('inf')):
                    visited[(x2, y2)] = total_cost
                    heapq.heappush(heap, (total_cost, x2, y2))
        
        return min_cost
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 4}, {'name': 'minimumCost', 'complexity': 8, 'lineno': 5}], 'maintainability_index': 49.86433530258923, 'raw_metrics': {'loc': 29, 'lloc': 29, 'sloc': 29, 'comments': 0}}"
take-k-of-each-character-from-left-and-right,"```python
class Solution:
    def takeCharacters(self, s: str, k: int) -> int:
        if k == 0:
            return 0
        
        n = len(s)
        count = {'a': 0, 'b': 0, 'c': 0}
        for c in s:
            count[c] += 1
        
        if any(count[char] < k for char in 'abc'):
            return -1
        
        left_counts = {'a': 0, 'b': 0, 'c': 0}
        right_counts = {'a': 0, 'b': 0, 'c': 0}
        left = 0
        right = n - 1
        min_time = float('inf')
        
        for left in range(n + 1):
            if left > 0:
                left_counts[s[left - 1]] += 1
            current_right_counts = {'a': 0, 'b': 0, 'c': 0}
            temp_right = n - 1
            found = False
            for take_right in range(n - left + 1):
                if take_right > 0:
                    current_right_counts[s[temp_right]] += 1
                    temp_right -= 1
                total_a = left_counts['a'] + current_right_counts['a']
                total_b = left_counts['b'] + current_right_counts['b']
                total_c = left_counts['c'] + current_right_counts['c']
                if total_a >= k and total_b >= k and total_c >= k:
                    total_time = left + take_right
                    if total_time < min_time:
                        min_time = total_time
                    found = True
                    break
            if found:
                break
        
        right_counts = {'a': 0, 'b': 0, 'c': 0}
        for right_taken in range(n + 1):
            if right_taken > 0:
                right_counts[s[n - right_taken]] += 1
            current_left_counts = {'a': 0, 'b': 0, 'c': 0}
            temp_left = 0
            found = False
            for take_left in range(n - right_taken + 1):
                if take_left > 0:
                    current_left_counts[s[temp_left]] += 1
                    temp_left += 1
                total_a = current_left_counts['a'] + right_counts['a']
                total_b = current_left_counts['b'] + right_counts['b']
                total_c = current_left_counts['c'] + right_counts['c']
                if total_a >= k and total_b >= k and total_c >= k:
                    total_time = take_left + right_taken
                    if total_time < min_time:
                        min_time = total_time
                    found = True
                    break
            if found:
                break
        
        return min_time if min_time != float('inf') else -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 25, 'lineno': 1}, {'name': 'takeCharacters', 'complexity': 24, 'lineno': 2}], 'maintainability_index': 36.96441461641307, 'raw_metrics': {'loc': 59, 'lloc': 65, 'sloc': 59, 'comments': 0}}"
most-profitable-path-in-a-tree,"```python
from typing import List
from collections import deque

class Solution:
    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:
        n = len(edges) + 1
        graph = [[] for _ in range(n)]
        for a, b in edges:
            graph[a].append(b)
            graph[b].append(a)
        
        parent = [ -1 ] * n
        q = deque([0])
        while q:
            u = q.popleft()
            for v in graph[u]:
                if parent[v] == -1 and v != 0:
                    parent[v] = u
                    q.append(v)
        
        bob_path = []
        u = bob
        while u != -1:
            bob_path.append(u)
            u = parent[u]
        bob_path.reverse()
        
        bob_time = {}
        for t, node in enumerate(bob_path):
            bob_time[node] = t
        
        max_profit = -float('inf')
        q = deque()
        q.append((0, 0, 0))  # (node, time, current_profit)
        visited = [False] * n
        visited[0] = True
        
        while q:
            node, time, profit = q.popleft()
            
            if node in bob_time:
                if time < bob_time[node]:
                    current_amount = amount[node]
                elif time == bob_time[node]:
                    current_amount = amount[node] // 2
                else:
                    current_amount = 0
            else:
                current_amount = amount[node]
            
            new_profit = profit + current_amount
            
            is_leaf = True
            for neighbor in graph[node]:
                if not visited[neighbor]:
                    is_leaf = False
                    break
            
            if is_leaf and node != 0:
                max_profit = max(max_profit, new_profit)
            else:
                for neighbor in graph[node]:
                    if not visited[neighbor]:
                        visited[neighbor] = True
                        q.append((neighbor, time + 1, new_profit))
        
        return max_profit
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 20, 'lineno': 4}, {'name': 'mostProfitablePath', 'complexity': 19, 'lineno': 5}], 'maintainability_index': 49.61829291179495, 'raw_metrics': {'loc': 57, 'lloc': 57, 'sloc': 57, 'comments': 1}}"
longest-special-path-ii,"```python
from collections import defaultdict
from typing import List

class Solution:
    def longestSpecialPath(self, edges: List[List[int]], nums: List[int]) -> List[int]:
        tree = defaultdict(list)
        for u, v, length in edges:
            tree[u].append((v, length))
            tree[v].append((u, length))
        
        root = 0
        parent = {root: -1}
        children = defaultdict(list)
        stack = [root]
        while stack:
            node = stack.pop()
            for neighbor, length in tree[node]:
                if neighbor != parent[node]:
                    parent[neighbor] = node
                    children[node].append((neighbor, length))
                    stack.append(neighbor)
        
        max_length = 0
        min_nodes = float('inf')
        
        
        def dfs(node):
            nonlocal max_length, min_nodes
            paths = []
            current_val = nums[node]
            single_path = {current_val: (0, 1)}  # length, node count
            double_paths = {}  # key: duplicated value, value: (length, node count)
            
            for child, length in children[node]:
                child_single, child_double = dfs(child)
                for val in child_single:
                    child_len, child_nodes = child_single[val]
                    new_len = child_len + length
                    new_nodes = child_nodes + 1
                    if val == current_val:
                        if current_val in double_paths:
                            existing_len, existing_nodes = double_paths[current_val]
                            if new_len > existing_len or (new_len == existing_len and new_nodes < existing_nodes):
                                double_paths[current_val] = (new_len, new_nodes)
                        else:
                            double_paths[current_val] = (new_len, new_nodes)
                    else:
                        if val in single_path:
                            existing_len, existing_nodes = single_path[val]
                            if new_len > existing_len or (new_len == existing_len and new_nodes < existing_nodes):
                                single_path[val] = (new_len, new_nodes)
                        else:
                            single_path[val] = (new_len, new_nodes)
                
                for val in child_double:
                    child_len, child_nodes = child_double[val]
                    new_len = child_len + length
                    new_nodes = child_nodes + 1
                    if val in double_paths:
                        existing_len, existing_nodes = double_paths[val]
                        if new_len > existing_len or (new_len == existing_len and new_nodes < existing_nodes):
                            double_paths[val] = (new_len, new_nodes)
                    else:
                        double_paths[val] = (new_len, new_nodes)
            
            single_path[current_val] = max(single_path.get(current_val, (0, 1)), (0, 1))
            
            for val in single_path:
                length, nodes = single_path[val]
                if length > max_length:
                    max_length = length
                    min_nodes = nodes
                elif length == max_length:
                    if nodes < min_nodes:
                        min_nodes = nodes
            
            for val in double_paths:
                length, nodes = double_paths[val]
                if length > max_length:
                    max_length = length
                    min_nodes = nodes
                elif length == max_length:
                    if nodes < min_nodes:
                        min_nodes = nodes
            
            return (single_path, double_paths)
        
        dfs(root)
        return [max_length, min_nodes]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 4}, {'name': 'longestSpecialPath', 'complexity': 5, 'lineno': 5}], 'maintainability_index': 48.39024274394336, 'raw_metrics': {'loc': 78, 'lloc': 80, 'sloc': 78, 'comments': 2}}"
maximize-subarrays-after-removing-one-conflicting-pair,"```python
from typing import List

class Solution:
    def maxSubarrays(self, n: int, conflictingPairs: List[List[int]]) -> int:
        if not conflictingPairs:
            return n * (n + 1) // 2
        
        max_subarrays = 0
        
        for i in range(len(conflictingPairs)):
            temp_pairs = conflictingPairs[:i] + conflictingPairs[i+1:]
            conflict_dict = {}
            for a, b in temp_pairs:
                if a not in conflict_dict:
                    conflict_dict[a] = set()
                if b not in conflict_dict:
                    conflict_dict[b] = set()
                conflict_dict[a].add(b)
                conflict_dict[b].add(a)
            
            total = n * (n + 1) // 2
            invalid = 0
            left = 0
            for right in range(1, n + 1):
                current = right
                if current in conflict_dict:
                    for neighbor in conflict_dict[current]:
                        while left < right and neighbor in range(left + 1, right + 1):
                            left += 1
                invalid += right - left
            
            current_subarrays = total - invalid
            if current_subarrays > max_subarrays:
                max_subarrays = current_subarrays
        
        return max_subarrays
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 13, 'lineno': 3}, {'name': 'maxSubarrays', 'complexity': 12, 'lineno': 4}], 'maintainability_index': 47.591096936679804, 'raw_metrics': {'loc': 31, 'lloc': 32, 'sloc': 31, 'comments': 0}}"
maximize-the-distance-between-points-on-a-square,"```python
from typing import List

class Solution:
    def maxDistance(self, side: int, points: List[List[int]], k: int) -> int:
        def manhattan(p1, p2):
            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])
        
        points.sort()
        left, right = 0, 2 * side
        best = 0
        
        def is_possible(mid):
            count = 1
            last = points[0]
            for point in points[1:]:
                if manhattan(last, point) >= mid:
                    count += 1
                    last = point
                    if count >= k:
                        return True
            return count >= k
        
        while left <= right:
            mid = (left + right) // 2
            if is_possible(mid):
                best = mid
                left = mid + 1
            else:
                right = mid - 1
        return best
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'maxDistance', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 52.4669334447468, 'raw_metrics': {'loc': 27, 'lloc': 27, 'sloc': 27, 'comments': 0}}"
lexicographically-smallest-generated-string,"```python
class Solution:
    def generateString(self, str1: str, str2: str) -> str:
        n = len(str1)
        m = len(str2)
        if n == 0 or m == 0:
            return """"
        
        total_length = n + m - 1
        result = ['a'] * total_length
        
        for i in range(n):
            if str1[i] == 'T':
                if i + m > total_length:
                    return """"
                for k in range(m):
                    if result[i + k] == 'a' or result[i + k] == str2[k]:
                        result[i + k] = str2[k]
                    else:
                        return """"
        
        for i in range(n):
            if str1[i] == 'F':
                if i + m > total_length:
                    continue  # out of bounds, no need to check
                match = True
                for k in range(m):
                    if i + k >= total_length:
                        match = False
                        break
                    if result[i + k] != 'a' and result[i + k] != str2[k]:
                        match = False
                        break
                if match:
                    found = False
                    for k in range(m):
                        if i + k >= total_length:
                            break
                        if result[i + k] == 'a':
                            for c in 'abcdefghijklmnopqrstuvwxyz':
                                if c != str2[k]:
                                    result[i + k] = c
                                    found = True
                                    break
                            if found:
                                break
                    if not found:
                        return """"
        
        for i in range(n):
            if i + m > total_length:
                continue
            substring = ''.join(result[i:i+m])
            if str1[i] == 'T':
                if substring != str2:
                    return """"
            else:
                if substring == str2:
                    return """"
        
        return ''.join(result)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 30, 'lineno': 1}, {'name': 'generateString', 'complexity': 29, 'lineno': 2}], 'maintainability_index': 46.287358733558236, 'raw_metrics': {'loc': 55, 'lloc': 56, 'sloc': 55, 'comments': 1}}"
maximize-the-minimum-game-score,"```python
class Solution:
    def maxScore(self, points: List[int], m: int) -> int:
        left, right = 1, sum(points)
        n = len(points)
        
        def is_possible(min_val):
            total_moves = 0
            current_sum = 0
            for num in points:
                current_sum += num
                if current_sum >= min_val:
                    total_moves += 1
                    current_sum = 0
                    if total_moves >= m:
                        return True
            return False
        
        result = 0
        while left <= right:
            mid = (left + right) // 2
            if is_possible(mid):
                result = mid
                left = mid + 1
            else:
                right = mid - 1
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'maxScore', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 54.663539659683714, 'raw_metrics': {'loc': 25, 'lloc': 25, 'sloc': 25, 'comments': 0}}"
minimum-operations-to-make-array-elements-zero,"```python
import math
from typing import List

class Solution:
    def minOperations(self, queries: List[List[int]]) -> int:
        total_operations = 0
        
        for l, r in queries:
            max_num = r
            operations = 0
            while max_num > 0:
                operations += 1
                max_num = max_num // 4
            total_operations += operations
        
        return total_operations
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 4}, {'name': 'minOperations', 'complexity': 3, 'lineno': 5}], 'maintainability_index': 63.395599679410545, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
length-of-longest-v-shaped-diagonal-segment,"```python
from typing import List

class Solution:
    def lenOfVDiagonal(self, grid: List[List[int]]) -> int:
        if not grid or not grid[0]:
            return 0
        
        n, m = len(grid), len(grid[0])
        max_len = 0
        
        directions = [(-1, -1), (-1, 1), (1, -1), (1, 1)]
        
        for i in range(n):
            for j in range(m):
                if grid[i][j] == 1:
                    for di, dj in directions:
                        length = 1
                        ni, nj = i + di, j + dj
                        step = 0  # 0 means next should be 2, 1 means next should be 0
                        while 0 <= ni < n and 0 <= nj < m:
                            expected = 2 if step % 2 == 0 else 0
                            if grid[ni][nj] != expected:
                                break
                            length += 1
                            step += 1
                            ni += di
                            nj += dj
                        
                        if length >= 2:
                            new_di, new_dj = dj, di
                            ni_turn, nj_turn = ni - di + new_di, nj - dj + new_dj
                            step_turn = step
                            temp_len = length
                            
                            while 0 <= ni_turn < n and 0 <= nj_turn < m:
                                expected = 2 if step_turn % 2 == 0 else 0
                                if grid[ni_turn][nj_turn] != expected:
                                    break
                                temp_len += 1
                                step_turn += 1
                                ni_turn += new_di
                                nj_turn += new_dj
                            
                            if temp_len > max_len:
                                max_len = temp_len
                        
                        if length > max_len:
                            max_len = length
        
        return max_len if max_len != 0 else 1 if any(grid[i][j] == 1 for i in range(n) for j in range(m)) else 0
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 23, 'lineno': 3}, {'name': 'lenOfVDiagonal', 'complexity': 22, 'lineno': 4}], 'maintainability_index': 50.891701039207184, 'raw_metrics': {'loc': 42, 'lloc': 42, 'sloc': 42, 'comments': 1}}"
smallest-substring-with-identical-characters-ii,"```python
class Solution:
    def minLength(self, s: str, numOps: int) -> int:
        if not s:
            return 0
        
        def get_min_run(ch):
            runs = []
            current_run = 0
            for c in s:
                if c == ch:
                    current_run += 1
                else:
                    if current_run > 0:
                        runs.append(current_run)
                    current_run = 0
            if current_run > 0:
                runs.append(current_run)
            if not runs:
                return 0
            runs.sort()
            total_ops = numOps
            i = 0
            n = len(runs)
            while i < n - 1 and total_ops > 0:
                diff = runs[i+1] - runs[i]
                ops_needed = (i + 1) * diff
                if ops_needed <= total_ops:
                    total_ops -= ops_needed
                    for j in range(i + 1):
                        runs[j] += diff
                else:
                    add = total_ops // (i + 1)
                    remaining = total_ops % (i + 1)
                    for j in range(i + 1):
                        runs[j] += add
                    for j in range(remaining):
                        runs[j] += 1
                    total_ops = 0
                i += 1
            if total_ops > 0:
                add = total_ops // n
                remaining = total_ops % n
                for j in range(n):
                    runs[j] += add
                for j in range(remaining):
                    runs[j] += 1
            return max(runs) if runs else 0
        
        min_0 = get_min_run('0')
        min_1 = get_min_run('1')
        return min(min_0, min_1)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 1}, {'name': 'minLength', 'complexity': 2, 'lineno': 2}], 'maintainability_index': 43.99039304124742, 'raw_metrics': {'loc': 49, 'lloc': 49, 'sloc': 49, 'comments': 0}}"
minimum-cost-good-caption,"```python
class Solution:
    def minCostGoodCaption(self, caption: str) -> str:
        if not caption:
            return """"
        
        n = len(caption)
        if n < 3:
            return """"
        
        runs = []
        current_char = caption[0]
        count = 1
        for c in caption[1:]:
            if c == current_char:
                count += 1
            else:
                runs.append((current_char, count))
                current_char = c
                count = 1
        runs.append((current_char, count))
        
        
        
        all_good = True
        for c, cnt in runs:
            if cnt < 3:
                all_good = False
                break
        if all_good:
            return caption
        
        possible_chars = set()
        for i in range(len(runs)):
            c, cnt = runs[i]
            possible_chars.add(c)
            if c != 'a':
                possible_chars.add(chr(ord(c) - 1))
            if c != 'z':
                possible_chars.add(chr(ord(c) + 1))
        
        min_cost = float('inf')
        best_candidate = None
        
        for target in sorted(possible_chars):
            total_cost = 0
            possible = True
            
            
            
            current_seg_len = 0
            current_seg_cost = 0
            total_segments = 0
            total_seg_cost = 0
            valid = True
            
            for c, cnt in runs:
                cost = 0
                for orig_c in c:
                    if orig_c == target:
                        cost_add = 0
                    else:
                        if target > orig_c:
                            cost_add = ord(target) - ord(orig_c)
                        else:
                            cost_add = ord(orig_c) - ord(target)
                    cost += cost_add
                
                if current_seg_len == 0:
                    current_seg_len = cnt
                    current_seg_cost = cost
                else:
                    current_seg_len += cnt
                    current_seg_cost += cost
                
                if current_seg_len >=3:
                    total_segments += 1
                    total_seg_cost += current_seg_cost
                    current_seg_len = 0
                    current_seg_cost = 0
            
            if current_seg_len > 0:
                valid = False
            
            if valid and total_seg_cost < min_cost:
                min_cost = total_seg_cost
                best_candidate = target * n
            elif valid and total_seg_cost == min_cost:
                candidate = target * n
                if candidate < best_candidate:
                    best_candidate = candidate
        
        if best_candidate is not None:
            return best_candidate
        
        if n >=3:
            min_full_cost = float('inf')
            best_full_candidate = None
            for target in sorted(set(caption)):
                total_cost = 0
                for c in caption:
                    total_cost += abs(ord(c) - ord(target))
                if total_cost < min_full_cost:
                    min_full_cost = total_cost
                    best_full_candidate = target * n
                elif total_cost == min_full_cost:
                    candidate = target * n
                    if candidate < best_full_candidate:
                        best_full_candidate = candidate
            if best_full_candidate is not None:
                return best_full_candidate
        
        return """"
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 33, 'lineno': 1}, {'name': 'minCostGoodCaption', 'complexity': 32, 'lineno': 2}], 'maintainability_index': 32.99850527056706, 'raw_metrics': {'loc': 93, 'lloc': 93, 'sloc': 93, 'comments': 0}}"
minimum-increments-for-target-multiples-in-an-array,"```python
from typing import List

class Solution:
    def minimumIncrements(self, nums: List[int], target: List[int]) -> int:
        nums.sort()
        target.sort()
        res = 0
        used = [False] * len(nums)
        
        for t in target:
            min_ops = float('inf')
            best_idx = -1
            for i in range(len(nums)):
                if not used[i]:
                    if nums[i] >= t:
                        ops = 0
                        if ops < min_ops:
                            min_ops = ops
                            best_idx = i
                        break
                    else:
                        remainder = t % nums[i]
                        if remainder == 0:
                            ops = 0
                            if ops < min_ops:
                                min_ops = ops
                                best_idx = i
                                break
                        else:
                            ops = nums[i] - remainder
                            if ops < min_ops:
                                min_ops = ops
                                best_idx = i
            if best_idx != -1:
                res += min_ops
                nums[best_idx] += min_ops
                used[best_idx] = True
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 3}, {'name': 'minimumIncrements', 'complexity': 10, 'lineno': 4}], 'maintainability_index': 48.46479399769331, 'raw_metrics': {'loc': 37, 'lloc': 37, 'sloc': 37, 'comments': 0}}"
shortest-matching-substring,"```python
class Solution:
    def shortestMatchingSubstring(self, s: str, p: str) -> int:
        star_indices = [i for i, ch in enumerate(p) if ch == '*']
        if len(star_indices) != 2:
            return -1
        
        prefix = p[:star_indices[0]]
        middle = p[star_indices[0]+1:star_indices[1]]
        suffix = p[star_indices[1]+1:]
        
        min_len = float('inf')
        
        prefix_matches = []
        n = len(s)
        m_prefix = len(prefix)
        if m_prefix == 0:
            prefix_matches = list(range(n+1))
        else:
            for i in range(n - m_prefix + 1):
                if s[i:i+m_prefix] == prefix:
                    prefix_matches.append(i + m_prefix)
        
        suffix_matches = []
        m_suffix = len(suffix)
        if m_suffix == 0:
            suffix_matches = list(range(n+1))
        else:
            for j in range(m_suffix, n+1):
                if s[j-m_suffix:j] == suffix:
                    suffix_matches.append(j - m_suffix)
        
        m_middle = len(middle)
        if m_middle == 0:
            for start in prefix_matches:
                for end in suffix_matches:
                    if end >= start:
                        current_len = end - start
                        if current_len < min_len:
                            min_len = current_len
        else:
            middle_indices = []
            for i in range(n - m_middle + 1):
                if s[i:i+m_middle] == middle:
                    middle_indices.append(i)
            
            for prefix_end in prefix_matches:
                left = 0
                right = len(middle_indices)
                low, high = 0, len(middle_indices) - 1
                first_middle = -1
                while low <= high:
                    mid = (low + high) // 2
                    if middle_indices[mid] >= prefix_end:
                        first_middle = mid
                        high = mid - 1
                    else:
                        low = mid + 1
                if first_middle == -1:
                    continue
                middle_start = middle_indices[first_middle]
                middle_end = middle_start + m_middle
                
                low_suffix, high_suffix = 0, len(suffix_matches) - 1
                first_suffix = -1
                while low_suffix <= high_suffix:
                    mid_suffix = (low_suffix + high_suffix) // 2
                    if suffix_matches[mid_suffix] >= middle_end:
                        first_suffix = mid_suffix
                        high_suffix = mid_suffix - 1
                    else:
                        low_suffix = mid_suffix + 1
                if first_suffix == -1:
                    continue
                suffix_start = suffix_matches[first_suffix]
                current_len = suffix_start - prefix_end
                if current_len < min_len:
                    min_len = current_len
        
        if min_len != float('inf'):
            return min_len
        else:
            return -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 27, 'lineno': 1}, {'name': 'shortestMatchingSubstring', 'complexity': 26, 'lineno': 2}], 'maintainability_index': 34.69160915368516, 'raw_metrics': {'loc': 74, 'lloc': 77, 'sloc': 74, 'comments': 0}}"
smallest-substring-with-identical-characters-i,"```python
class Solution:
    def minLength(self, s: str, numOps: int) -> int:
        n = len(s)
        if n == 0:
            return 0
        
        def get_min_segment(target):
            segments = []
            current = 0
            for c in s:
                if c == target:
                    current += 1
                else:
                    if current > 0:
                        segments.append(current)
                    current = 0
            if current > 0:
                segments.append(current)
            if not segments:
                return 0
            segments.sort()
            ops = numOps
            i = len(segments) - 1
            while ops > 0 and i >= 0:
                max_seg = segments[i]
                if i == 0:
                    reduce = min(ops, max_seg)
                    segments[i] -= reduce
                    ops -= reduce
                else:
                    next_seg = segments[i-1]
                    diff = max_seg - next_seg
                    reduce = min(ops, diff)
                    segments[i] -= reduce
                    ops -= reduce
                i -= 1
            segments.sort()
            return segments[-1] if segments else 0
        
        res0 = get_min_segment('0')
        res1 = get_min_segment('1')
        
        return min(res0, res1) if numOps > 0 else max(res0, res1)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'minLength', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 47.425818360705975, 'raw_metrics': {'loc': 40, 'lloc': 40, 'sloc': 40, 'comments': 0}}"
longest-special-path,"```python
from typing import List
from collections import defaultdict

class Solution:
    def longestSpecialPath(self, edges: List[List[int]], nums: List[int]) -> List[int]:
        n = len(nums)
        tree = defaultdict(list)
        for u, v, length in edges:
            tree[u].append((v, length))
            tree[v].append((u, length))
        
        max_length = 0
        min_nodes = float('inf')
        
        stack = [(0, -1, 0, set())]  # (node, parent, current_length, current_values)
        
        while stack:
            node, parent, current_length, current_values = stack.pop()
            if nums[node] in current_values:
                if current_length > max_length:
                    max_length = current_length
                    min_nodes = len(current_values)
                elif current_length == max_length:
                    if len(current_values) < min_nodes:
                        min_nodes = len(current_values)
                continue
            
            new_values = set(current_values)
            new_values.add(nums[node])
            
            is_leaf = True
            for neighbor, length in tree[node]:
                if neighbor != parent:
                    is_leaf = False
                    stack.append((neighbor, node, current_length + length, new_values))
            
            if is_leaf:
                path_length = current_length
                num_nodes = len(new_values)
                if path_length > max_length:
                    max_length = path_length
                    min_nodes = num_nodes
                elif path_length == max_length:
                    if num_nodes < min_nodes:
                        min_nodes = num_nodes
        
        return [max_length, min_nodes] if max_length != 0 else [0, 1]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 15, 'lineno': 4}, {'name': 'longestSpecialPath', 'complexity': 14, 'lineno': 5}], 'maintainability_index': 57.45427644884741, 'raw_metrics': {'loc': 40, 'lloc': 40, 'sloc': 40, 'comments': 1}}"
count-connected-components-in-lcm-graph,"```python
import math
from typing import List
from collections import defaultdict

class Solution:
    def countComponents(self, nums: List[int], threshold: int) -> int:
        parent = {}
        size = defaultdict(int)
        
        def find(u):
            while parent[u] != u:
                parent[u] = parent[parent[u]]
                u = parent[u]
            return u
        
        def union(u, v):
            u_root = find(u)
            v_root = find(v)
            if u_root == v_root:
                return
            if size[u_root] < size[v_root]:
                u_root, v_root = v_root, u_root
            parent[v_root] = u_root
            size[u_root] += size[v_root]
        
        num_set = set(nums)
        nums_sorted = sorted(num_set)
        for num in nums_sorted:
            parent[num] = num
            size[num] = 1
        
        for num in nums_sorted:
            if num > threshold:
                continue
            max_factor = math.isqrt(num) + 1
            for factor in range(1, max_factor):
                if num % factor == 0:
                    for neighbor in (factor, num // factor):
                        if neighbor != num and neighbor in num_set:
                            lcm = (num * neighbor) // math.gcd(num, neighbor)
                            if lcm <= threshold:
                                union(num, neighbor)
        
        roots = set()
        for num in nums:
            roots.add(find(num))
        return len(roots)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 5}, {'name': 'countComponents', 'complexity': 11, 'lineno': 6}], 'maintainability_index': 46.479569573173, 'raw_metrics': {'loc': 42, 'lloc': 42, 'sloc': 42, 'comments': 0}}"
maximize-sum-of-weights-after-edge-removals,"```python
from collections import defaultdict

class Solution:
    def maximizeSumOfWeights(self, edges: List[List[int]], k: int) -> int:
        adjacency = defaultdict(list)
        for u, v, w in edges:
            adjacency[u].append((v, w))
            adjacency[v].append((u, w))
        
        degrees = defaultdict(int)
        for u, v, _ in edges:
            degrees[u] += 1
            degrees[v] += 1
        
        heap = []
        for u in degrees:
            heap.append((-degrees[u], u))
        
        import heapq
        heapq.heapify(heap)
        
        edge_removed = set()
        total = sum(w for _, _, w in edges)
        removed_sum = 0
        
        while heap:
            neg_degree, u = heapq.heappop(heap)
            current_degree = -neg_degree
            if current_degree <= k:
                continue
            
            min_w = float('inf')
            min_edge = None
            for v, w in adjacency[u]:
                edge_key = tuple(sorted((u, v)))
                if edge_key not in edge_removed:
                    if w < min_w:
                        min_w = w
                        min_edge = edge_key
            
            if min_edge is not None:
                edge_removed.add(min_edge)
                removed_sum += min_w
                a, b = min_edge
                degrees[a] -= 1
                degrees[b] -= 1
                if degrees[a] > k:
                    heapq.heappush(heap, (-degrees[a], a))
                if degrees[b] > k:
                    heapq.heappush(heap, (-degrees[b], b))
        
        return total - removed_sum
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 14, 'lineno': 3}, {'name': 'maximizeSumOfWeights', 'complexity': 13, 'lineno': 4}], 'maintainability_index': 45.952691612851474, 'raw_metrics': {'loc': 44, 'lloc': 44, 'sloc': 44, 'comments': 0}}"
count-non-decreasing-subarrays-after-k-operations,"```python
class Solution:
    def countNonDecreasingSubarrays(self, nums: List[int], k: int) -> int:
        n = len(nums)
        total_subarrays = n * (n + 1) // 2
        non_decreasing = 0
        left = 0
        
        for right in range(1, n):
            if nums[right] >= nums[right - 1]:
                continue
            length = right - left
            non_decreasing += length * (length + 1) // 2
            left = right
        
        length = n - left
        non_decreasing += length * (length + 1) // 2
        
        res = non_decreasing
        left = 0
        
        for right in range(1, n):
            if nums[right] >= nums[right - 1]:
                continue","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'countNonDecreasingSubarrays', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 54.22525020931003, 'raw_metrics': {'loc': 20, 'lloc': 20, 'sloc': 20, 'comments': 0}}"
minimize-the-maximum-adjacent-element-difference,"```python
from typing import List

class Solution:
    def minDifference(self, nums: List[int]) -> int:
        known = [num for num in nums if num != -1]
        if not known:
            return 0
        
        min_val = min(known)
        max_val = max(known)
        
        candidates = []
        n = len(nums)
        
        for i in range(n):
            if nums[i] == -1:
                left = nums[i-1] if i > 0 else None
                right = nums[i+1] if i < n-1 else None
                
                if left is not None and left != -1:
                    candidates.append(left)
                if right is not None and right != -1:
                    candidates.append(right)
        
        if not candidates:
            return 0
        
        candidates.append(min_val)
        candidates.append(max_val)
        candidates.sort()
        
        min_diff = float('inf')
        for i in range(1, len(candidates)):
            diff = candidates[i] - candidates[i-1]
            if diff < min_diff:
                min_diff = diff
        
        max_diff = max_val - min_val
        return min(min_diff, max_diff)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 16, 'lineno': 3}, {'name': 'minDifference', 'complexity': 15, 'lineno': 4}], 'maintainability_index': 47.72061062227981, 'raw_metrics': {'loc': 31, 'lloc': 31, 'sloc': 31, 'comments': 0}}"
sum-of-good-subsequences,"```python
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        max_num = max(nums) if nums else 0
        dp_sum = [0] * (max_num + 2)
        dp_count = [0] * (max_num + 2)
        
        for num in nums:
            total = 1  # the subsequence [num] itself
            if num - 1 >= 0:
                total += dp_count[num - 1]
            if num + 1 <= max_num:
                total += dp_count[num + 1]
            total %= MOD
            
            added_sum = num * (1 + dp_count[num - 1] + dp_count[num + 1]) % MOD
            dp_sum[num] = (dp_sum[num] + added_sum) % MOD
            dp_count[num] = (dp_count[num] + total) % MOD
        
        return sum(dp_sum) % MOD
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'sumOfGoodSubsequences', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 67.26258369027647, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 1}}"
maximize-the-number-of-target-nodes-after-connecting-trees-ii,"```python
from typing import List
from collections import deque

class Solution:
    def maxTargetNodes(self, edges1: List[List[int]], edges2: List[List[int]]) -> List[int]:
        n = len(edges1) + 1
        m = len(edges2) + 1
        
        tree1 = [[] for _ in range(n)]
        for u, v in edges1:
            tree1[u].append(v)
            tree1[v].append(u)
        
        tree2 = [[] for _ in range(m)]
        for u, v in edges2:
            tree2[u].append(v)
            tree2[v].append(u)
        
        parity2 = [0] * m
        q = deque()
        q.append(0)
        visited = [False] * m
        visited[0] = True
        
        while q:
            u = q.popleft()
            for v in tree2[u]:
                if not visited[v]:
                    visited[v] = True
                    parity2[v] = 1 - parity2[u]
                    q.append(v)
        
        count0 = parity2.count(0)
        count1 = m - count0
        
        parity1 = [0] * n
        q = deque()
        q.append(0)
        visited = [False] * n
        visited[0] = True
        
        while q:
            u = q.popleft()
            for v in tree1[u]:
                if not visited[v]:
                    visited[v] = True
                    parity1[v] = 1 - parity1[u]
                    q.append(v)
        
        answer = []
        for u in range(n):
            if parity1[u] == 0:
                answer.append(n + count0 - 1)
            else:
                answer.append(n + count1 - 1)
        
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 14, 'lineno': 4}, {'name': 'maxTargetNodes', 'complexity': 13, 'lineno': 5}], 'maintainability_index': 45.169089088427, 'raw_metrics': {'loc': 48, 'lloc': 48, 'sloc': 48, 'comments': 0}}"
maximum-frequency-of-an-element-after-performing-operations-ii,"```python
from collections import defaultdict

class Solution:
    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:
        if not nums:
            return 0
        
        nums.sort()
        freq = defaultdict(int)
        n = len(nums)
        left = 0
        total = 0
        max_freq = 0
        
        for right in range(n):
            target = nums[right]
            total += target
            
            while (right - left + 1) * target - total > k * numOperations:
                total -= nums[left]
                left += 1
            
            current_window = right - left + 1
            if current_window > max_freq:
                max_freq = current_window
        
        return max_freq
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'maxFrequency', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 54.301493199223586, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
minimum-operations-to-make-character-frequencies-equal,"```python
class Solution:
    def makeStringGood(self, s: str) -> int:
        from collections import defaultdict

        freq = defaultdict(int)
        for c in s:
            freq[c] += 1
        
        counts = sorted(freq.values())
        operations = 0
        
        for i in range(1, len(counts)):
            if counts[i] <= counts[i-1]:
                target = max(0, counts[i-1] - 1)
                operations += counts[i] - target if target < counts[i] else 0
                counts[i] = target if target < counts[i] else counts[i]
        
        return operations
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 1}, {'name': 'makeStringGood', 'complexity': 6, 'lineno': 2}], 'maintainability_index': 59.81882390595723, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
total-characters-in-string-after-transformations-ii,"```python
class Solution:
    def lengthAfterTransformations(self, s: str, t: int, nums: List[int]) -> int:
        MOD = 10**9 + 7
        
        
        
        total_length = 0
        for c in s:
            original_pos = ord(c) - ord('a')
            shift_per_step = nums[original_pos]
            multiplier = pow(shift_per_step, t, MOD)
            total_length = (total_length + multiplier) % MOD
        
        return total_length
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 2}, {'name': 'lengthAfterTransformations', 'complexity': 2, 'lineno': 3}], 'maintainability_index': 64.57904975746665, 'raw_metrics': {'loc': 11, 'lloc': 11, 'sloc': 11, 'comments': 0}}"
find-the-original-typed-string-ii,"```python
class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        MOD = 10**9 + 7
        n = len(word)
        if k > n:
            return 0
        
        groups = []
        current_char = word[0]
        count = 1
        for c in word[1:]:
            if c == current_char:
                count += 1
            else:
                groups.append((current_char, count))
                current_char = c
                count = 1
        groups.append((current_char, count))
        
        m = len(groups)
        if m < k:
            return 0
        
        dp = [[0] * (m + 1) for _ in range(m + 1)]
        dp[0][0] = 1
        
        for i in range(1, m + 1):
            for j in range(1, m + 1):
                if j > i:
                    continue
                if i - 1 >= 0 and j - 1 >= 0:
                    dp[i][j] += dp[i-1][j-1]
                if i - 2 >= 0 and j - 1 >= 0 and groups[i-1][0] == groups[i-2][0]:
                    dp[i][j] += dp[i-2][j-1] * (groups[i-1][1] + groups[i-2][1] - 1)
                dp[i][j] %= MOD
        
        total = 0
        for l in range(k, m + 1):
            total = (total + dp[m][l]) % MOD
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 16, 'lineno': 1}, {'name': 'possibleStringCount', 'complexity': 15, 'lineno': 2}], 'maintainability_index': 44.28913761795065, 'raw_metrics': {'loc': 35, 'lloc': 35, 'sloc': 35, 'comments': 0}}"
find-the-number-of-subsequences-with-equal-gcd,"```python
import math
from collections import defaultdict
from typing import List

class Solution:
    def subsequencePairCount(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        n = len(nums)
        g = defaultdict(int)
        
        for mask in range(1, 1 << n):
            current_gcd = 0
            for i in range(n):
                if mask & (1 << i):
                    current_gcd = math.gcd(current_gcd, nums[i])
            g[current_gcd] += 1
        
        total = 0
        for gcd_val in g:
            cnt = g[gcd_val]
            total = (total + cnt * (cnt - 1) // 2) % MOD
        
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 5}, {'name': 'subsequencePairCount', 'complexity': 5, 'lineno': 6}], 'maintainability_index': 55.473383818459546, 'raw_metrics': {'loc': 20, 'lloc': 20, 'sloc': 20, 'comments': 0}}"
find-the-number-of-possible-ways-for-an-event,"```python
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10**9 + 7
        
        dp = [[0] * (x + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        
        for i in range(1, n + 1):
            for k in range(1, x + 1):
                dp[i][k] = (dp[i-1][k-1] + dp[i-1][k] * k) % MOD
        
        total = 0
        fact = [1] * (x + 1)
        for i in range(1, x + 1):
            fact[i] = fact[i-1] * i % MOD
        
        for k in range(1, x + 1):
            ways_partition = dp[n][k] * fact[k] % MOD
            ways_score = pow(y, k, MOD)
            total = (total + ways_partition * ways_score) % MOD
        
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 1}, {'name': 'numberOfWays', 'complexity': 6, 'lineno': 2}], 'maintainability_index': 54.16722945556871, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
check-if-dfs-strings-are-palindromes,"```python
from typing import List

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        children = [[] for _ in range(n)]
        for i in range(1, n):
            children[parent[i]].append(i)
        
        answer = [False] * n
        
        for i in range(n):
            stack = [(i, False)]
            dfs_str = []
            while stack:
                node, processed = stack.pop()
                if processed:
                    dfs_str.append(s[node])
                else:
                    for child in reversed(sorted(children[node])):
                        stack.append((child, False))
                    stack.append((node, True))
            if dfs_str == dfs_str[::-1]:
                answer[i] = True
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 3}, {'name': 'findAnswer', 'complexity': 8, 'lineno': 4}], 'maintainability_index': 59.42053437668916, 'raw_metrics': {'loc': 23, 'lloc': 23, 'sloc': 23, 'comments': 0}}"
count-the-number-of-winning-sequences,"```python
class Solution:
    def countWinningSequences(self, s: str) -> int:
        MOD = 10**9 + 7
        n = len(s)
        
        alice_points = [0] * n
        for i in range(n):
            c = s[i]
            if c == 'F':
                alice_points[i] = [0, 1, -1]  # Bob's F, W, E: Alice's points
            elif c == 'W':
                alice_points[i] = [-1, 0, 1]
            elif c == 'E':
                alice_points[i] = [1, -1, 0]
        
        
        dp = {}
        for move in range(3):
            diff = -alice_points[0][move]
            dp[(move, diff)] = 1
        
        for i in range(1, n):
            new_dp = {}
            for (last_move, current_diff), count in dp.items():
                for next_move in range(3):
                    if next_move == last_move:
                        continue
                    new_diff = current_diff - alice_points[i][next_move]
                    key = (next_move, new_diff)
                    new_dp[key] = (new_dp.get(key, 0) + count) % MOD
            dp = new_dp
        
        total = 0
        for (last_move, diff), count in dp.items():
            if diff > 0:
                total = (total + count) % MOD
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 13, 'lineno': 1}, {'name': 'countWinningSequences', 'complexity': 12, 'lineno': 2}], 'maintainability_index': 59.288408247016605, 'raw_metrics': {'loc': 32, 'lloc': 32, 'sloc': 32, 'comments': 1}}"
sorted-gcd-pair-queries,"```python
import math
from collections import defaultdict
from bisect import bisect_left

class Solution:
    def gcdValues(self, nums: List[int], queries: List[int]) -> List[int]:
        freq = defaultdict(int)
        n = len(nums)
        
        for i in range(n):
            for j in range(i + 1, min(i + 100, n)):  # Limit the range to avoid O(n^2)
                g = math.gcd(nums[i], nums[j])
                freq[g] += 1
        
        value_counts = defaultdict(int)
        for num in nums:
            value_counts[num] += 1
        
        for num, cnt in value_counts.items():
            if cnt >= 2:
                pairs = cnt * (cnt - 1) // 2
                freq[num] += pairs
        
        sorted_gcds = sorted(freq.keys())
        cumulative = []
        total = 0
        for g in sorted_gcds:
            total += freq[g]
            cumulative.append(total)
        
        answer = []
        for q in queries:
            pos = q + 1  # 1-based to find the smallest g where cumulative >= pos
            idx = bisect_left(cumulative, pos)
            answer.append(sorted_gcds[idx])
        
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 5}, {'name': 'gcdValues', 'complexity': 8, 'lineno': 6}], 'maintainability_index': 65.914250542342, 'raw_metrics': {'loc': 31, 'lloc': 31, 'sloc': 31, 'comments': 2}}"
construct-2d-grid-matching-graph-layout,"```python
from collections import defaultdict, deque
from typing import List

class Solution:
    def constructGridLayout(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        graph = defaultdict(set)
        for u, v in edges:
            graph[u].add(v)
            graph[v].add(u)
        
        start = 0
        for node in graph:
            if len(graph[node]) <= 2:
                start = node
                break
        
        visited = set()
        queue = deque()
        queue.append(start)
        visited.add(start)
        order = []
        
        while queue:
            node = queue.popleft()
            order.append(node)
            for neighbor in graph[node]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        
        grid = []
        if not order:
            return grid
        
        current_row = [order[0]]
        remaining_nodes = order[1:]
        
        while remaining_nodes:
            last_in_row = current_row[-1]
            found = False
            for i, node in enumerate(remaining_nodes):
                if node in graph[last_in_row]:
                    current_row.append(node)
                    remaining_nodes.pop(i)
                    found = True
                    break
            if not found:
                grid.append(current_row)
                current_row = [remaining_nodes.pop(0)]
        
        if current_row:
            grid.append(current_row)
        
        return grid
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 14, 'lineno': 4}, {'name': 'constructGridLayout', 'complexity': 13, 'lineno': 5}], 'maintainability_index': 49.34133763561323, 'raw_metrics': {'loc': 46, 'lloc': 47, 'sloc': 46, 'comments': 0}}"
find-the-maximum-sequence-value-of-array,"```python
from typing import List

class Solution:
    def maxValue(self, nums: List[int], k: int) -> int:
        max_val = 0
        n = len(nums)
        for i in range(n - 2 * k + 1):
            for j in range(i + k, n - k + 1):
                left_or = 0
                for num in nums[i:i+k]:
                    left_or |= num
                right_or = 0
                for num in nums[j:j+k]:
                    right_or |= num
                current = left_or ^ right_or
                if current > max_val:
                    max_val = current
        return max_val
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'maxValue', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 56.327737200694706, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
count-substrings-that-can-be-rearranged-to-contain-a-string-ii,"```python
class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        len1, len2 = len(word1), len(word2)
        if len1 < len2:
            return 0
        
        target = [0] * 26
        for c in word2:
            target[ord(c) - ord('a')] += 1
        
        current = [0] * 26
        left = 0
        res = 0
        
        for right in range(len1):
            current[ord(word1[right]) - ord('a')] += 1
            
            while right - left + 1 > len2:
                current[ord(word1[left]) - ord('a')] -= 1
                left += 1
            
            if right - left + 1 == len2:
                valid = True
                for i in range(26):
                    if current[i] < target[i]:
                        valid = False
                        break
                if valid:
                    res += len1 - right
                    current[ord(word1[left]) - ord('a')] -= 1
                    left += 1
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 1}, {'name': 'validSubstringCount', 'complexity': 9, 'lineno': 2}], 'maintainability_index': 49.74385147881623, 'raw_metrics': {'loc': 27, 'lloc': 27, 'sloc': 27, 'comments': 0}}"
length-of-the-longest-increasing-path,"```python
class Solution:
    def maxPathLength(self, coordinates: List[List[int]], k: int) -> int:
        coordinates.sort()
        n = len(coordinates)
        dp = [1] * n
        target = coordinates[k]
        max_len = 1
        
        for i in range(n):
            x, y = coordinates[i]
            if x == target[0] and y == target[1]:
                current_max = 1
                for j in range(i):
                    prev_x, prev_y = coordinates[j]
                    if prev_x < x and prev_y < y:
                        if dp[j] + 1 > current_max:
                            current_max = dp[j] + 1
                dp[i] = current_max
                if current_max > max_len:
                    max_len = current_max
            else:
                current_max = 1
                for j in range(i):
                    prev_x, prev_y = coordinates[j]
                    if prev_x < x and prev_y < y:
                        if dp[j] + 1 > current_max:
                            current_max = dp[j] + 1
                dp[i] = current_max
        
        return max_len
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 14, 'lineno': 2}, {'name': 'maxPathLength', 'complexity': 13, 'lineno': 3}], 'maintainability_index': 49.45326028530962, 'raw_metrics': {'loc': 29, 'lloc': 29, 'sloc': 29, 'comments': 0}}"
select-cells-in-grid-with-maximum-score,"```python
from typing import List
import heapq

class Solution:
    def maxScore(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0]) if m > 0 else 0
        
        elements = []
        for i in range(m):
            for j in range(n):
                elements.append((-grid[i][j], i, j))  # Using max heap by storing negatives
        
        elements.sort()
        
        used_rows = set()
        used_values = set()
        total = 0
        
        for val, i, j in elements:
            current_val = -val
            if i not in used_rows and current_val not in used_values:
                used_rows.add(i)
                used_values.add(current_val)
                total += current_val
        
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 4}, {'name': 'maxScore', 'complexity': 7, 'lineno': 5}], 'maintainability_index': 68.972075098779, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 1}}"
maximum-score-of-non-overlapping-intervals,"```python
from typing import List

class Solution:
    def maximumWeight(self, intervals: List[List[int]]) -> List[int]:
        if not intervals:
            return []
        
        indexed_intervals = [(interval[0], interval[1], interval[2], i) for i, interval in enumerate(intervals)]
        indexed_intervals.sort(key=lambda x: x[1])
        
        n = len(indexed_intervals)
        prev = [-1] * n
        for i in range(n):
            low, high = 0, i - 1
            while low <= high:
                mid = (low + high) // 2
                if indexed_intervals[mid][1] < indexed_intervals[i][0]:
                    low = mid + 1
                else:
                    high = mid - 1
            prev[i] = high
        
        dp = [[0] * n for _ in range(5)]
        selected = [[[] for _ in range(n)] for _ in range(5)]
        
        for k in range(1, 5):
            for i in range(n):
                if i > 0:
                    dp[k][i] = dp[k][i-1]
                    selected[k][i] = selected[k][i-1].copy()
                
                if prev[i] == -1:
                    if k == 1:
                        if intervals[indexed_intervals[i][3]][2] > dp[k][i]:
                            dp[k][i] = intervals[indexed_intervals[i][3]][2]
                            selected[k][i] = [indexed_intervals[i][3]]
                else:
                    if dp[k-1][prev[i]] + intervals[indexed_intervals[i][3]][2] > dp[k][i]:
                        dp[k][i] = dp[k-1][prev[i]] + intervals[indexed_intervals[i][3]][2]
                        selected[k][i] = selected[k-1][prev[i]] + [indexed_intervals[i][3]]
        
        max_k = 0
        max_score = 0
        best_indices = []
        for k in range(1, 5):
            if dp[k][-1] > max_score:
                max_score = dp[k][-1]
                max_k = k
                best_indices = selected[k][-1]
            elif dp[k][-1] == max_score and len(selected[k][-1]) > len(best_indices):
                best_indices = selected[k][-1]
        
        best_indices.sort()
        return best_indices
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 21, 'lineno': 3}, {'name': 'maximumWeight', 'complexity': 20, 'lineno': 4}], 'maintainability_index': 41.441491921327476, 'raw_metrics': {'loc': 47, 'lloc': 48, 'sloc': 47, 'comments': 0}}"
maximum-number-of-moves-to-kill-all-pawns,"```python
from typing import List
from collections import deque

class Solution:
    def maxMoves(self, kx: int, ky: int, positions: List[List[int]]) -> int:
        pawns = positions
        n = len(pawns)
        distance_maps = {}
        directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2),
                      (1, -2), (1, 2), (2, -1), (2, 1)]
        
        for i, (px, py) in enumerate(pawns):
            q = deque()
            q.append((px, py))
            dist = {}
            dist[(px, py)] = 0
            while q:
                x, y = q.popleft()
                for dx, dy in directions:
                    nx, ny = x + dx, y + dy
                    if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in dist:
                        dist[(nx, ny)] = dist[(x, y)] + 1
                        q.append((nx, ny))
            distance_maps[i] = dist
        
        
        initial_steps = []
        for i in range(n):
            px, py = pawns[i]
            if (kx, ky) in distance_maps[i]:
                initial_steps.append(distance_maps[i][(kx, ky)])
            else:
                initial_steps.append(0)  # should not happen per problem statement
        
        
        step_matrix = [[0] * n for _ in range(n)]
        for i in range(n):
            for j in range(n):
                if i == j:
                    step_matrix[i][j] = 0
                else:
                    px, py = pawns[j]
                    if (px, py) in distance_maps[i]:
                        step_matrix[i][j] = distance_maps[i][(px, py)]
                    else:
                        step_matrix[i][j] = 0  # should not happen
        
        
        
        all_steps = []
        for step in initial_steps:
            all_steps.append(step)
        for i in range(n):
            for j in range(n):
                if i != j:
                    all_steps.append(step_matrix[i][j])
        
        all_steps.sort(reverse=True)
        
        total = 0
        for i in range(len(all_steps)):
            if i % 2 == 0:
                total += all_steps[i]
        
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 21, 'lineno': 4}, {'name': 'maxMoves', 'complexity': 20, 'lineno': 5}], 'maintainability_index': 53.13372517979782, 'raw_metrics': {'loc': 54, 'lloc': 53, 'sloc': 54, 'comments': 2}}"
maximum-xor-score-subarray-queries,"```python
from typing import List

class Solution:
    def maximumSubarrayXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        n = len(nums)
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i+1] = prefix[i] ^ nums[i]
        
        res = []
        for l, r in queries:
            max_xor = 0
            for i in range(l, r + 1):
                current_xor = 0
                for j in range(i, r + 1):
                    current_xor ^= nums[j]
                    if current_xor > max_xor:
                        max_xor = current_xor
            res.append(max_xor)
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'maximumSubarrayXor', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 57.355527011299664, 'raw_metrics': {'loc': 19, 'lloc': 19, 'sloc': 19, 'comments': 0}}"
find-the-count-of-good-integers,"```python
from math import comb

class Solution:
    def countGoodIntegers(self, n: int, k: int) -> int:
        if n == 1:
            return 9 // k
        
        total = 0
        half = (n + 1) // 2
        max_num = 10 ** half - 1
        min_num = 10 ** (half - 1)
        
        count = 0
        for num in range((min_num + k - 1) // k * k, max_num + 1, k):
            s = str(num)
            if s == s[::-1]:
                count += 1
        
        if n % 2 == 0:
            total = count * comb(9 + half - 1, half)
        else:
            first_digit_options = 9
            other_digits_options = comb(9 + half - 2, half - 1)
            total = count * first_digit_options * other_digits_options
        
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 2}, {'name': 'countGoodIntegers', 'complexity': 5, 'lineno': 3}], 'maintainability_index': 52.19397440457585, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
count-almost-equal-pairs-ii,"```python
from collections import defaultdict
from typing import List

class Solution:
    def countPairs(self, nums: List[int]) -> int:
        def get_key(num):
            s = str(num)
            freq = [0] * 10
            for c in s:
                freq[int(c)] += 1
            return tuple(freq)
        
        freq_map = defaultdict(int)
        res = 0
        for num in nums:
            key = get_key(num)
            res += freq_map[key]
            freq_map[key] += 1
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 4}, {'name': 'countPairs', 'complexity': 2, 'lineno': 5}], 'maintainability_index': 61.00679943910556, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
maximum-value-sum-by-placing-three-rooks-ii,"```python
from typing import List

class Solution:
    def maximumValueSum(self, board: List[List[int]]) -> int:
        m = len(board)
        n = len(board[0]) if m > 0 else 0
        
        row_max = [sorted([(val, j) for j, val in enumerate(row)], reverse=True) for row in board]
        col_max = []
        for j in range(n):
            column = [board[i][j] for i in range(m)]
            col_max.append(sorted([(val, i) for i, val in enumerate(column)], reverse=True))
        
        max_sum = -float('inf')
        
        for i1 in range(m):
            for j1 in range(n):
                val1 = board[i1][j1]
                for i2 in range(m):
                    if i2 == i1:
                        continue
                    for j2 in range(n):
                        if j2 == j1:
                            continue
                        val2 = board[i2][j2]
                        for i3 in range(m):
                            if i3 == i1 or i3 == i2:
                                continue
                            for j3 in range(n):
                                if j3 == j1 or j3 == j2:
                                    continue
                                val3 = board[i3][j3]
                                current_sum = val1 + val2 + val3
                                if current_sum > max_sum:
                                    max_sum = current_sum
        
        for i in range(m):
            for k1 in range(min(5, n)):
                j1 = row_max[i][k1][1]
                val1 = row_max[i][k1][0]
                for k2 in range(k1 + 1, min(5, n)):
                    j2 = row_max[i][k2][1]
                    val2 = row_max[i][k2][0]
                    for other_i in range(m):
                        if other_i == i:
                            continue
                        for other_j in range(n):
                            if other_j == j1 or other_j == j2:
                                continue
                            val3 = board[other_i][other_j]
                            current_sum = val1 + val2 + val3
                            if current_sum > max_sum:
                                max_sum = current_sum
        
        for j in range(n):
            for k1 in range(min(5, m)):
                i1 = col_max[j][k1][1]
                val1 = col_max[j][k1][0]
                for k2 in range(k1 + 1, min(5, m)):
                    i2 = col_max[j][k2][1]
                    val2 = col_max[j][k2][0]
                    for other_i in range(m):
                        if other_i == i1 or other_i == i2:
                            continue
                        for other_j in range(n):
                            if other_j == j:
                                continue
                            val3 = board[other_i][other_j]
                            current_sum = val1 + val2 + val3
                            if current_sum > max_sum:
                                max_sum = current_sum
        
        return max_sum
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 39, 'lineno': 3}, {'name': 'maximumValueSum', 'complexity': 38, 'lineno': 4}], 'maintainability_index': 36.37924624522919, 'raw_metrics': {'loc': 67, 'lloc': 67, 'sloc': 67, 'comments': 0}}"
find-the-count-of-monotonic-pairs-ii,"```python
class Solution:
    def countOfPairs(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        n = len(nums)
        if n == 0:
            return 0
        
        
        min_arr1 = [0] * n
        max_arr1 = [0] * n
        
        min_arr1[0] = 0
        max_arr1[0] = nums[0]
        for i in range(1, n):
            min_arr1[i] = min_arr1[i-1]
            max_arr1[i] = min(max_arr1[i-1], nums[i])
        
        for i in range(n-2, -1, -1):
            new_min = max(min_arr1[i], min_arr1[i+1] + nums[i] - nums[i+1])
            new_max = min(max_arr1[i], max_arr1[i+1])
            if new_min > new_max:
                return 0
            min_arr1[i] = new_min
            max_arr1[i] = new_max
        
        total = 1
        for i in range(n):
            choices = max_arr1[i] - min_arr1[i] + 1
            if choices <= 0:
                return 0
            total = (total * choices) % MOD
        
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 2}, {'name': 'countOfPairs', 'complexity': 7, 'lineno': 3}], 'maintainability_index': 49.93374244127631, 'raw_metrics': {'loc': 28, 'lloc': 28, 'sloc': 28, 'comments': 0}}"
find-the-count-of-monotonic-pairs-i,"```python
class Solution:
    def countOfPairs(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        n = len(nums)
        if n == 0:
            return 0
        
        
        min_arr1 = [0] * n
        max_arr1 = [0] * n
        
        min_arr1[0] = 0
        max_arr1[0] = nums[0]
        
        for i in range(1, n):
            max_arr1[i] = min(max_arr1[i-1], nums[i])
        
        for i in range(n-2, -1, -1):
            min_arr1[i] = max(min_arr1[i+1] - (nums[i+1] - nums[i]), 0)
        
        result = 1
        for i in range(n):
            if max_arr1[i] < min_arr1[i]:
                return 0
            cnt = max_arr1[i] - min_arr1[i] + 1
            result = (result * cnt) % MOD
        
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 2}, {'name': 'countOfPairs', 'complexity': 6, 'lineno': 3}], 'maintainability_index': 52.86524431246464, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
minimum-amount-of-damage-dealt-to-bob,"```python
from typing import List
import heapq

class Solution:
    def minDamage(self, power: int, damage: List[int], health: List[int]) -> int:
        enemies = []
        for d, h in zip(damage, health):
            heapq.heappush(enemies, (-d, h))
        
        total_damage = 0
        current_damage = 0
        
        while enemies:
            neg_d, h = heapq.heappop(enemies)
            d = -neg_d
            current_damage += d
            
            turns = (h + power - 1) // power
            total_damage += current_damage * turns
            
        return total_damage
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 4}, {'name': 'minDamage', 'complexity': 3, 'lineno': 5}], 'maintainability_index': 59.00572654444599, 'raw_metrics': {'loc': 17, 'lloc': 17, 'sloc': 17, 'comments': 0}}"
alternating-groups-iii,"```python
from typing import List

class Solution:
    def numberOfAlternatingGroups(self, colors: List[int], queries: List[List[int]]) -> List[int]:
        n = len(colors)
        if n == 0:
            return []
        
        segments = []
        start = 0
        for i in range(1, n + 1):
            if i == n:
                if colors[i-1] != colors[0]:
                    continue
                else:
                    segments.append((start, i-1))
                    start = i
            elif colors[i] == colors[i-1]:
                segments.append((start, i-1))
                start = i
        if start < n:
            segments.append((start, n-1))
        
        if len(segments) > 1 and colors[segments[0][0]] == colors[segments[-1][1]]:
            first_start, first_end = segments[0]
            last_start, last_end = segments[-1]
            merged_segment = (last_start, first_end)
            segments = [merged_segment] + segments[1:-1]
        
        from collections import defaultdict
        count_dict = defaultdict(int)
        for start, end in segments:
            length = end - start + 1
            count_dict[length] += 1
        
        result = []
        for query in queries:
            if query[0] == 1:
                size = query[1]
                res = 0
                for seg_len in count_dict:
                    if seg_len >= size:
                        res += (seg_len - size + 1) * count_dict[seg_len]
                result.append(res)
            elif query[0] == 2:
                index, color = query[1], query[2]
                if colors[index] == color:
                    continue
                colors[index] = color
                segments = []
                start = 0
                for i in range(1, n + 1):
                    if i == n:
                        if colors[i-1] != colors[0]:
                            continue
                        else:
                            segments.append((start, i-1))
                            start = i
                    elif colors[i] == colors[i-1]:
                        segments.append((start, i-1))
                        start = i
                if start < n:
                    segments.append((start, n-1))
                if len(segments) > 1 and colors[segments[0][0]] == colors[segments[-1][1]]:
                    first_start, first_end = segments[0]
                    last_start, last_end = segments[-1]
                    merged_segment = (last_start, first_end)
                    segments = [merged_segment] + segments[1:-1]
                count_dict = defaultdict(int)
                for start, end in segments:
                    length = end - start + 1
                    count_dict[length] += 1
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 25, 'lineno': 3}, {'name': 'numberOfAlternatingGroups', 'complexity': 24, 'lineno': 4}], 'maintainability_index': 35.88349543417392, 'raw_metrics': {'loc': 69, 'lloc': 71, 'sloc': 69, 'comments': 0}}"
shortest-distance-after-road-addition-queries-ii,"```python
import bisect

class Solution:
    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        intervals = []
        res = []
        current_min = n - 1
        
        for u, v in queries:
            new_start, new_end = u, v
            
            pos = bisect.bisect_left(intervals, (new_start, new_end))
            
            if pos > 0 and intervals[pos-1][1] >= new_start:
                prev_start, prev_end = intervals[pos-1]
                new_start = min(prev_start, new_start)
                new_end = max(prev_end, new_end)
                pos -= 1
                intervals.pop(pos)
            
            while pos < len(intervals) and intervals[pos][0] <= new_end:
                next_start, next_end = intervals[pos]
                new_start = min(new_start, next_start)
                new_end = max(new_end, next_end)
                intervals.pop(pos)
            
            bisect.insort(intervals, (new_start, new_end))
            
            if new_start == 0:
                current_min = min(current_min, new_end)
            
            res.append(current_min)
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 3}, {'name': 'shortestDistanceAfterQueries', 'complexity': 7, 'lineno': 4}], 'maintainability_index': 52.974121833628004, 'raw_metrics': {'loc': 26, 'lloc': 26, 'sloc': 26, 'comments': 0}}"
check-if-the-rectangle-corner-is-reachable,"```python
from typing import List

class Solution:
    def canReachCorner(self, xCorner: int, yCorner: int, circles: List[List[int]]) -> bool:
        for x, y, r in circles:
            if (x * x + y * y) <= r * r:
                return False
            if ((x - xCorner) ** 2 + (y - yCorner) ** 2) <= r * r:
                return False
            numerator = abs(yCorner * x - xCorner * y)
            denominator = (yCorner ** 2 + xCorner ** 2) ** 0.5
            if numerator <= r * denominator:
                return False
        return True
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'canReachCorner', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 56.75534519551122, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
count-the-number-of-inversions,"```python
class Solution:
    def numberOfPermutations(self, n: int, requirements: List[List[int]]) -> int:
        MOD = 10**9 + 7
        req = {endi: cnti for endi, cnti in requirements}
        max_inv = max(req.values()) if req else 0
        
        dp = [[0] * (max_inv + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        
        for i in range(1, n + 1):
            max_possible_inv = i * (i - 1) // 2
            for j in range(0, min(max_possible_inv, max_inv) + 1):
                for k in range(0, min(i, j + 1)):
                    if j - k >= 0:
                        dp[i][j] = (dp[i][j] + dp[i-1][j - k]) % MOD
        
        result = 1
        for endi in sorted(req.keys()):
            cnti = req[endi]
            if cnti > endi * (endi + 1) // 2:
                return 0
            result = (result * dp[endi + 1][cnti]) % MOD
        
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 2}, {'name': 'numberOfPermutations', 'complexity': 10, 'lineno': 3}], 'maintainability_index': 51.190476954526396, 'raw_metrics': {'loc': 21, 'lloc': 22, 'sloc': 21, 'comments': 0}}"
find-the-minimum-area-to-cover-all-ones-ii,"```python
from typing import List

class Solution:
    def minimumSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        ones = []
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    ones.append((i, j))
        
        if not ones:
            return 0
        
        def get_area(points):
            if not points:
                return 0
            min_row = min(p[0] for p in points)
            max_row = max(p[0] for p in points)
            min_col = min(p[1] for p in points)
            max_col = max(p[1] for p in points)
            return (max_row - min_row + 1) * (max_col - min_col + 1)
        
        min_total = float('inf')
        ones_sorted_row = sorted(ones, key=lambda x: x[0])
        for i in range(1, len(ones)):
            for j in range(i+1, len(ones)):
                group1 = ones_sorted_row[:i]
                group2 = ones_sorted_row[i:j]
                group3 = ones_sorted_row[j:]
                total = get_area(group1) + get_area(group2) + get_area(group3)
                if total < min_total:
                    min_total = total
        
        ones_sorted_col = sorted(ones, key=lambda x: x[1])
        for i in range(1, len(ones)):
            for j in range(i+1, len(ones)):
                group1 = ones_sorted_col[:i]
                group2 = ones_sorted_col[i:j]
                group3 = ones_sorted_col[j:]
                total = get_area(group1) + get_area(group2) + get_area(group3)
                if total < min_total:
                    min_total = total
        
        min_col = min(p[1] for p in ones)
        max_col = max(p[1] for p in ones)
        for split1 in range(min_col + 1, max_col + 1):
            for split2 in range(split1, max_col + 1):
                group1 = [p for p in ones if p[1] < split1]
                group2 = [p for p in ones if split1 <= p[1] < split2]
                group3 = [p for p in ones if p[1] >= split2]
                if group1 and group2 and group3:
                    total = get_area(group1) + get_area(group2) + get_area(group3)
                    if total < min_total:
                        min_total = total
        
        min_row = min(p[0] for p in ones)
        max_row = max(p[0] for p in ones)
        for split1 in range(min_row + 1, max_row + 1):
            for split2 in range(split1, max_row + 1):
                group1 = [p for p in ones if p[0] < split1]
                group2 = [p for p in ones if split1 <= p[0] < split2]
                group3 = [p for p in ones if p[0] >= split2]
                if group1 and group2 and group3:
                    total = get_area(group1) + get_area(group2) + get_area(group3)
                    if total < min_total:
                        min_total = total
        
        return min_total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 40, 'lineno': 3}, {'name': 'minimumSum', 'complexity': 39, 'lineno': 4}], 'maintainability_index': 34.67294262347756, 'raw_metrics': {'loc': 62, 'lloc': 70, 'sloc': 62, 'comments': 0}}"
minimum-operations-to-make-array-equal-to-target,"```python
from typing import List

class Solution:
    def minimumOperations(self, nums: List[int], target: List[int]) -> int:
        n = len(nums)
        diff = [target[i] - nums[i] for i in range(n)]
        res = 0
        current = 0
        for d in diff:
            if d != current:
                res += abs(d - current)
                current = d
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'minimumOperations', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 63.96317228110075, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
find-the-maximum-length-of-a-good-subsequence-ii,"```python
from typing import List

class Solution:
    def maximumLength(self, nums: List[int], k: int) -> int:
        n = len(nums)
        if k == 0:
            max_len = 0
            from collections import defaultdict
            freq = defaultdict(int)
            for num in nums:
                freq[num] += 1
                if freq[num] > max_len:
                    max_len = freq[num]
            return max_len
        
        dp = [[0] * (k + 1) for _ in range(n)]
        best = [[0] * (k + 1) for _ in range(n)]
        res = 0
        
        for i in range(n):
            for j in range(k + 1):
                dp[i][j] = 1
                if j > 0:
                    if i > 0:
                        dp[i][j] = max(dp[i][j], best[i-1][j-1] + 1)
                if i > 0:
                    if nums[i] == nums[i-1]:
                        dp[i][j] = max(dp[i][j], dp[i-1][j] + 1)
                
                if i == 0:
                    best[i][j] = dp[i][j]
                else:
                    best[i][j] = max(best[i-1][j], dp[i][j])
                
                if dp[i][j] > res:
                    res = dp[i][j]
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 15, 'lineno': 3}, {'name': 'maximumLength', 'complexity': 14, 'lineno': 4}], 'maintainability_index': 47.66895809780679, 'raw_metrics': {'loc': 33, 'lloc': 33, 'sloc': 33, 'comments': 0}}"
block-placement-queries,"```python
import bisect

class Solution:
    def getResults(self, queries: List[List[int]]) -> List[bool]:
        obstacles = []
        results = []
        for query in queries:
            if query[0] == 1:
                x = query[1]
                bisect.insort(obstacles, x)
            else:
                x, sz = query[1], query[2]
                if not obstacles:
                    results.append(x >= sz)
                    continue
                idx = bisect.bisect_left(obstacles, x)
                if idx == 0:
                    prev_obstacle = 0
                else:
                    prev_obstacle = obstacles[idx - 1]
                if x - prev_obstacle >= sz:
                    results.append(True)
                    continue
                possible = False
                if idx < len(obstacles):
                    next_obstacle = obstacles[idx]
                    if next_obstacle - sz >= 0 and next_obstacle - sz <= x - sz:
                        possible = True
                else:
                    if x >= sz:
                        possible = True
                results.append(possible)
        return results
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 3}, {'name': 'getResults', 'complexity': 10, 'lineno': 4}], 'maintainability_index': 49.298498729889246, 'raw_metrics': {'loc': 33, 'lloc': 33, 'sloc': 33, 'comments': 0}}"
find-products-of-elements-of-big-array,"```python
class Solution:
    def findProductsOfElements(self, queries: List[List[int]]) -> List[int]:
        def get_powers(x):
            powers = []
            power = 1
            while x > 0:
                if x & 1:
                    powers.append(power)
                power <<= 1
                x >>= 1
            return powers
        
        def find_kth_element(k):
            low, high = 1, k
            while low < high:
                mid = (low + high) // 2
                total = 0
                power = 1
                count = 0
                while power <= mid:
                    count += (mid // power + 1) // 2
                    power <<= 1
                if count < k:
                    low = mid + 1
                else:
                    high = mid
            x = low
            powers = get_powers(x)
            total_before = 0
            power = 1
            while power <= x - 1:
                total_before += ((x - 1) // power + 1) // 2
                power <<= 1
            pos_in_powers = k - total_before - 1
            return powers[pos_in_powers]
        
        def product_range(l, r, mod):
            if l > r:
                return 0
            res = 1
            for k in range(l, r + 1):
                elem = find_kth_element(k)
                res = (res * elem) % mod
            return res
        
        answer = []
        for query in queries:
            from_i, to_i, mod_i = query
            res = 1
            for k in range(from_i, to_i + 1):
                elem = find_kth_element(k + 1)  # 1-based to 0-based?
                res = (res * elem) % mod_i
            answer.append(res)
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'findProductsOfElements', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 51.09566336558372, 'raw_metrics': {'loc': 52, 'lloc': 52, 'sloc': 52, 'comments': 1}}"
minimum-cost-to-equalize-array,"```python
class Solution:
    def minCostToEqualizeArray(self, nums: List[int], cost1: int, cost2: int) -> int:
        MOD = 10**9 + 7
        max_num = max(nums)
        total_deficit = sum(max_num - x for x in nums)
        
        if cost1 * 2 <= cost2:
            return (total_deficit * cost1) % MOD
        
        n = len(nums)
        min_cost = float('inf')
        
        for target in [max_num, max_num + 1]:
            deficits = [target - x for x in nums]
            total = sum(deficits)
            max_deficit = max(deficits)
            pair_ops = (total - max_deficit)
            if max_deficit <= pair_ops:
                cost = (total // 2) * cost2
                if total % 2 != 0:
                    cost += cost1
            else:
                cost = pair_ops * cost2 + (max_deficit - pair_ops) * cost1
            if cost < min_cost:
                min_cost = cost
        
        return min_cost % MOD
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 2}, {'name': 'minCostToEqualizeArray', 'complexity': 8, 'lineno': 3}], 'maintainability_index': 50.969298642875835, 'raw_metrics': {'loc': 24, 'lloc': 24, 'sloc': 24, 'comments': 0}}"
find-the-number-of-subarrays-where-boundary-elements-are-maximum,"```python
from typing import List

class Solution:
    def numberOfSubarrays(self, nums: List[int]) -> int:
        stack = []
        res = 0
        for num in nums:
            while stack and stack[-1] < num:
                stack.pop()
            if not stack or stack[-1] > num:
                stack.append(num)
            res += len(stack)
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'numberOfSubarrays', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 61.219354746846655, 'raw_metrics': {'loc': 13, 'lloc': 13, 'sloc': 13, 'comments': 0}}"
kth-smallest-amount-with-single-denomination-combination,"```python
import heapq

class Solution:
    def findKthSmallest(self, coins: List[int], k: int) -> int:
        coins = sorted(coins)
        heap = []
        seen = set()
        
        for coin in coins:
            heapq.heappush(heap, (coin, coin))
            seen.add(coin)
        
        result = 0
        for _ in range(k):
            result, coin = heapq.heappop(heap)
            next_val = result + coin
            if next_val not in seen:
                seen.add(next_val)
                heapq.heappush(heap, (next_val, coin))
        
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'findKthSmallest', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 63.60838074561505, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
maximize-consecutive-elements-in-an-array-after-modification,"```python
from typing import List

class Solution:
    def maxSelectedElements(self, nums: List[int]) -> int:
        nums.sort()
        n = len(nums)
        dp = {}
        max_len = 1
        
        for num in nums:
            if num - 1 in dp:
                dp[num] = dp[num - 1] + 1
            else:
                dp[num] = 1
            if num + 1 in dp:
                dp[num + 1] = dp[num] + 1
            if num in dp:
                max_len = max(max_len, dp[num])
            if num + 1 in dp:
                max_len = max(max_len, dp[num + 1])
        
        return max_len
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'maxSelectedElements', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 56.006489070307445, 'raw_metrics': {'loc': 20, 'lloc': 20, 'sloc': 20, 'comments': 0}}"
earliest-second-to-mark-indices-ii,"```python
from typing import List

class Solution:
    def earliestSecondToMarkIndices(self, nums: List[int], changeIndices: List[int]) -> int:
        n = len(nums)
        m = len(changeIndices)
        
        left = 1
        right = m
        answer = -1
        
        while left <= right:
            mid = (left + right) // 2
            last_occurrence = {}
            for s in range(mid):
                i = changeIndices[s] - 1
                last_occurrence[i] = s
            
            if len(last_occurrence) != n:
                left = mid + 1
                continue
            
            total_ops = 0
            possible = True
            for s in range(mid):
                i = changeIndices[s] - 1
                if last_occurrence[i] == s:
                    if nums[i] > total_ops:
                        possible = False
                        break
                    total_ops -= nums[i]
                else:
                    total_ops += 1
            
            if possible:
                answer = mid
                right = mid - 1
            else:
                left = mid + 1
        
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 3}, {'name': 'earliestSecondToMarkIndices', 'complexity': 8, 'lineno': 4}], 'maintainability_index': 49.22481174108284, 'raw_metrics': {'loc': 35, 'lloc': 35, 'sloc': 35, 'comments': 0}}"
minimize-or-of-remaining-elements-using-operations,"```python
from typing import List

class Solution:
    def minOrAfterOperations(self, nums: List[int], k: int) -> int:
        res = 0
        for bit in range(29, -1, -1):
            mask = 1 << bit
            res_mask = res | mask
            cnt = 0
            current_and = (1 << 30) - 1  # Initialize to all ones
            for num in nums:
                current_and &= num
                if (current_and & res_mask) == 0:
                    cnt += 1
                    current_and = (1 << 30) - 1  # Reset to all ones
            if cnt > k:
                res |= mask
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 3}, {'name': 'minOrAfterOperations', 'complexity': 5, 'lineno': 4}], 'maintainability_index': 74.67442353106746, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 2}}"
count-the-number-of-powerful-integers,"```python
class Solution:
    def numberOfPowerfulInt(self, start: int, finish: int, limit: int, s: str) -> int:
        s_len = len(s)
        s_num = int(s)
        
        def count_powerful_numbers(high):
            high_str = str(high)
            n = len(high_str)
            if n < s_len:
                return 0
            prefix_len = n - s_len
            prefix_high = int(high_str[:prefix_len]) if prefix_len > 0 else 0
            suffix = int(high_str[prefix_len:])
            
            dp = {}
            def dfs(pos, tight):
                if pos == prefix_len:
                    return 1
                key = (pos, tight)
                if key in dp:
                    return dp[key]
                limit_digit = int(high_str[pos]) if tight else 9
                res = 0
                for d in range(0, min(limit_digit, limit) + 1):
                    new_tight = tight and (d == limit_digit)
                    res += dfs(pos + 1, new_tight)
                dp[key] = res
                return res
            total_prefix = dfs(0, True)
            
            if suffix >= s_num and all(int(c) <= limit for c in high_str[prefix_len:]):
                return total_prefix
            else:
                return total_prefix - 1 if total_prefix > 0 else 0
        
        def count_powerful_numbers_simple(high):
            count = 0
            s_num = int(s)
            if s_num > high:
                return 0
            max_prefix = high // (10 ** s_len)
            for prefix in range(0, max_prefix + 1):
                num = prefix * (10 ** s_len) + s_num
                if num > high:
                    continue
                valid = True
                temp = prefix
                while temp > 0:
                    digit = temp % 10
                    if digit > limit:
                        valid = False
                        break
                    temp = temp // 10
                if valid:
                    count += 1
            return count
        
        if finish < 10**6:
            return count_powerful_numbers_simple(finish) - count_powerful_numbers_simple(start - 1)
        else:
            return count_powerful_numbers(finish) - count_powerful_numbers(start - 1)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 1}, {'name': 'numberOfPowerfulInt', 'complexity': 2, 'lineno': 2}], 'maintainability_index': 41.627803198058544, 'raw_metrics': {'loc': 56, 'lloc': 58, 'sloc': 56, 'comments': 0}}"
maximize-the-number-of-partitions-after-operations,"```python
class Solution:
    def maxPartitionsAfterOperations(self, s: str, k: int) -> int:
        n = len(s)
        if k == 26:
            return n
        
        def calculate(s):
            res = 0
            left = 0
            while left < n:
                res += 1
                distinct = set()
                right = left
                while right < n:
                    distinct.add(s[right])
                    if len(distinct) > k:
                        break
                    right += 1
                left = right
            return res
        
        max_partitions = calculate(s)
        if max_partitions == n:
            return n
        
        for i in range(n):
            original_char = s[i]
            for c in 'abcdefghijklmnopqrstuvwxyz':
                if c == original_char:
                    continue
                modified_s = s[:i] + c + s[i+1:]
                current_partitions = calculate(modified_s)
                if current_partitions > max_partitions:
                    max_partitions = current_partitions
                    if max_partitions == n:
                        return n
        return max_partitions
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 1}, {'name': 'maxPartitionsAfterOperations', 'complexity': 8, 'lineno': 2}], 'maintainability_index': 49.37689021300578, 'raw_metrics': {'loc': 34, 'lloc': 35, 'sloc': 34, 'comments': 0}}"
count-the-number-of-infection-sequences,"```python
import math
from typing import List

class Solution:
    def numberOfSequence(self, n: int, sick: List[int]) -> int:
        MOD = 10**9 + 7
        gaps = []
        prev = -1
        for pos in sick:
            if prev + 1 < pos:
                gaps.append(pos - prev - 1)
            prev = pos
        if sick[-1] != n - 1:
            gaps.append(n - 1 - sick[-1])
        
        total = 0
        res = 1
        for g in gaps:
            total += g
            res = res * math.comb(total, g) % MOD
        
        sick_prev = -1
        for i in range(len(sick)):
            if i == 0:
                left = sick[i] - 0
                if left > 0:
                    res = res * pow(2, left - 1, MOD) % MOD
            else:
                between = sick[i] - sick[i-1] - 1
                if between > 0:
                    res = res * pow(2, between - 1, MOD) % MOD
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 4}, {'name': 'numberOfSequence', 'complexity': 9, 'lineno': 5}], 'maintainability_index': 47.76381591982601, 'raw_metrics': {'loc': 30, 'lloc': 30, 'sloc': 30, 'comments': 0}}"
count-the-number-of-good-partitions,"```python
class Solution:
    def numberOfGoodPartitions(self, nums: List[int]) -> int:
        last_occurrence = {}
        for idx, num in enumerate(nums):
            last_occurrence[num] = idx
        
        MOD = 10**9 + 7
        result = 1
        max_last = 0
        
        for i in range(len(nums)):
            max_last = max(max_last, last_occurrence[nums[i]])
            if i == max_last:
                result = (result * 2) % MOD
        
        return result // 2
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 2}, {'name': 'numberOfGoodPartitions', 'complexity': 4, 'lineno': 3}], 'maintainability_index': 61.32082306511657, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
find-maximum-non-decreasing-array-length,"```python
class Solution:
    def findMaximumLength(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [1] * n
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i+1] = prefix[i] + nums[i]
        
        last_val = [0] * (n + 2)
        dp_val = [0] * (n + 2)
        left = [0] * (n + 2)
        
        for i in range(1, n+1):
            left[i] = left[i-1] + 1
            while left[i] <= i:
                s = prefix[i] - prefix[left[i]-1]
                if s >= last_val[left[i]-1]:
                    break
                left[i] += 1
            
            if left[i] <= i:
                dp[i-1] = dp[left[i]-2] + 1 if left[i] >= 2 else 1
                last_val[i] = prefix[i] - prefix[left[i]-1]
            else:
                dp[i-1] = 1
                last_val[i] = nums[i-1]
        
        return max(dp)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 2}, {'name': 'findMaximumLength', 'complexity': 7, 'lineno': 3}], 'maintainability_index': 49.852998172003, 'raw_metrics': {'loc': 25, 'lloc': 25, 'sloc': 25, 'comments': 0}}"
count-beautiful-substrings-ii,"```python
class Solution:
    def beautifulSubstrings(self, s: str, k: int) -> int:
        vowels = {'a', 'e', 'i', 'o', 'u'}
        n = len(s)
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i+1] = prefix[i] + (1 if s[i] in vowels else -1)
        
        from collections import defaultdict
        mod_groups = defaultdict(dict)
        mod_groups[0][0] = 1
        res = 0
        
        for i in range(1, n+1):
            current = prefix[i]
            mod = (current % k + k) % k
            for m in mod_groups.get(mod, {}):
                if (current - m) % 2 == 0:
                    res += mod_groups[mod].get(m, 0)
            mod_groups[prefix[i] % (2 * k)][current] = mod_groups[prefix[i] % (2 * k)].get(current, 0) + 1
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 1}, {'name': 'beautifulSubstrings', 'complexity': 6, 'lineno': 2}], 'maintainability_index': 54.028761754984544, 'raw_metrics': {'loc': 19, 'lloc': 19, 'sloc': 19, 'comments': 0}}"
palindrome-rearrangement-queries,"```python
class Solution:
    def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:
        n = len(s)
        half = n // 2
        s1 = s[:half]
        s2 = s[half:][::-1]
        
        diff = [0] * (half + 1)
        for i in range(half):
            diff[i+1] = diff[i] + (1 if s1[i] != s2[i] else 0)
        
        freq1 = [[0]*26 for _ in range(half+1)]
        freq2 = [[0]*26 for _ in range(half+1)]
        
        for i in range(half):
            for c in range(26):
                freq1[i+1][c] = freq1[i][c]
                freq2[i+1][c] = freq2[i][c]
            freq1[i+1][ord(s1[i]) - ord('a')] += 1
            freq2[i+1][ord(s2[i]) - ord('a')] += 1
        
        res = []
        for a, b, c, d in queries:
            c_prime = half - 1 - (d - half)
            d_prime = half - 1 - (c - half)
            left_start = min(a, c_prime)
            left_end = max(b, d_prime)
            
            ok = True
            if left_start > 0 and diff[left_start] != 0:
                ok = False
            if left_end + 1 < half and diff[half] - diff[left_end + 1] != 0:
                ok = False
            
            if not ok:
                res.append(False)
                continue
            
            
            s1_freq = [0]*26
            s2_freq = [0]*26
            for i in range(26):
                s1_freq[i] = freq1[b+1][i] - freq1[a][i]
                s2_freq[i] = freq2[d_prime+1][i] - freq2[c_prime][i]
            
            if s1_freq != s2_freq:
                res.append(False)
                continue
            
            res.append(True)
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 16, 'lineno': 2}, {'name': 'canMakePalindromeQueries', 'complexity': 15, 'lineno': 3}], 'maintainability_index': 41.95101272632757, 'raw_metrics': {'loc': 42, 'lloc': 44, 'sloc': 42, 'comments': 0}}"
apply-operations-to-maximize-frequency-score,"```python
class Solution:
    def maxFrequencyScore(self, nums: List[int], k: int) -> int:
        nums.sort()
        left = 0
        total = 0
        max_freq = 1
        
        for right in range(len(nums)):
            total += nums[right]
            
            while nums[right] * (right - left + 1) > total + k:
                total -= nums[left]
                left += 1
            
            max_freq = max(max_freq, right - left + 1)
        
        return max_freq
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 2}, {'name': 'maxFrequencyScore', 'complexity': 3, 'lineno': 3}], 'maintainability_index': 59.836162432594215, 'raw_metrics': {'loc': 14, 'lloc': 14, 'sloc': 14, 'comments': 0}}"
find-building-where-alice-and-bob-can-meet,"```python
import bisect
from typing import List

class Solution:
    def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:
        n = len(heights)
        res = [-1] * len(queries)
        processed_queries = []
        for idx, (a, b) in enumerate(queries):
            if a == b:
                res[idx] = a
                continue
            if a > b:
                a, b = b, a
            if heights[a] < heights[b]:
                res[idx] = b
                continue
            processed_queries.append((b, heights[a], idx))
        
        stack = []
        queries_sorted = sorted(processed_queries, key=lambda x: -x[0])
        ptr = len(queries_sorted) - 1
        
        for i in range(n - 1, -1, -1):
            h = heights[i]
            while ptr >= 0 and queries_sorted[ptr][0] == i:
                target_h, min_h, idx = queries_sorted[ptr]
                ptr -= 1
                left = bisect.bisect_right(stack, (-min_h, -1)) 
                if left < len(stack):
                    res[idx] = -stack[left][1]
                else:
                    res[idx] = -1
            
            while stack and stack[-1][0] >= -h:
                stack.pop()
            stack.append((-h, -i))
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 4}, {'name': 'leftmostBuildingQueries', 'complexity': 11, 'lineno': 5}], 'maintainability_index': 46.91675400754217, 'raw_metrics': {'loc': 35, 'lloc': 36, 'sloc': 35, 'comments': 0}}"
maximum-points-after-collecting-coins-from-all-nodes,"```python
from typing import List
from collections import deque

class Solution:
    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:
        n = len(coins)
        graph = [[] for _ in range(n)]
        for a, b in edges:
            graph[a].append(b)
            graph[b].append(a)
        
        parent = [ -1 ] * n
        children = [[] for _ in range(n)]
        q = deque([0])
        parent[0] = -2  # mark as visited
        
        while q:
            u = q.popleft()
            for v in graph[u]:
                if parent[v] == -1:
                    parent[v] = u
                    children[u].append(v)
                    q.append(v)
        
        max_halves = 14
        dp = [[0] * (max_halves + 1) for _ in range(n)]
        
        stack = [(0, False)]
        
        while stack:
            u, processed = stack.pop()
            if not processed:
                stack.append((u, True))
                for v in reversed(children[u]):
                    stack.append((v, False))
            else:
                for h in range(max_halves + 1):
                    current_coin = coins[u] >> h
                    option1 = (current_coin - k) if (current_coin - k) > 0 else 0
                    for v in children[u]:
                        option1 += dp[v][h]
                    
                    option2 = current_coin // 2
                    for v in children[u]:
                        option2 += dp[v][h + 1] if (h + 1) <= max_halves else 0
                    
                    dp[u][h] = max(option1, option2)
        
        return dp[0][0]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 17, 'lineno': 4}, {'name': 'maximumPoints', 'complexity': 16, 'lineno': 5}], 'maintainability_index': 54.89045943883348, 'raw_metrics': {'loc': 41, 'lloc': 41, 'sloc': 41, 'comments': 1}}"
count-valid-paths-in-a-tree,"```python
import math
from collections import defaultdict
from typing import List

class Solution:
    def countPaths(self, n: int, edges: List[List[int]]) -> int:
        is_prime = [True] * (n + 1)
        is_prime[0] = is_prime[1] = False
        for i in range(2, int(math.sqrt(n)) + 1):
            if is_prime[i]:
                for j in range(i * i, n + 1, i):
                    is_prime[j] = False
        
        adj = defaultdict(list)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        
        res = 0
        
        count = defaultdict(lambda: [0, 0])
        
        stack = [(1, None, False)]
        
        while stack:
            node, parent, processed = stack.pop()
            if not processed:
                stack.append((node, parent, True))
                for neighbor in reversed(adj[node]):
                    if neighbor != parent:
                        stack.append((neighbor, node, False))
            else:
                cnt0, cnt1 = 0, 0
                if is_prime[node]:
                    cnt1 = 1
                else:
                    cnt0 = 1
                
                for neighbor in adj[node]:
                    if neighbor == parent:
                        continue
                    child_cnt0, child_cnt1 = count[neighbor]
                    if is_prime[node]:
                        res += child_cnt0
                    else:
                        res += child_cnt1
                    if is_prime[node]:
                        res += cnt0 * child_cnt0
                    else:
                        res += cnt0 * child_cnt1 + cnt1 * child_cnt0
                    if is_prime[node]:
                        cnt1 += child_cnt0
                    else:
                        cnt0 += child_cnt0
                        cnt1 += child_cnt1
                count[node] = [cnt0, cnt1]
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 16, 'lineno': 5}, {'name': 'countPaths', 'complexity': 15, 'lineno': 6}], 'maintainability_index': 43.58459905695943, 'raw_metrics': {'loc': 51, 'lloc': 52, 'sloc': 51, 'comments': 0}}"
maximum-spending-after-buying-items,"```python
import heapq
from typing import List

class Solution:
    def maxSpending(self, values: List[List[int]]) -> int:
        m = len(values)
        n = len(values[0]) if m > 0 else 0
        
        max_heap = []
        for i in range(m):
            if n > 0:
                heapq.heappush(max_heap, (-values[i][-1], i, n - 1))
        
        total = 0
        day = 1
        
        while max_heap:
            val_neg, i, j = heapq.heappop(max_heap)
            val = -val_neg
            total += val * day
            day += 1
            if j > 0:
                heapq.heappush(max_heap, (-values[i][j - 1], i, j - 1))
        
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 4}, {'name': 'maxSpending', 'complexity': 6, 'lineno': 5}], 'maintainability_index': 55.12264296683162, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
count-of-sub-multisets-with-bounded-sum,"```python
from collections import defaultdict
from typing import List

class Solution:
    def countSubMultisets(self, nums: List[int], l: int, r: int) -> int:
        MOD = 10**9 + 7
        freq = defaultdict(int)
        for num in nums:
            freq[num] += 1
        
        max_sum = r
        dp = [0] * (max_sum + 1)
        dp[0] = 1  # empty multiset
        
        for num, cnt in freq.items():
            if num == 0:
                continue
            for s in range(max_sum, -1, -1):
                if dp[s]:
                    for k in range(1, cnt + 1):
                        if s + k * num <= max_sum:
                            dp[s + k * num] = (dp[s + k * num] + dp[s]) % MOD
                        else:
                            break
        
        total = 0
        for s in range(l, r + 1):
            if s <= max_sum:
                total = (total + dp[s]) % MOD
        
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 4}, {'name': 'countSubMultisets', 'complexity': 10, 'lineno': 5}], 'maintainability_index': 61.082189491455765, 'raw_metrics': {'loc': 27, 'lloc': 27, 'sloc': 27, 'comments': 1}}"
string-transformation,"```python
MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, s: str, t: str, k: int) -> int:
        n = len(s)
        if n != len(t):
            return 0
        
        shifts = []
        doubled = s + s
        for i in range(1, n+1):
            if doubled[i:i+n] == t:
                shifts.append(i)
        if not shifts:
            return 0
        
        m = len(shifts)
        
        
        
        initial_shift_0 = 1 if 0 in shifts else 0
        f0 = 0
        g0 = initial_shift_0
        
        if k == 0:
            return g0 % MOD
        
        a = (n - m) % MOD
        b = (m - 1) % MOD
        c = (n - m - 1) % MOD
        d = m % MOD
        
        def matrix_mult(A, B):
            return [
                [(A[0][0] * B[0][0] + A[0][1] * B[1][0]) % MOD,
                 (A[0][0] * B[0][1] + A[0][1] * B[1][1]) % MOD],
                [(A[1][0] * B[0][0] + A[1][1] * B[1][0]) % MOD,
                 (A[1][0] * B[0][1] + A[1][1] * B[1][1]) % MOD]
            ]
        
        def matrix_pow(mat, power):
            result = [[1, 0], [0, 1]]  # Identity matrix
            while power > 0:
                if power % 2 == 1:
                    result = matrix_mult(result, mat)
                mat = matrix_mult(mat, mat)
                power //= 2
            return result
        
        mat = [[a, b], [c, d]]
        mat_k = matrix_pow(mat, k)
        
        
        
        if initial_shift_0:
            res = mat_k[0][1]
        else:
            res = mat_k[1][1] * m % MOD
        
        return res % MOD
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 2}, {'name': 'numberOfWays', 'complexity': 8, 'lineno': 3}], 'maintainability_index': 52.545318709644235, 'raw_metrics': {'loc': 45, 'lloc': 40, 'sloc': 45, 'comments': 1}}"
count-stepping-numbers-in-range,"```python
class Solution:
    def countSteppingNumbers(self, low: str, high: str) -> int:
        MOD = 10**9 + 7
        
        def count_stepping_numbers_up_to(s):
            n = len(s)
            s = list(map(int, s))
            
            memo = {}
            
            def dp(pos, prev, tight, leading_zero):
                if pos == n:
                    return 0 if leading_zero else 1
                key = (pos, prev, tight, leading_zero)
                if key in memo:
                    return memo[key]
                
                limit = s[pos] if tight else 9
                total = 0
                
                for d in range(0, limit + 1):
                    new_tight = tight and (d == limit)
                    new_leading_zero = leading_zero and (d == 0)
                    
                    if new_leading_zero:
                        total += dp(pos + 1, prev, new_tight, new_leading_zero)
                    else:
                        if leading_zero or abs(d - prev) == 1:
                            total += dp(pos + 1, d, new_tight, False)
                
                memo[key] = total % MOD
                return memo[key]
            
            return dp(0, 0, True, True)
        
        def is_stepping_number(num_str):
            num = list(map(int, num_str))
            for i in range(1, len(num)):
                if abs(num[i] - num[i-1]) != 1:
                    return False
            return True
        
        low_num = int(low)
        high_num = int(high)
        
        count_high = count_stepping_numbers_up_to(high)
        count_low = count_stepping_numbers_up_to(str(low_num - 1)) if low_num > 1 else 0
        total = (count_high - count_low) % MOD
        
        if is_stepping_number(low):
            total = (total + 1) % MOD
        
        return total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 1}, {'name': 'countSteppingNumbers', 'complexity': 3, 'lineno': 2}], 'maintainability_index': 46.0692091738947, 'raw_metrics': {'loc': 40, 'lloc': 40, 'sloc': 40, 'comments': 0}}"
minimum-changes-to-make-k-semi-palindromes,"```python
class Solution:
    def minimumChanges(self, s: str, k: int) -> int:
        n = len(s)
        cost = [[0] * n for _ in range(n)]
        
        for i in range(n):
            for j in range(i + 1, n):
                length = j - i + 1
                min_cost = float('inf')
                for d in range(1, length):
                    if length % d != 0:
                        continue
                    current_cost = 0
                    for group in range(d):
                        left = i + group
                        right = j - (d - 1 - group)
                        l, r = left, right
                        while l < r:
                            if s[l] != s[r]:
                                current_cost += 1
                            l += d
                            r -= d
                    min_cost = min(min_cost, current_cost)
                cost[i][j] = min_cost if min_cost != float('inf') else 0
        
        dp = [[float('inf')] * n for _ in range(k + 1)]
        for i in range(n):
            dp[1][i] = cost[0][i]
        
        for t in range(2, k + 1):
            for i in range(t - 1, n):
                for j in range(t - 2, i):
                    if dp[t - 1][j] + cost[j + 1][i] < dp[t][i]:
                        dp[t][i] = dp[t - 1][j] + cost[j + 1][i]
        
        return dp[k][n - 1]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 17, 'lineno': 1}, {'name': 'minimumChanges', 'complexity': 16, 'lineno': 2}], 'maintainability_index': 46.30379743370434, 'raw_metrics': {'loc': 32, 'lloc': 32, 'sloc': 32, 'comments': 0}}"
modify-graph-edge-weights,"```python
import heapq
from collections import defaultdict

class Solution:
    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:
        adj = defaultdict(list)
        for i, (u, v, w) in enumerate(edges):
            adj[u].append((v, i))
            adj[v].append((u, i))
        
        def dijkstra(adj, edges, src, dest, skip_negative):
            min_heap = []
            heapq.heappush(min_heap, (0, src))
            dist = {node: float('inf') for node in range(n)}
            dist[src] = 0
            parent = {}
            visited = set()
            
            while min_heap:
                current_dist, u = heapq.heappop(min_heap)
                if u in visited:
                    continue
                visited.add(u)
                if u == dest:
                    break
                for (v, idx) in adj[u]:
                    w = edges[idx][2]
                    if w == -1:
                        if skip_negative:
                            continue
                        w = 1  # treat -1 as 1 temporarily
                    if dist[v] > current_dist + w:
                        dist[v] = current_dist + w
                        parent[v] = u
                        heapq.heappush(min_heap, (dist[v], v))
            return dist.get(dest, float('inf')), parent
        
        shortest_path, _ = dijkstra(adj, edges, source, destination, skip_negative=False)
        if shortest_path > target:
            return []
        
        shortest_path_skip, parent = dijkstra(adj, edges, source, destination, skip_negative=True)
        if shortest_path_skip < target:
            return []
        elif shortest_path_skip == target:
            path_edges = set()
            node = destination
            while node != source:
                prev = parent[node]
                for (v, idx) in adj[prev]:
                    if v == node:
                        path_edges.add(idx)
                        break
                node = prev
            modified_edges = []
            for i, (u, v, w) in enumerate(edges):
                if w == -1:
                    if i not in path_edges:
                        modified_edges.append([u, v, 1])
                    else:
                        modified_edges.append([u, v, target - shortest_path_skip + 1])
                else:
                    modified_edges.append([u, v, w])
            return modified_edges
        
        dist = {node: float('inf') for node in range(n)}
        dist[source] = 0
        heap = [(0, source)]
        parent = {}
        edge_usage = {}  # to store which edge was used to reach a node
        
        while heap:
            current_dist, u = heapq.heappop(heap)
            if u == destination:
                break
            if current_dist > dist[u]:
                continue
            for (v, idx) in adj[u]:
                w = edges[idx][2]
                if w == -1:
                    w = 1
                if dist[v] > current_dist + w:
                    dist[v] = current_dist + w
                    parent[v] = u
                    edge_usage[v] = idx
                    heapq.heappush(heap, (dist[v], v))
        
        path = []
        node = destination
        while node != source:
            prev = parent[node]
            edge_idx = edge_usage[node]
            path.append(edge_idx)
            node = prev
        
        count_neg = 0
        for idx in path:
            if edges[idx][2] == -1:
                count_neg += 1
        
        if count_neg == 0:
            return []  # no -1 edges to adjust
        
        total_needed = target - (dist[destination] - count_neg)
        if total_needed < count_neg:
            return []  # each -1 edge must be at least 1
        
        remaining = total_needed
        modified = {}
        for idx in path:
            if edges[idx][2] == -1:
                if remaining > 0:
                    assign = 1 + remaining
                    modified[idx] = assign
                    remaining = 0
                else:
                    modified[idx] = 1
        
        result = []
        for i, (u, v, w) in enumerate(edges):
            if w == -1:
                if i in modified:
                    result.append([u, v, modified[i]])
                else:
                    result.append([u, v, 1])
            else:
                result.append([u, v, w])
        
        adj_modified = defaultdict(list)
        for u, v, w in result:
            adj_modified[u].append((v, w))
            adj_modified[v].append((u, w))
        
        heap = [(0, source)]
        dist_modified = {node: float('inf') for node in range(n)}
        dist_modified[source] = 0
        
        while heap:
            current_dist, u = heapq.heappop(heap)
            if u == destination:
                break
            if current_dist > dist_modified[u]:
                continue
            for (v, w) in adj_modified[u]:
                if dist_modified[v] > current_dist + w:
                    dist_modified[v] = current_dist + w
                    heapq.heappush(heap, (dist_modified[v], v))
        
        if dist_modified.get(destination, float('inf')) == target:
            return result
        else:
            return []
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 38, 'lineno': 4}, {'name': 'modifiedGraphEdges', 'complexity': 37, 'lineno': 5}], 'maintainability_index': 38.228650136817386, 'raw_metrics': {'loc': 136, 'lloc': 139, 'sloc': 136, 'comments': 4}}"
find-the-string-with-lcp,"```python
from typing import List

class Solution:
    def findTheString(self, lcp: List[List[int]]) -> str:
        n = len(lcp)
        word = [''] * n
        
        for i in range(n):
            if lcp[i][i] != n - i:
                return """"
            for j in range(n):
                if lcp[i][j] != lcp[j][i]:
                    return """"
                if lcp[i][j] > n - max(i, j):
                    return """"
        
        current_char = 'a'
        for i in range(n):
            if word[i] == '':
                if current_char > 'z':
                    return """"  # Not enough letters
                word[i] = current_char
                for j in range(i + 1, n):
                    if lcp[i][j] > 0:
                        if j >= n:
                            return """"
                        if word[j] == '':
                            word[j] = word[i]
                        elif word[j] != word[i]:
                            return """"
                current_char = chr(ord(current_char) + 1)
        
        for i in range(n - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                if i == j:
                    if lcp[i][j] != n - i:
                        return """"
                else:
                    if word[i] != word[j]:
                        if lcp[i][j] != 0:
                            return """"
                    else:
                        max_len = 0
                        if i + 1 < n and j + 1 < n:
                            if word[i] == word[j]:
                                max_len = lcp[i + 1][j + 1] + 1
                        if lcp[i][j] != max_len:
                            return """"
        return ''.join(word)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 25, 'lineno': 3}, {'name': 'findTheString', 'complexity': 24, 'lineno': 4}], 'maintainability_index': 49.92953612797871, 'raw_metrics': {'loc': 46, 'lloc': 46, 'sloc': 46, 'comments': 1}}"
subsequence-with-the-minimum-score,"```python
class Solution:
    def minimumScore(self, s: str, t: str) -> int:
        m, n = len(s), len(t)
        left_pos = [-1] * n
        i = 0
        for j in range(n):
            while i < m and s[i] != t[j]:
                i += 1
            if i < m:
                left_pos[j] = i
                i += 1
            else:
                break
        
        right_pos = [-1] * n
        i = m - 1
        for j in range(n - 1, -1, -1):
            while i >= 0 and s[i] != t[j]:
                i -= 1
            if i >= 0:
                right_pos[j] = i
                i -= 1
            else:
                break
        
        left = 0
        while left < n and left_pos[left] != -1:
            left += 1
        
        right = n - 1
        while right >= 0 and right_pos[right] != -1:
            right -= 1
        
        if left > right:
            return 0
        
        min_score = right - left + 1
        
        i = 0
        j = right + 1
        while i < left and j < n:
            if left_pos[i] < right_pos[j]:
                min_score = min(min_score, j - i - 1)
                i += 1
            else:
                j += 1
        
        return min_score
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 18, 'lineno': 1}, {'name': 'minimumScore', 'complexity': 17, 'lineno': 2}], 'maintainability_index': 42.6599629616452, 'raw_metrics': {'loc': 41, 'lloc': 41, 'sloc': 41, 'comments': 0}}"
maximize-the-minimum-powered-city,"```python
from typing import List

class Solution:
    def maxPower(self, stations: List[int], r: int, k: int) -> int:
        n = len(stations)
        left = 0
        right = max(stations) + k
        res = 0
        
        def is_possible(target):
            nonlocal k
            diff = [0] * (n + 1)
            current = 0
            remaining = k
            for i in range(n):
                current += diff[i]
                total = stations[i] + current
                if total < target:
                    needed = target - total
                    if needed > remaining:
                        return False
                    remaining -= needed
                    current += needed
                    end = min(i + 2 * r + 1, n)
                    diff[end] -= needed
            return True
        
        while left <= right:
            mid = (left + right) // 2
            if is_possible(mid):
                res = mid
                left = mid + 1
            else:
                right = mid - 1
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'maxPower', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 49.14832384026085, 'raw_metrics': {'loc': 33, 'lloc': 33, 'sloc': 33, 'comments': 0}}"
number-of-beautiful-partitions,"```python
class Solution:
    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:
        MOD = 10**9 + 7
        primes = {'2', '3', '5', '7'}
        n = len(s)
        if k * minLength > n or s[0] not in primes or s[-1] in primes:
            return 0
        
        dp = [[0] * (n + 1) for _ in range(k + 1)]
        dp[0][0] = 1
        
        for parts in range(1, k + 1):
            total = 0
            for end in range(1, n + 1):
                if end >= minLength:
                    start = end - minLength
                    if start >= 0 and s[start] in primes and (end == n or s[end] not in primes):
                        total += dp[parts - 1][start]
                        total %= MOD
                dp[parts][end] = total
        
        return dp[k][n]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 13, 'lineno': 1}, {'name': 'beautifulPartitions', 'complexity': 12, 'lineno': 2}], 'maintainability_index': 52.148249754711884, 'raw_metrics': {'loc': 19, 'lloc': 19, 'sloc': 19, 'comments': 0}}"
split-message-based-on-limit,"```python
from typing import List

class Solution:
    def splitMessage(self, message: str, limit: int) -> List[str]:
        n = len(message)
        parts = 0
        low, high = 1, n
        found = False
        while low <= high:
            mid = (low + high) // 2
            total = 0
            ok = True
            a_digits = 1
            b_digits = len(str(mid))
            pos = 0
            for a in range(1, mid + 1):
                if a >= 10 ** a_digits:
                    a_digits += 1
                suffix_len = 3 + a_digits + b_digits  # <a/b> is 3 + digits of a + digits of b
                if suffix_len >= limit:
                    ok = False
                    break
                chunk_len = limit - suffix_len
                total += chunk_len
                if total > n:
                    break
            if ok and total >= n:
                found = True
                parts = mid
                high = mid - 1
            else:
                low = mid + 1
        if not found:
            return []
        
        res = []
        pos = 0
        b_digits = len(str(parts))
        a_digits = 1
        for a in range(1, parts + 1):
            if a >= 10 ** a_digits:
                a_digits += 1
            suffix_len = 3 + a_digits + b_digits
            chunk_len = limit - suffix_len
            chunk = message[pos: pos + chunk_len]
            pos += chunk_len
            part = f""{chunk}<{a}/{parts}>""
            res.append(part)
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 3}, {'name': 'splitMessage', 'complexity': 11, 'lineno': 4}], 'maintainability_index': 51.85890146369349, 'raw_metrics': {'loc': 48, 'lloc': 49, 'sloc': 48, 'comments': 1}}"
maximum-number-of-non-overlapping-palindrome-substrings,"```python
class Solution:
    def maxPalindromes(self, s: str, k: int) -> int:
        n = len(s)
        dp = [0] * (n + 1)
        
        for i in range(n):
            dp[i+1] = dp[i]
            l, r = i, i
            while l >= 0 and r < n and s[l] == s[r]:
                if r - l + 1 >= k:
                    dp[r+1] = max(dp[r+1], dp[l] + 1)
                    break
                l -= 1
                r += 1
            l, r = i, i+1
            while l >= 0 and r < n and s[l] == s[r]:
                if r - l + 1 >= k:
                    dp[r+1] = max(dp[r+1], dp[l] + 1)
                    break
                l -= 1
                r += 1
        
        return dp[n]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 1}, {'name': 'maxPalindromes', 'complexity': 10, 'lineno': 2}], 'maintainability_index': 51.23804293783917, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
height-of-binary-tree-after-subtree-removal-queries,"```python
class Solution:
    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:
        from collections import defaultdict

        depth = defaultdict(int)
        height = defaultdict(int)
        ancestors = defaultdict(list)
        node_map = {}

        stack = [(root, 0, [])]
        while stack:
            node, d, path = stack.pop()
            if not node:
                continue
            depth[node.val] = d
            node_map[node.val] = node
            ancestors[node.val] = path.copy()
            stack.append((node.right, d + 1, path + [node.val]))
            stack.append((node.left, d + 1, path + [node.val]))

        stack = [(root, False)]
        while stack:
            node, visited = stack.pop()
            if not node:
                continue
            if visited:
                left_height = height[node.left.val] if node.left else -1
                right_height = height[node.right.val] if node.right else -1
                height[node.val] = 1 + max(left_height, right_height)
            else:
                stack.append((node, True))
                stack.append((node.right, False))
                stack.append((node.left, False))

        max_heights = defaultdict(dict)
        for node_val in node_map:
            path = ancestors[node_val]
            for i, ancestor_val in enumerate(path):
                sibling = None
                ancestor_node = node_map[ancestor_val]
                if i < len(path) - 1:
                    next_val = path[i+1]
                    if ancestor_node.left and ancestor_node.left.val == next_val:
                        sibling = ancestor_node.right
                    else:
                        sibling = ancestor_node.left
                else:
                    if ancestor_node.left and ancestor_node.left.val == node_val:
                        sibling = ancestor_node.right
                    else:
                        sibling = ancestor_node.left
                sibling_height = height[sibling.val] if sibling else -1
                current_max = depth[ancestor_val] + sibling_height
                if i == 0:
                    max_heights[node_val][ancestor_val] = current_max
                else:
                    parent_val = path[i-1]
                    max_heights[node_val][ancestor_val] = max(current_max, max_heights[node_val][parent_val])

        res = []
        for q in queries:
            path = ancestors[q]
            if not path:
                res.append(-1)
                continue
            max_h = -1
            for ancestor_val in path:
                if ancestor_val in max_heights[q]:
                    max_h = max(max_h, max_heights[q][ancestor_val])
            res.append(max_h)
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 22, 'lineno': 2}, {'name': 'treeQueries', 'complexity': 21, 'lineno': 3}], 'maintainability_index': 39.75353705042274, 'raw_metrics': {'loc': 67, 'lloc': 67, 'sloc': 67, 'comments': 0}}"
longest-increasing-subsequence-ii,"```python
import bisect

class Solution:
    def lengthOfLIS(self, nums: List[int], k: int) -> int:
        tails = []
        for num in nums:
            idx = bisect.bisect_left(tails, num)
            if idx == 0:
                if not tails or num <= tails[0]:
                    if not tails:
                        tails.append(num)
                    else:
                        tails[0] = num
            else:
                left = bisect.bisect_left(tails, num - k)
                if left < idx:
                    if idx < len(tails):
                        tails[idx] = min(tails[idx], num)
                    else:
                        tails.append(num)
        return len(tails)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 3}, {'name': 'lengthOfLIS', 'complexity': 8, 'lineno': 4}], 'maintainability_index': 56.3313363003473, 'raw_metrics': {'loc': 21, 'lloc': 21, 'sloc': 21, 'comments': 0}}"
find-the-k-sum-of-an-array,"```python
import heapq
from typing import List

class Solution:
    def kSum(self, nums: List[int], k: int) -> int:
        max_sum = sum(num for num in nums if num > 0)
        abs_nums = sorted(abs(num) for num in nums)
        max_heap = [(-max_sum, 0)]
        result = max_sum
        
        for _ in range(k - 1):
            current_sum, i = heapq.heappop(max_heap)
            current_sum = -current_sum
            result = current_sum
            
            if i < len(abs_nums):
                heapq.heappush(max_heap, (-(current_sum - abs_nums[i]), i + 1))
                if i > 0:
                    heapq.heappush(max_heap, (-(current_sum - abs_nums[i] + abs_nums[i - 1]), i + 1))
        
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 8, 'lineno': 4}, {'name': 'kSum', 'complexity': 7, 'lineno': 5}], 'maintainability_index': 56.081337512845295, 'raw_metrics': {'loc': 18, 'lloc': 18, 'sloc': 18, 'comments': 0}}"
maximum-total-beauty-of-the-gardens,"```python
class Solution:
    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:
        flowers.sort()
        n = len(flowers)
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i+1] = prefix[i] + flowers[i]
        
        res = 0
        j = n - 1
        while j >= 0 and flowers[j] >= target:
            j -= 1
        
        if j < 0:
            return n * full
        
        for k in range(n, -1, -1):
            if k > 0:
                required = target * k - (prefix[n] - prefix[n - k])
                if required > newFlowers:
                    continue
                remaining = newFlowers - required
                if remaining <= 0:
                    current = k * full
                    if current > res:
                        res = current
                    continue
                low = 0
                high = target - 1
                best_min = 0
                while low <= high:
                    mid = (low + high) // 2
                    left = 0
                    right = n - k - 1
                    pos = -1
                    while left <= right:
                        m = (left + right) // 2
                        if flowers[m] < mid:
                            pos = m
                            left = m + 1
                        else:
                            right = m - 1
                    if pos == -1:
                        high = mid - 1
                    else:
                        total = mid * (pos + 1) - prefix[pos + 1]
                        if total <= remaining:
                            best_min = mid
                            low = mid + 1
                        else:
                            high = mid - 1
                current = k * full + best_min * partial
                if current > res:
                    res = current
            else:
                low = 0
                high = target - 1
                best_min = 0
                while low <= high:
                    mid = (low + high) // 2
                    left = 0
                    right = n - 1
                    pos = -1
                    while left <= right:
                        m = (left + right) // 2
                        if flowers[m] < mid:
                            pos = m
                            left = m + 1
                        else:
                            right = m - 1
                    if pos == -1:
                        high = mid - 1
                    else:
                        total = mid * (pos + 1) - prefix[pos + 1]
                        if total <= newFlowers:
                            best_min = mid
                            low = mid + 1
                        else:
                            high = mid - 1
                current = best_min * partial
                if current > res:
                    res = current
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 23, 'lineno': 2}, {'name': 'maximumBeauty', 'complexity': 22, 'lineno': 3}], 'maintainability_index': 33.491844937403016, 'raw_metrics': {'loc': 81, 'lloc': 81, 'sloc': 81, 'comments': 0}}"
count-good-triplets-in-an-array,"```python
import bisect

class Solution:
    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        pos2 = [0] * n
        for idx, num in enumerate(nums2):
            pos2[num] = idx
        
        pos_in_nums2 = [0] * n
        for i in range(n):
            pos_in_nums2[i] = pos2[nums1[i]]
        
        res = 0
        sorted_list = []
        for i in range(n):
            y = pos_in_nums2[i]
            left = bisect.bisect_left(sorted_list, y)
            right = len(sorted_list) - left
            res += left * (n - 1 - i - right)
            bisect.insort(sorted_list, y)
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 3}, {'name': 'goodTriplets', 'complexity': 4, 'lineno': 4}], 'maintainability_index': 57.066974603972284, 'raw_metrics': {'loc': 20, 'lloc': 20, 'sloc': 20, 'comments': 0}}"
maximum-fruits-harvested-after-at-most-k-steps,"```python
class Solution:
    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:
        left = 0
        right = 0
        n = len(fruits)
        max_fruits = 0
        current_sum = 0
        
        positions = [pos for pos, _ in fruits]
        amounts = [amount for _, amount in fruits]
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i+1] = prefix[i] + amounts[i]
        
        for i in range(n):
            pos = fruits[i][0]
            if pos <= startPos:
                steps = startPos - pos
                remaining = k - steps
                if remaining >= 0:
                    max_right = startPos + remaining
                    l, r = i, n - 1
                    best = i
                    while l <= r:
                        mid = (l + r) // 2
                        if fruits[mid][0] <= max_right:
                            best = mid
                            l = mid + 1
                        else:
                            r = mid - 1
                    current = prefix[best + 1] - prefix[i]
                    if current > max_fruits:
                        max_fruits = current
            if pos >= startPos:
                steps = pos - startPos
                remaining = k - steps
                if remaining >= 0:
                    min_left = startPos - remaining
                    l, r = 0, i
                    best = i
                    while l <= r:
                        mid = (l + r) // 2
                        if fruits[mid][0] >= min_left:
                            best = mid
                            r = mid - 1
                        else:
                            l = mid + 1
                    current = prefix[i + 1] - prefix[best]
                    if current > max_fruits:
                        max_fruits = current
        
        return max_fruits
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 16, 'lineno': 2}, {'name': 'maxTotalFruits', 'complexity': 15, 'lineno': 3}], 'maintainability_index': 41.794230675542096, 'raw_metrics': {'loc': 50, 'lloc': 50, 'sloc': 50, 'comments': 0}}"
sequentially-ordinal-rank-tracker,"```python
import heapq

class SORTracker:

    def __init__(self):
        self.min_heap = []
        self.max_heap = []
        self.get_count = 0

    def add(self, name: str, score: int) -> None:
        if self.min_heap and (-self.min_heap[0][0] > score or (-self.min_heap[0][0] == score and self.min_heap[0][1] < name)):
            val = heapq.heappop(self.min_heap)
            heapq.heappush(self.max_heap, (-val[0], val[1]))
            heapq.heappush(self.min_heap, (-score, name))
        else:
            heapq.heappush(self.max_heap, (score, name))
        
        if len(self.max_heap) > self.get_count:
            val = heapq.heappop(self.max_heap)
            heapq.heappush(self.min_heap, (-val[0], val[1]))

    def get(self) -> str:
        self.get_count += 1
        result = self.min_heap[0][1]
        if self.max_heap and len(self.min_heap) < self.get_count:
            val = heapq.heappop(self.max_heap)
            heapq.heappush(self.min_heap, (-val[0], val[1]))
        return result
```","{'cyclomatic_complexity': [{'name': 'SORTracker', 'complexity': 4, 'lineno': 2}, {'name': '__init__', 'complexity': 1, 'lineno': 3}, {'name': 'add', 'complexity': 6, 'lineno': 7}, {'name': 'get', 'complexity': 3, 'lineno': 17}], 'maintainability_index': 52.612737595439526, 'raw_metrics': {'loc': 23, 'lloc': 23, 'sloc': 23, 'comments': 0}}"
maximum-number-of-tasks-you-can-assign,"```python
import bisect

class Solution:
    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:
        tasks.sort()
        workers.sort()
        
        left, right = 0, min(len(tasks), len(workers))
        answer = 0
        
        def is_possible(k):
            if k == 0:
                return True
            available_workers = workers[-k:]
            remaining_pills = pills
            task_ptr = 0
            dq = []
            
            for worker in available_workers:
                if task_ptr < k:
                    if worker >= tasks[task_ptr]:
                        task_ptr += 1
                    else:
                        if remaining_pills > 0 and worker + strength >= tasks[task_ptr]:
                            remaining_pills -= 1
                            task_ptr += 1
                        else:
                            pass
            return task_ptr == k
        
        while left <= right:
            mid = (left + right) // 2
            if is_possible(mid):
                answer = mid
                left = mid + 1
            else:
                right = mid - 1
        return answer
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'maxTaskAssign', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 49.10881711607731, 'raw_metrics': {'loc': 34, 'lloc': 35, 'sloc': 34, 'comments': 0}}"
number-of-valid-move-combinations-on-chessboard,"```python
class Solution:
    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:
        directions = {
            'rook': [(1, 0), (-1, 0), (0, 1), (0, -1)],
            'bishop': [(1, 1), (1, -1), (-1, 1), (-1, -1)],
            'queen': [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)]
        }
        
        n = len(pieces)
        targets = []
        
        for i in range(n):
            piece = pieces[i]
            r, c = positions[i]
            dirs = directions['queen'] if piece == 'queen' else directions[piece]
            possible = []
            for dr, dc in dirs:
                nr, nc = r, c
                while True:
                    nr += dr
                    nc += dc
                    if 1 <= nr <= 8 and 1 <= nc <= 8:
                        possible.append((nr, nc))
                    else:
                        break
            possible.append((r, c))
            targets.append(possible)
        
        from itertools import product
        
        count = 0
        
        for dests in product(*targets):
            valid = True
            occupied = set()
            for i in range(n):
                r, c = positions[i]
                tr, tc = dests[i]
                if (r, c) == (tr, tc):
                    occupied.add((r, c))
                    continue
                dr = 1 if tr > r else (-1 if tr < r else 0)
                dc = 1 if tc > c else (-1 if tc < c else 0)
                steps = max(abs(tr - r), abs(tc - c))
                for step in range(1, steps + 1):
                    pos = (r + dr * step, c + dc * step)
                    if pos in occupied:
                        valid = False
                        break
                    occupied.add(pos)
                if not valid:
                    break
            if valid:
                count += 1
        
        return count
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 19, 'lineno': 2}, {'name': 'countCombinations', 'complexity': 18, 'lineno': 3}], 'maintainability_index': 41.982215289461955, 'raw_metrics': {'loc': 51, 'lloc': 48, 'sloc': 51, 'comments': 0}}"
maximum-number-of-ways-to-partition-an-array,"```python
from typing import List
from collections import defaultdict

class Solution:
    def waysToPartition(self, nums: List[int], k: int) -> int:
        n = len(nums)
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i+1] = prefix[i] + nums[i]
        total = prefix[n]
        
        res = 0
        for pivot in range(1, n):
            if prefix[pivot] == total - prefix[pivot]:
                res += 1
        
        left_counts = defaultdict(int)
        right_counts = defaultdict(int)
        
        for pivot in range(1, n):
            s = prefix[pivot]
            right_counts[total - 2 * s] += 1
        
        max_changes = 0
        for i in range(n):
            delta = k - nums[i]
            
            cnt = right_counts.get(delta, 0)
            cnt += left_counts.get(total - delta, 0)
            
            if cnt > max_changes:
                max_changes = cnt
            
            if i < n - 1:
                pivot = i + 1
                s = prefix[pivot]
                key = total - 2 * s
                right_counts[key] -= 1
                new_key = (total + 2 * delta) - 2 * s  # Not sure, maybe better to recompute
                left_key = total - 2 * s
                left_counts[left_key] += 1
        
        return max(res, max_changes)
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 4}, {'name': 'waysToPartition', 'complexity': 8, 'lineno': 5}], 'maintainability_index': 56.78115245205757, 'raw_metrics': {'loc': 35, 'lloc': 35, 'sloc': 35, 'comments': 1}}"
find-array-given-subset-sums,"```python
from collections import defaultdict

class Solution:
    def recoverArray(self, n: int, sums: List[int]) -> List[int]:
        sums.sort()
        res = []
        while len(sums) > 1:
            num = sums[-1] - sums[-2]
            freq = defaultdict(int)
            for x in sums:
                freq[x] += 1
            new_sums = []
            new_sums_zero = []
            found_zero = False
            for x in sums:
                if freq[x] > 0:
                    if x == 0:
                        found_zero = True
                    if found_zero:
                        if freq[x + num] > 0:
                            new_sums_zero.append(x)
                            freq[x] -= 1
                            freq[x + num] -= 1
                    else:
                        pass
                    if not found_zero:
                        if freq[x + num] > 0:
                            new_sums.append(x)
                            freq[x] -= 1
                            freq[x + num] -= 1
            if found_zero:
                sums = new_sums_zero
                res.append(num)
            else:
                sums = new_sums
                res.append(-num)
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 3}, {'name': 'recoverArray', 'complexity': 11, 'lineno': 4}], 'maintainability_index': 47.514183207564365, 'raw_metrics': {'loc': 37, 'lloc': 37, 'sloc': 37, 'comments': 0}}"
number-of-ways-to-separate-numbers,"```python
class Solution:
    def numberOfCombinations(self, num: str) -> int:
        MOD = 10**9 + 7
        n = len(num)
        if num[0] == '0':
            return 0
        
        lcp = [[0] * (n + 1) for _ in range(n + 1)]
        for i in range(n-1, -1, -1):
            for j in range(n-1, -1, -1):
                if num[i] == num[j]:
                    lcp[i][j] = lcp[i+1][j+1] + 1
        
        dp = [[0] * (n + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        
        for i in range(1, n + 1):
            if num[i-1] == '0':
                continue
            for l in range(1, i + 1):
                j = i - l
                if j < 0:
                    continue
                res = 0
                if j >= l:
                    res = dp[j][l-1]
                if j >= l:
                    k = j - l
                    if k >= 0:
                        common = lcp[k][j]
                        if common < l and num[k + common] < num[j + common]:
                            res += dp[j][l]
                            res %= MOD
                else:
                    res += dp[j][j] if j > 0 else 0
                    res %= MOD
                dp[i][l] = (dp[i][l-1] + res) % MOD
        
        return dp[n][n]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 18, 'lineno': 1}, {'name': 'numberOfCombinations', 'complexity': 17, 'lineno': 2}], 'maintainability_index': 44.071125575869075, 'raw_metrics': {'loc': 35, 'lloc': 35, 'sloc': 35, 'comments': 0}}"
longest-common-subpath,"```python
import bisect
from typing import List

class Solution:
    def longestCommonSubpath(self, n: int, paths: List[List[int]]) -> int:
        if not paths:
            return 0
        
        paths.sort(key=lambda x: len(x))
        shortest_path = paths[0]
        m = len(shortest_path)
        
        base = 10**5 + 3
        mod = 10**11 + 7
        
        max_len = m
        power = [1] * (max_len + 1)
        for i in range(1, max_len + 1):
            power[i] = (power[i-1] * base) % mod
        
        def get_subpath_hashes(path, L):
            if L == 0:
                return []
            h = 0
            for i in range(L):
                h = (h * base + path[i]) % mod
            hashes = [h]
            for i in range(L, len(path)):
                h = (h * base - path[i - L] * power[L] + path[i]) % mod
                hashes.append(h)
            return hashes
        
        low, high = 0, m
        result = 0
        while low <= high:
            mid = (low + high) // 2
            common_hashes = set(get_subpath_hashes(shortest_path, mid))
            
            for path in paths[1:]:
                if len(path) < mid:
                    common_hashes = set()
                    break
                current_hashes = set(get_subpath_hashes(path, mid))
                common_hashes.intersection_update(current_hashes)
                if not common_hashes:
                    break
            
            if common_hashes:
                result = mid
                low = mid + 1
            else:
                high = mid - 1
        
        return result
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 9, 'lineno': 4}, {'name': 'longestCommonSubpath', 'complexity': 8, 'lineno': 5}], 'maintainability_index': 43.65129677688793, 'raw_metrics': {'loc': 46, 'lloc': 47, 'sloc': 46, 'comments': 0}}"
minimum-cost-to-reach-destination-in-time,"```python
import heapq
from typing import List

class Solution:
    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:
        n = len(passingFees)
        graph = [[] for _ in range(n)]
        for x, y, time in edges:
            graph[x].append((y, time))
            graph[y].append((x, time))
        
        heap = []
        heapq.heappush(heap, (passingFees[0], 0, 0))
        
        min_time = [float('inf')] * n
        min_time[0] = 0
        
        while heap:
            current_cost, current_time, current_node = heapq.heappop(heap)
            if current_node == n - 1:
                return current_cost
            if current_time > min_time[current_node]:
                continue
            for neighbor, time in graph[current_node]:
                new_time = current_time + time
                if new_time > maxTime:
                    continue
                if new_time < min_time[neighbor]:
                    min_time[neighbor] = new_time
                    heapq.heappush(heap, (current_cost + passingFees[neighbor], new_time, neighbor))
        
        return -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 4}, {'name': 'minCost', 'complexity': 9, 'lineno': 5}], 'maintainability_index': 52.728033045922565, 'raw_metrics': {'loc': 28, 'lloc': 28, 'sloc': 28, 'comments': 0}}"
the-earliest-and-latest-rounds-where-players-compete,"```python
class Solution:
    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:
        from functools import lru_cache

        firstPlayer -= 1
        secondPlayer -= 1

        @lru_cache(maxsize=None)
        def dp(mask, round):
            players = []
            for i in range(n):
                if mask & (1 << i):
                    players.append(i)
            if len(players) < 2:
                return (float('inf'), float('-inf'))
            
            next_players = []
            left = 0
            right = len(players) - 1
            while left < right:
                a = players[left]
                b = players[right]
                if (a == firstPlayer and b == secondPlayer) or (a == secondPlayer and b == firstPlayer):
                    return (round, round)
                if a == firstPlayer or a == secondPlayer:
                    next_players.append(a)
                elif b == firstPlayer or b == secondPlayer:
                    next_players.append(b)
                else:
                    next_players.append(a)  # or b, but we need to explore both possibilities
                left += 1
                right -= 1
            if left == right:
                next_players.append(players[left])
            
            next_players.sort()
            next_mask = 0
            for p in next_players:
                next_mask |= (1 << p)
            
            min_round = float('inf')
            max_round = float('-inf')
            if next_mask != mask:
                res = dp(next_mask, round + 1)
                min_round = min(min_round, res[0])
                max_round = max(max_round, res[1])
            else:
                pass
            return (min_round, max_round)
        
        initial_mask = (1 << n) - 1
        result = dp(initial_mask, 1)
        return [result[0], result[1]] if result[0] != float('inf') else [0, 0]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 3, 'lineno': 2}, {'name': 'earliestAndLatest', 'complexity': 2, 'lineno': 3}], 'maintainability_index': 52.6920128015374, 'raw_metrics': {'loc': 48, 'lloc': 48, 'sloc': 48, 'comments': 1}}"
design-movie-rental-system,"```python
import heapq
from collections import defaultdict

class MovieRentingSystem:

    def __init__(self, n: int, entries: List[List[int]]):
        self.unrented = defaultdict(list)  # movie -> list of (price, shop) min-heap
        self.rented = []  # min-heap of (price, shop, movie)
        self.shop_movie_price = {}  # (shop, movie) -> price
        self.rented_set = set()  # (shop, movie)
        
        for shop, movie, price in entries:
            self.shop_movie_price[(shop, movie)] = price
            heapq.heappush(self.unrented[movie], (price, shop))
        
    def search(self, movie: int) -> List[int]:
        res = []
        temp_heap = []
        available = self.unrented.get(movie, [])
        
        while available and len(res) < 5:
            price, shop = heapq.heappop(available)
            if (shop, movie) not in self.rented_set:
                res.append(shop)
                temp_heap.append((price, shop))
        
        for price, shop in temp_heap:
            heapq.heappush(available, (price, shop))
        
        return res

    def rent(self, shop: int, movie: int) -> None:
        price = self.shop_movie_price[(shop, movie)]
        self.rented_set.add((shop, movie))
        heapq.heappush(self.rented, (price, shop, movie))

    def drop(self, shop: int, movie: int) -> None:
        price = self.shop_movie_price[(shop, movie)]
        self.rented_set.remove((shop, movie))
        heapq.heappush(self.unrented[movie], (price, shop))

    def report(self) -> List[List[int]]:
        res = []
        temp = []
        
        while self.rented and len(res) < 5:
            price, shop, movie = heapq.heappop(self.rented)
            if (shop, movie) in self.rented_set:
                res.append([shop, movie])
                temp.append((price, shop, movie))
        
        for item in temp:
            heapq.heappush(self.rented, item)
        
        return res
```","{'cyclomatic_complexity': [{'name': 'MovieRentingSystem', 'complexity': 4, 'lineno': 4}, {'name': '__init__', 'complexity': 2, 'lineno': 5}, {'name': 'search', 'complexity': 5, 'lineno': 13}, {'name': 'rent', 'complexity': 1, 'lineno': 25}, {'name': 'drop', 'complexity': 1, 'lineno': 29}, {'name': 'report', 'complexity': 5, 'lineno': 33}], 'maintainability_index': 66.6181234453772, 'raw_metrics': {'loc': 43, 'lloc': 43, 'sloc': 43, 'comments': 4}}"
minimum-skips-to-arrive-at-meeting-on-time,"```python
from typing import List

class Solution:
    def minSkips(self, dist: List[int], speed: int, hoursBefore: int) -> int:
        n = len(dist)
        INF = float('inf')
        dp = [[INF] * (n + 1) for _ in range(n + 1)]
        dp[0][0] = 0.0
        
        for i in range(1, n + 1):
            d = dist[i - 1]
            for j in range(i + 1):
                if j > 0:
                    dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + d / speed)
                if j < i:
                    wait_time = math.ceil(dp[i - 1][j]) - dp[i - 1][j] if (dp[i - 1][j] % 1 != 0) else 0.0
                    dp[i][j] = min(dp[i][j], math.ceil(dp[i - 1][j] + wait_time) + d / speed)
        
        for skips in range(n + 1):
            if dp[n][skips] <= hoursBefore + 1e-9:
                return skips
        return -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 3}, {'name': 'minSkips', 'complexity': 9, 'lineno': 4}], 'maintainability_index': 52.144038425677316, 'raw_metrics': {'loc': 20, 'lloc': 20, 'sloc': 20, 'comments': 0}}"
finding-mk-average,"```python
import heapq
from collections import deque

class MKAverage:

    def __init__(self, m: int, k: int):
        self.m = m
        self.k = k
        self.stream = deque()
        self.min_heap = []
        self.max_heap = []
        self.mid_heap = []
        self.min_heap_removed = {}
        self.max_heap_removed = {}
        self.mid_heap_removed = {}
        self.sum_mid = 0
        self.count_mid = 0

    def addElement(self, num: int) -> None:
        self.stream.append(num)
        if len(self.stream) > self.m:
            removed = self.stream.popleft()
            if removed in self.min_heap_removed:
                self.min_heap_removed[removed] += 1
            else:
                self.min_heap_removed[removed] = 1
            if removed in self.max_heap_removed:
                self.max_heap_removed[removed] += 1
            else:
                self.max_heap_removed[removed] = 1
            if removed in self.mid_heap_removed:
                self.mid_heap_removed[removed] += 1
            else:
                self.mid_heap_removed[removed] = 1
        
        heapq.heappush(self.min_heap, num)
        heapq.heappush(self.max_heap, -num)
        
        if len(self.stream) <= self.m:
            return
        
        self._balance_heaps()

    def _balance_heaps(self):
        while self.min_heap and self.min_heap[0] in self.min_heap_removed:
            val = heapq.heappop(self.min_heap)
            self.min_heap_removed[val] -= 1
            if self.min_heap_removed[val] == 0:
                del self.min_heap_removed[val]
        
        while self.max_heap and -self.max_heap[0] in self.max_heap_removed:
            val = -heapq.heappop(self.max_heap)
            self.max_heap_removed[val] -= 1
            if self.max_heap_removed[val] == 0:
                del self.max_heap_removed[val]
        
        while len(self.min_heap) > self.k:
            val = heapq.heappop(self.min_heap)
            heapq.heappush(self.mid_heap, val)
            self.sum_mid += val
            self.count_mid += 1
        
        while len(self.max_heap) > self.k:
            val = -heapq.heappop(self.max_heap)
            heapq.heappush(self.mid_heap, val)
            self.sum_mid += val
            self.count_mid += 1
        
        while self.mid_heap and self.mid_heap[0] in self.mid_heap_removed:
            val = heapq.heappop(self.mid_heap)
            self.mid_heap_removed[val] -= 1
            if self.mid_heap_removed[val] == 0:
                del self.mid_heap_removed[val]
            self.sum_mid -= val
            self.count_mid -= 1

    def calculateMKAverage(self) -> int:
        if len(self.stream) < self.m:
            return -1
        
        self._balance_heaps()
        
        if self.count_mid == 0:
            return 0
        
        return self.sum_mid // self.count_mid


```","{'cyclomatic_complexity': [{'name': 'MKAverage', 'complexity': 6, 'lineno': 3}, {'name': '__init__', 'complexity': 1, 'lineno': 4}, {'name': 'addElement', 'complexity': 6, 'lineno': 16}, {'name': '_balance_heaps', 'complexity': 12, 'lineno': 37}, {'name': 'calculateMKAverage', 'complexity': 3, 'lineno': 65}], 'maintainability_index': 37.066508640800045, 'raw_metrics': {'loc': 71, 'lloc': 71, 'sloc': 71, 'comments': 0}}"
maximum-number-of-groups-getting-fresh-donuts,"```python
from typing import List
from functools import lru_cache

class Solution:
    def maxHappyGroups(self, batchSize: int, groups: List[int]) -> int:
        count = [0] * batchSize
        for num in groups:
            remainder = num % batchSize
            if remainder != 0:
                count[remainder] += 1
        
        res = count[0]
        count[0] = 0
        
        for i in range(1, batchSize // 2 + 1):
            j = batchSize - i
            if i == j:
                res += count[i] // 2
                count[i] %= 2
            else:
                min_val = min(count[i], count[j])
                res += min_val
                count[i] -= min_val
                count[j] -= min_val
        
        @lru_cache(maxsize=None)
        def dfs(remainder, cnt_tuple):
            cnt = list(cnt_tuple)
            res = 0
            for i in range(1, batchSize):
                if cnt[i] == 0:
                    continue
                cnt[i] -= 1
                new_remainder = (remainder - i) % batchSize
                current = 1 if new_remainder == 0 else 0
                res = max(res, current + dfs(new_remainder, tuple(cnt)))
                cnt[i] += 1
            return res
        
        max_additional = dfs(0, tuple(count))
        return res + max_additional
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 6, 'lineno': 4}, {'name': 'maxHappyGroups', 'complexity': 5, 'lineno': 5}], 'maintainability_index': 47.2024516445348, 'raw_metrics': {'loc': 37, 'lloc': 37, 'sloc': 37, 'comments': 0}}"
tree-of-coprimes,"```python
import math
from collections import defaultdict, deque
from typing import List

class Solution:
    def getCoprimes(self, nums: List[int], edges: List[List[int]]) -> List[int]:
        n = len(nums)
        tree = defaultdict(list)
        for u, v in edges:
            tree[u].append(v)
            tree[v].append(u)
        
        ans = [-1] * n
        stack = [[] for _ in range(51)]  # nums[i] is up to 50
        visited = [False] * n
        
        q = deque()
        q.append((0, -1, 0))  # (node, parent, depth)
        visited[0] = True
        
        while q:
            node, parent, depth = q.popleft()
            current_val = nums[node]
            best_depth = -1
            best_ancestor = -1
            
            for val in range(1, 51):
                if stack[val] and math.gcd(val, current_val) == 1:
                    last_node, last_depth = stack[val][-1]
                    if last_depth > best_depth:
                        best_depth = last_depth
                        best_ancestor = last_node
            
            ans[node] = best_ancestor
            stack[current_val].append((node, depth))
            
            for neighbor in tree[node]:
                if not visited[neighbor] and neighbor != parent:
                    visited[neighbor] = True
                    q.append((neighbor, node, depth + 1))
            
            stack[current_val].pop()
        
        return ans
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 12, 'lineno': 5}, {'name': 'getCoprimes', 'complexity': 11, 'lineno': 6}], 'maintainability_index': 62.66943407049444, 'raw_metrics': {'loc': 36, 'lloc': 36, 'sloc': 36, 'comments': 2}}"
minimum-adjacent-swaps-for-k-consecutive-ones,"```python
from typing import List

class Solution:
    def minMoves(self, nums: List[int], k: int) -> int:
        ones = [i for i, num in enumerate(nums) if num == 1]
        n = len(ones)
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i+1] = prefix[i] + ones[i]
        
        res = float('inf')
        radius = (k - 1) // 2
        
        for i in range(n - k + 1):
            j = i + k - 1
            mid = (i + j) // 2
            left = ones[mid] * (mid - i) - (prefix[mid] - prefix[i])
            right = (prefix[j+1] - prefix[mid+1]) - ones[mid] * (j - mid)
            total = left + right
            if k % 2 == 0:
                total += ones[mid+1] - ones[mid] - 1
                total -= radius
            res = min(res, total)
        
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 7, 'lineno': 3}, {'name': 'minMoves', 'complexity': 6, 'lineno': 4}], 'maintainability_index': 50.830059958025515, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 0}}"
minimum-initial-energy-to-finish-tasks,"```python
from typing import List

class Solution:
    def minimumEffort(self, tasks: List[List[int]]) -> int:
        tasks.sort(key=lambda x: (x[1] - x[0]))
        res = 0
        curr_energy = 0
        for actual, minimum in tasks:
            if curr_energy < minimum:
                res += minimum - curr_energy
                curr_energy = minimum
            curr_energy -= actual
        return res
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 4, 'lineno': 3}, {'name': 'minimumEffort', 'complexity': 3, 'lineno': 4}], 'maintainability_index': 62.57460486092825, 'raw_metrics': {'loc': 13, 'lloc': 14, 'sloc': 13, 'comments': 0}}"
maximize-grid-happiness,"```python
class Solution:
    def getMaxGridHappiness(self, m: int, n: int, introvertsCount: int, extrovertsCount: int) -> int:
        from functools import lru_cache
        
        total_positions = m * n
        neighbors = [(0, -1), (-1, 0)]
        
        @lru_cache(maxsize=None)
        def dp(position, intro_remain, extro_remain, prev_n):
            if position == total_positions or (intro_remain == 0 and extro_remain == 0):
                return 0
            
            row, col = position // n, position % n
            res = dp(position + 1, intro_remain, extro_remain, prev_n[1:] + (0,))
            
            if intro_remain > 0:
                temp = 120
                up = prev_n[0] if row > 0 else 0
                left = prev_n[-1] if col > 0 else 0
                for neighbor in (up, left):
                    if neighbor == 1:  # introvert neighbor
                        temp -= 30
                    elif neighbor == 2:  # extrovert neighbor
                        temp -= 30
                for neighbor in (up, left):
                    if neighbor == 1:  # introvert neighbor
                        temp -= 30
                    elif neighbor == 2:  # extrovert neighbor
                        temp += 20
                new_prev_n = prev_n[1:] + (1,)
                res = max(res, temp + dp(position + 1, intro_remain - 1, extro_remain, new_prev_n))
            
            if extro_remain > 0:
                temp = 40
                up = prev_n[0] if row > 0 else 0
                left = prev_n[-1] if col > 0 else 0
                for neighbor in (up, left):
                    if neighbor == 1:  # introvert neighbor
                        temp += 20
                    elif neighbor == 2:  # extrovert neighbor
                        temp += 20
                new_prev_n = prev_n[1:] + (2,)
                res = max(res, temp + dp(position + 1, intro_remain, extro_remain - 1, new_prev_n))
            
            return res
        
        return dp(0, introvertsCount, extrovertsCount, tuple([0] * n))
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 2, 'lineno': 1}, {'name': 'getMaxGridHappiness', 'complexity': 1, 'lineno': 2}], 'maintainability_index': 65.50806401735315, 'raw_metrics': {'loc': 40, 'lloc': 43, 'sloc': 40, 'comments': 6}}"
minimum-cost-to-connect-two-groups-of-points,"```python
class Solution:
    def connectTwoGroups(self, cost: List[List[int]]) -> int:
        size1, size2 = len(cost), len(cost[0])
        min_cost2 = [min(cost[i][j] for i in range(size1)) for j in range(size2)]
        
        dp = [[float('inf')] * (1 << size2) for _ in range(size1 + 1)]
        dp[0][0] = 0
        
        for i in range(1, size1 + 1):
            for mask in range(1 << size2):
                for j in range(size2):
                    new_mask = mask | (1 << j)
                    if dp[i - 1][mask] + cost[i - 1][j] < dp[i][new_mask]:
                        dp[i][new_mask] = dp[i - 1][mask] + cost[i - 1][j]
                if dp[i - 1][mask] + min_cost2[j] < dp[i][mask]:
                    dp[i][mask] = dp[i - 1][mask] + min_cost2[j]
        
        return dp[size1][(1 << size2) - 1]
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 10, 'lineno': 2}, {'name': 'connectTwoGroups', 'complexity': 9, 'lineno': 3}], 'maintainability_index': 55.0146184884951, 'raw_metrics': {'loc': 16, 'lloc': 16, 'sloc': 16, 'comments': 0}}"
parallel-courses-ii,"```python
from typing import List
from collections import deque

class Solution:
    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:
        graph = [[] for _ in range(n + 1)]
        in_degree = [0] * (n + 1)
        for u, v in relations:
            graph[u].append(v)
            in_degree[v] += 1
        
        queue = deque()
        for i in range(1, n + 1):
            if in_degree[i] == 0:
                queue.append(i)
        
        semesters = 0
        while queue:
            semester_courses = []
            for _ in range(min(k, len(queue))):
                course = queue.popleft()
                semester_courses.append(course)
            
            for course in semester_courses:
                for neighbor in graph[course]:
                    in_degree[neighbor] -= 1
                    if in_degree[neighbor] == 0:
                        queue.append(neighbor)
            
            semesters += 1
        
        return semesters
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 11, 'lineno': 4}, {'name': 'minNumberOfSemesters', 'complexity': 10, 'lineno': 5}], 'maintainability_index': 53.20878983499439, 'raw_metrics': {'loc': 27, 'lloc': 27, 'sloc': 27, 'comments': 0}}"
paint-house-iii,"```python
class Solution:
    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:
        dp = [[[float('inf')] * (target + 1) for _ in range(n + 1)] for __ in range(m + 1)]
        
        for j in range(n + 1):
            dp[0][j][0] = 0
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                for k in range(1, target + 1):
                    if houses[i - 1] != 0 and houses[i - 1] != j:
                        continue  # can't paint to color j if already painted to another color
                    
                    current_cost = 0
                    if houses[i - 1] == 0:
                        current_cost = cost[i - 1][j - 1]  # j is 1-based, cost is 0-based
                    
                    min_cost = dp[i - 1][j][k]
                    
                    for prev_color in range(1, n + 1):
                        if prev_color != j:
                            if dp[i - 1][prev_color][k - 1] < min_cost:
                                min_cost = dp[i - 1][prev_color][k - 1]
                    
                    dp[i][j][k] = min_cost + current_cost
        
        result = min(dp[m][j][target] for j in range(1, n + 1))
        return result if result != float('inf') else -1
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 16, 'lineno': 2}, {'name': 'minCost', 'complexity': 15, 'lineno': 3}], 'maintainability_index': 67.31473953692718, 'raw_metrics': {'loc': 22, 'lloc': 22, 'sloc': 22, 'comments': 2}}"
probability-of-a-two-boxes-having-the-same-number-of-distinct-balls,"```python
import math
from typing import List

class Solution:
    def getProbability(self, balls: List[int]) -> float:
        total_balls = sum(balls)
        n = total_balls // 2
        k = len(balls)
        
        max_fact = total_balls
        fact = [1] * (max_fact + 1)
        for i in range(1, max_fact + 1):
            fact[i] = fact[i-1] * i
        
        total = fact[total_balls]
        for b in balls:
            total //= fact[b]
        
        self.valid = 0
        
        def backtrack(pos, box1_count, box1_distinct, box2_distinct, box1_comb, box2_comb):
            if pos == k:
                if box1_count == n and box1_distinct == box2_distinct:
                    self.valid += box1_comb * box2_comb
                return
            
            current_ball = balls[pos]
            for i in range(0, current_ball + 1):
                if box1_count + i > n:
                    continue
                new_box1_distinct = box1_distinct + (1 if i > 0 else 0)
                new_box2_distinct = box2_distinct + (1 if (current_ball - i) > 0 else 0)
                new_box1_comb = box1_comb // fact[i]
                new_box2_comb = box2_comb // fact[current_ball - i]
                backtrack(pos + 1, box1_count + i, new_box1_distinct, new_box2_distinct, new_box1_comb, new_box2_comb)
        
        initial_box1_comb = fact[n] * fact[n]
        initial_box2_comb = 1
        for b in balls:
            initial_box1_comb //= fact[b]
        
        backtrack(0, 0, 0, 0, fact[n] * fact[n], 1)
        
        return self.valid / total
```","{'cyclomatic_complexity': [{'name': 'Solution', 'complexity': 5, 'lineno': 4}, {'name': 'getProbability', 'complexity': 4, 'lineno': 5}], 'maintainability_index': 46.48066432677085, 'raw_metrics': {'loc': 36, 'lloc': 36, 'sloc': 36, 'comments': 0}}"
